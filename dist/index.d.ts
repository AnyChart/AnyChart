// Type definitions for anychart
// Project: http://anychart.com/
// Definitions by: AnyChart <http://anychart.com>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyType
declare namespace anychart {
    const DEVELOP: boolean;
    const VERSION: string;
    function appendTheme(value: string | Object): void;
    function area(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function area3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function bar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function bar3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function barmekko(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Mekko;
    function box(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function bubble(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function bubbleMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function bullet(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Bullet;
    function cartesian(): anychart.charts.Cartesian;
    function cartesian3d(): anychart.charts.Cartesian3d;
    function choropleth(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function column(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function column3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function connector(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function financial(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function fromJson(jsonConfig: Object | string): any;
    function fromJsonFile(url: string, onSuccessOrContainer?: string | (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function fromXml(xmlConfig: string | Node): any;
    function fromXmlFile(url: string, onSuccessOrContainer?: string | (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function funnel(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Funnel;
    function ganttProject(): anychart.charts.Gantt;
    function ganttResource(): anychart.charts.Gantt;
    function ganttToolbar(): anychart.ui.GanttToolbar;
    function heatMap(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.HeatMap;
    function hilo(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function licenseKey(value?: string): string;
    function line(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function line3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function map(): anychart.charts.Map;
    function marker(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function markerMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function mekko(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Mekko;
    function mosaic(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Mekko;
    function onDocumentLoad(func: (() => void), scope?: any): void;
    function onDocumentReady(func: (() => void), scope?: any): void;
    function pareto(data?: anychart.data.View | anychart.data.Set | Array<any>): anychart.charts.Pareto;
    function pert(): anychart.charts.Pert;
    function pie(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Pie;
    function pie3d(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Pie;
    function polar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Polar;
    function pyramid(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Pyramid;
    function quadrant(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function radar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Radar;
    function resource(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Resource;
    function scatter(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function seatMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function sparkline(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Sparkline;
    function stock(allowPointSettings?: boolean): anychart.charts.Stock;
    function tagCloud(data?: anychart.data.View | anychart.data.Set | Array<any> | string, settings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.TagCloud;
    function theme(value?: string | Object | Array<(string|Object)>): string | Object | Array<(string|Object)>;
    function treeMap(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod): anychart.charts.TreeMap;
    function venn(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Venn;
    function vertical(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function verticalArea(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function verticalLine(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function waterfall(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Waterfall;
    interface SignalEvent {
        targetBoundsChanged(): boolean;
        targetDataChanged(): boolean;
        targetMetaChanged(): boolean;
        targetNeedsReapplication(): boolean;
        targetNeedsRecalculation(): boolean;
        targetNeedsRedraw(): boolean;
    }
}

declare namespace anychart.charts {
    interface TreeMap extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(value?: Object): anychart.charts.TreeMap;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(value?: anychart.scales.OrdinalColor | anychart.scales.LinearColor | Object | anychart.enums.ScaleTypes | string): anychart.scales.LinearColor;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(value?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod | string): anychart.charts.TreeMap;
        draw(async?: boolean): anychart.core.Chart;
        drillTo(target: anychart.data.Tree.DataItem | Array<any> | string): void;
        drillUp(): void;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        fill(fillFunction?: (() => void)): anychart.charts.TreeMap;
        fill(color: string, opacity?: number): anychart.charts.TreeMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TreeMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TreeMap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        getDrilldownPath(): Array<any>;
        getPixelBounds(): anychart.math.Rect;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.TreeMap;
        headers(): anychart.core.ui.LabelsFactory;
        headers(value?: Object | boolean): anychart.charts.TreeMap;
        headersDisplayMode(): string | anychart.enums.LabelsDisplayMode;
        headersDisplayMode(value?: string | anychart.enums.LabelsDisplayMode): anychart.charts.TreeMap;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hintDepth(): number;
        hintDepth(value?: number): anychart.charts.TreeMap;
        hintOpacity(): number;
        hintOpacity(value?: number): anychart.charts.TreeMap;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.TreeMap;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.TreeMap;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.TreeMap;
        maxDepth(): number;
        maxDepth(value?: number): anychart.charts.TreeMap;
        maxHeadersHeight(): number | string;
        maxHeadersHeight(value?: number | string): anychart.charts.TreeMap;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.TreeMap;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.TreeMap;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.charts.TreeMap;
        sort(): anychart.enums.Sort;
        sort(value?: anychart.enums.Sort | string): anychart.charts.TreeMap;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.charts.TreeMap;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.TreeMap;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Cartesian extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.charts.Cartesian;
        animation(enabled: boolean, duration: number): anychart.charts.Cartesian;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Cartesian;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.charts.Cartesian;
        bar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bar;
        barGroupsPadding(): number;
        barGroupsPadding(value?: number): anychart.charts.Cartesian;
        barsPadding(): number;
        barsPadding(value?: number): anychart.charts.Cartesian;
        bottom(): number | string;
        bottom(value?: number | string): anychart.charts.Cartesian;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        box(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Box;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bubble;
        cancelMarquee(): anychart.core.Chart;
        candlestick(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Candlestick;
        column(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Cartesian;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Cartesian;
        data(): anychart.data.View;
        data(value?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Cartesian;
        defaultSeriesType(): string | anychart.enums.CartesianSeriesType;
        defaultSeriesType(value?: string | anychart.enums.CartesianSeriesType): anychart.charts.Cartesian;
        draw(async?: boolean): anychart.charts.Cartesian;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.cartesian.series.Base;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Cartesian;
        height(): number | string;
        height(value?: number | string): anychart.charts.Cartesian;
        hilo(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Hilo;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.charts.Cartesian;
        jumpLine(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.JumpLine;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.charts.Cartesian;
        label(index?: string | number, value?: boolean | Object | string): anychart.charts.Cartesian;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Cartesian;
        left(): number | string;
        left(value?: number | string): anychart.charts.Cartesian;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.charts.Cartesian;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Cartesian;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.charts.Cartesian;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Cartesian;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Cartesian;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.charts.Cartesian;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.charts.Cartesian;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Cartesian;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Cartesian;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.charts.Cartesian;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.charts.Cartesian;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.charts.Cartesian;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        ohlc(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.OHLC;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.charts.Cartesian;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Cartesian;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Cartesian;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeArea;
        rangeBar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeBar;
        rangeColumn(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeColumn;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Cartesian;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        rangeSplineArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeSplineArea;
        rangeStepArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Cartesian;
        removeSeries(id: number | string): anychart.charts.Cartesian;
        removeSeriesAt(index: number): anychart.charts.Cartesian;
        right(): number | string;
        right(value?: number | string): anychart.charts.Cartesian;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Cartesian;
        spline(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Spline;
        splineArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.SplineArea;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stepArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.StepArea;
        stepLine(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.StepLine;
        stick(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Stick;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Cartesian;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.charts.Cartesian;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Cartesian;
        top(): number | string;
        top(value?: number | string): anychart.charts.Cartesian;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.charts.Cartesian;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Cartesian;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(value?: Object | boolean): anychart.charts.Cartesian;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(value?: Object | boolean): anychart.charts.Cartesian;
        xMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        xScale(): anychart.scales.Base;
        xScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Cartesian;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(value?: Object | boolean): anychart.charts.Cartesian;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(value?: number | boolean | Object): anychart.charts.Cartesian;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Cartesian;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(value?: Object | boolean): anychart.charts.Cartesian;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(value?: Object | boolean): anychart.charts.Cartesian;
        yMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        yScale(): anychart.scales.Base;
        yScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Cartesian;
        zIndex(): number;
        zIndex(value?: number): anychart.charts.Cartesian;
    }
    interface Bullet extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axis(): anychart.core.axes.Linear;
        axis(value?: Object | boolean): anychart.charts.Bullet;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Bullet;
        draw(async?: boolean): anychart.charts.Bullet;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        inMarquee(): boolean;
        isHorizontal(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        layout(): anychart.enums.Layout | string;
        layout(value?: string | anychart.enums.Layout): anychart.charts.Bullet;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: Array<anychart.enums.MarkerType> | Object | anychart.palettes.Markers): anychart.charts.Bullet;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        range(index?: number): anychart.core.axisMarkers.Range;
        range(value?: Object | boolean): anychart.charts.Bullet;
        range(index?: number, value?: Object | boolean): anychart.charts.Bullet;
        rangePalette(): anychart.palettes.DistinctColors;
        rangePalette(value?: anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Bullet;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.charts.Bullet;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Polar extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.polar.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        barGroupsPadding(): number;
        barGroupsPadding(value?: number): anychart.charts.Polar;
        barsPadding(): number;
        barsPadding(value?: number): anychart.charts.Polar;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        column(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        defaultSeriesType(): string;
        defaultSeriesType(value?: string | anychart.enums.PolarSeriesType): anychart.charts.Polar;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.polar.series.Base;
        getSeriesAt(index: number): anychart.core.polar.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXScales(): Array<any>;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Polar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        innerRadius(): number | string;
        innerRadius(value?: number | string): anychart.charts.Polar;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Polar;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Polar;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.charts.Polar;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Polar;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Polar;
        polygon(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.Polygon;
        polyline(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.Polyline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        rangeColumn(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.polar.series.RangeColumn;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Polar;
        removeSeries(id: number | string): anychart.charts.Polar;
        removeSeriesAt(index: number): anychart.charts.Polar;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Polar;
        sortPointsByX(): boolean;
        sortPointsByX(value?: boolean): anychart.charts.Polar;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.charts.Polar;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(): anychart.core.axes.Radar;
        xAxis(value?: Object | boolean): anychart.charts.Radar;
        xGrid(index?: number): anychart.core.grids.Polar;
        xGrid(value?: Object | boolean): anychart.charts.Polar;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.Polar;
        xMinorGrid(index?: number): anychart.core.grids.Polar;
        xMinorGrid(value?: Object | boolean): anychart.charts.Polar;
        xMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Polar;
        xScale(): anychart.scales.Base;
        xScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Polar;
        yAxis(): anychart.core.axes.Radial;
        yAxis(value?: Object | boolean): anychart.charts.Polar;
        yGrid(index?: number): anychart.core.grids.Polar;
        yGrid(value?: Object | boolean): anychart.charts.Polar;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.Polar;
        yMinorGrid(index?: number): anychart.core.grids.Polar;
        yMinorGrid(value?: Object | boolean): anychart.charts.Polar;
        yMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Polar;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: Object | string | anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Polar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Pert extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        criticalPath(): anychart.core.pert.CriticalPath;
        criticalPath(value?: Object): anychart.charts.Pert;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod | string, deps?: Array<anychart.data.Tree.Dependency>): anychart.charts.Pert;
        draw(async?: boolean): anychart.core.Chart;
        expectedTimeCalculator(): (() => void);
        expectedTimeCalculator(value?: (() => void)): anychart.charts.Pert;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalSpacing(): string | number;
        horizontalSpacing(value?: number | string): anychart.charts.Pert;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        milestones(): anychart.core.pert.Milestones;
        milestones(value?: Object): anychart.charts.Pert;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        tasks(): anychart.core.pert.Tasks;
        tasks(value?: Object): anychart.charts.Pert;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalSpacing(): string | number;
        verticalSpacing(value?: number | string): anychart.charts.Pert;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Scatter extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.scatter.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Scatter;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.scatter.series.Bubble;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Scatter;
        crossing(): anychart.core.utils.Crossing;
        crossing(value?: Object): anychart.charts.Scatter;
        defaultSeriesType(): string;
        defaultSeriesType(value?: string): anychart.charts.Scatter;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.scatter.series.Base;
        getSeriesAt(index: number): anychart.core.scatter.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXScales(): Array<any>;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Scatter;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Scatter;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.scatter.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Scatter;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.scatter.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Scatter;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Scatter;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Scatter;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Scatter;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        quarters(): anychart.core.utils.QuarterSettings;
        quarters(value?: Object): anychart.charts.Scatter;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Scatter;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Scatter;
        removeSeries(id: number | string): anychart.charts.Scatter;
        removeSeriesAt(index: number): anychart.charts.Scatter;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Scatter;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Scatter;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Scatter;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(value?: Object | boolean): anychart.charts.Scatter;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(value?: Object | boolean): anychart.charts.Scatter;
        xMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: Object | string | anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Scatter;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Scatter;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(value?: Object | boolean): anychart.charts.Scatter;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(value?: Object | boolean): anychart.charts.Scatter;
        yMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: Object | string | anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Scatter;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Pareto extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Pareto;
        barGroupsPadding(): number;
        barGroupsPadding(value?: number): anychart.charts.Pareto;
        barsPadding(): number;
        barsPadding(value?: number): anychart.charts.Pareto;
        cancelMarquee(): anychart.core.Chart;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Pareto;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | anychart.data.DataSettings | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Pareto;
        defaultSeriesType(): string | anychart.enums.CartesianSeriesType;
        defaultSeriesType(value?: string | anychart.enums.CartesianSeriesType): anychart.charts.Pareto;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPlotBounds(): anychart.math.Rect;
        getSeries(id: number | string): anychart.core.cartesian.series.Base;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pareto;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Pareto;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Pareto;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Pareto;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Pareto;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.charts.Pareto;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Pareto;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.charts.Pareto;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pareto;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Pareto;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Pareto;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        removeAllSeries(): anychart.charts.Pareto;
        removeSeries(id: number | string): anychart.charts.Pareto;
        removeSeriesAt(index: number): anychart.charts.Pareto;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Pareto;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Pareto;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Pareto;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(value?: Object | boolean): anychart.charts.Pareto;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(value?: Object | boolean): anychart.charts.Pareto;
        xMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        xScale(): anychart.scales.Base;
        xScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Pareto;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(value?: Object | boolean): anychart.charts.Pareto;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(value?: number | boolean | Object): anychart.charts.Pareto;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Pareto;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(value?: Object | boolean): anychart.charts.Pareto;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(value?: Object | boolean): anychart.charts.Pareto;
        yMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Pareto;
        yScale(): anychart.scales.Base;
        yScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Pareto;
    }
    interface Venn extends anychart.core.SeparateChart {
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Venn;
        dataSeparator(): string;
        dataSeparator(value?: string): anychart.charts.Venn;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Venn;
        fill(fillFunction?: (() => void)): anychart.charts.Venn;
        fill(color: string, opacity?: number): anychart.charts.Venn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Venn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Venn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Venn;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Venn;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Venn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.charts.Venn;
        hover(index?: number): anychart.charts.Venn;
        hover(indexes?: Array<number>): anychart.charts.Venn;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Venn;
        intersections(): anychart.core.venn.Intersections;
        intersections(value?: Object): anychart.charts.Venn;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Venn;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Venn;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.Venn;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Venn;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Venn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(index?: number): anychart.charts.Venn;
        select(indexes?: number | Array<number>): anychart.charts.Venn;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Venn;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.charts.Venn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Venn;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(indexOrIndexes?: number | Array<number>): anychart.charts.Venn;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Venn;
        unselect(index?: number): anychart.charts.Venn;
        unselect(indexes?: Array<number>): anychart.charts.Venn;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Waterfall extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Waterfall;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Waterfall;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Waterfall;
        data(): anychart.data.View;
        data(value?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Waterfall;
        dataMode(): anychart.enums.WaterfallDataMode | string;
        dataMode(value?: string | anychart.enums.WaterfallDataMode): anychart.charts.Waterfall;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSeries(id: number | string): anychart.core.waterfall.series.Waterfall;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Waterfall;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Waterfall;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Waterfall;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Waterfall;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.charts.Waterfall;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.charts.Waterfall;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Waterfall;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Waterfall;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Waterfall;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Waterfall;
        removeSeries(id: number | string): anychart.charts.Waterfall;
        removeSeriesAt(index: number): anychart.charts.Waterfall;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Waterfall;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Waterfall;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(value?: Object | boolean): anychart.charts.Waterfall;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(value?: Object | boolean): anychart.charts.Waterfall;
        xMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        xScale(): anychart.scales.Base;
        xScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Waterfall;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(value?: Object | boolean): anychart.charts.Waterfall;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(value?: number | boolean | Object): anychart.charts.Waterfall;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Waterfall;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(value?: Object | boolean): anychart.charts.Waterfall;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(value?: Object | boolean): anychart.charts.Waterfall;
        yMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Waterfall;
        yScale(): anychart.scales.Base;
        yScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Waterfall;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface TagCloud extends anychart.core.SeparateChart {
        angles(): Array<number>;
        angles(value?: Array<number>): anychart.charts.TagCloud;
        anglesCount(): number;
        anglesCount(value?: number): anychart.charts.TagCloud;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(value?: Object | boolean): anychart.charts.TagCloud;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | anychart.enums.ScaleTypes | string): anychart.charts.TagCloud;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | anychart.data.DataSettings | string, settings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.TagCloud;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fromAngle(): number;
        fromAngle(value?: number): anychart.charts.TagCloud;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.Point;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index: number | Array<number>): anychart.charts.TagCloud;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.TagCloud;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        mode(): anychart.enums.TagCloudMode;
        mode(value?: anychart.enums.TagCloudMode | string): anychart.charts.TagCloud;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.TagCloud;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.TagCloud;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scale(): anychart.scales.Base;
        scale(value?: anychart.enums.ScaleTypes | anychart.scales.Base | Object): anychart.charts.TagCloud;
        select(index?: number): anychart.charts.TagCloud;
        select(indexes?: Array<number>): anychart.charts.TagCloud;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.TagCloud;
        textSpacing(): number;
        textSpacing(value?: number): anychart.charts.TagCloud;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toAngle(): number;
        toAngle(value?: number): anychart.charts.TagCloud;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.TagCloud;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.TagCloud;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(indexOrIndexes?: number | Array<number>): void;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Cartesian3d extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        area(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Area3d;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bar3d;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        column(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Column3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.Set | Array<any> | anychart.data.DataSettings): anychart.charts.Cartesian3d;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Cartesian3d;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line3d;
        line2d(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.charts.Cartesian3d;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.charts.Cartesian3d;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Cartesian3d;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Cartesian3d;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zAngle(): number;
        zAngle(value?: number): anychart.charts.Cartesian3d;
        zAspect(): number | string;
        zAspect(value?: number | string): anychart.charts.Cartesian3d;
        zDistribution(): boolean;
        zDistribution(value?: boolean): anychart.charts.Cartesian3d;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zPadding(): number;
        zPadding(value?: number): anychart.charts.Cartesian3d;
    }
    interface Stock extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        annotations(): anychart.core.annotations.ChartController;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Stock;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotsCount(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSelectedRange(): Object;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grouping(): anychart.core.stock.Grouping;
        grouping(value?: boolean | Array<(string|anychart.core.stock.Grouping.Level)> | Object): anychart.charts.Stock;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.StockInteractivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        plot(index?: number): anychart.core.stock.Plot;
        plot(value?: Object | boolean): anychart.charts.Stock;
        plot(index?: number, value?: Object | boolean): anychart.charts.Stock;
        preserveSelectedRangeOnDataUpdate(): boolean;
        preserveSelectedRangeOnDataUpdate(value?: boolean): anychart.charts.Stock;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scroller(): anychart.core.stock.Scroller;
        scroller(value?: Object | boolean): anychart.charts.Stock;
        scrollerGrouping(): anychart.core.stock.Grouping;
        scrollerGrouping(value?: boolean | Array<(string|anychart.core.stock.Grouping.Level)> | Object): anychart.charts.Stock;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selectRange(typeOrUnitOrStart: number | string | Date | anychart.enums.StockRangeType | anychart.enums.Interval, endOrCountOrDispatchEvent?: number | string | Date | boolean, anchorOrDispatchEvent?: anychart.enums.StockRangeAnchor | boolean, dispatchEvent?: boolean): anychart.charts.Stock;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        startZoomMarquee(repeat?: boolean, asRect?: boolean): anychart.charts.Stock;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.StockScatterDateTime;
        xScale(value?: string | Object): anychart.charts.Stock;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zoomMarqueeFill(): anychart.graphics.vector.Fill;
        zoomMarqueeFill(value: anychart.graphics.vector.Fill): anychart.charts.Stock;
        zoomMarqueeFill(color: string, opacity?: number): anychart.charts.Stock;
        zoomMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Stock;
        zoomMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Stock;
        zoomMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Stock;
        zoomMarqueeStroke(): anychart.graphics.vector.Stroke;
        zoomMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
    }
    interface Resource extends anychart.core.Chart {
        activities(): anychart.core.resource.Activities;
        activities(value?: Object): anychart.charts.Resource;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        calendar(): anychart.scales.Calendar;
        calendar(value?: Object): anychart.charts.Resource;
        cancelMarquee(): anychart.core.Chart;
        cellPadding(): anychart.core.utils.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.charts.Resource;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Resource;
        conflicts(): anychart.core.resource.Conflicts;
        conflicts(value?: Object): anychart.charts.Resource;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Resource;
        defaultMinutesPerDay(): number;
        defaultMinutesPerDay(value?: number): anychart.charts.Resource;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grid(): anychart.core.resource.Grid;
        grid(value?: Object | boolean): anychart.charts.Resource;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalScrollBar(): anychart.core.ui.Scroller;
        horizontalScrollBar(value?: Object | boolean): anychart.charts.Resource;
        hover(resourceIndex: number, activityIndex: number): anychart.charts.Resource;
        hoverPoint(globalIndex: number): anychart.charts.Resource;
        inMarquee(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        logo(): anychart.core.resource.Logo;
        logo(value?: Object): anychart.charts.Resource;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minRowHeight(): number;
        minRowHeight(value?: number): anychart.charts.Resource;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        overlay(): anychart.core.ui.Overlay;
        overlay(value?: Object | boolean): anychart.charts.Resource;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        pixPerHour(): number;
        pixPerHour(value?: number): anychart.charts.Resource;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        resourceListWidth(): number | string;
        resourceListWidth(value?: number | string): anychart.charts.Resource;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(resourceIndex: number, activityIndex: number): anychart.charts.Resource;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selectPoint(globalIndex: number, event?: anychart.core.MouseEvent): anychart.charts.Resource;
        splitterStroke(): anychart.graphics.vector.Stroke;
        splitterStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Resource;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        timeLine(): anychart.core.resource.TimeLine;
        timeLine(value?: Object | boolean): anychart.charts.Resource;
        timeLineHeight(): number | string;
        timeLineHeight(value?: number | string): anychart.charts.Resource;
        timeTrackingMode(): anychart.enums.TimeTrackingMode;
        timeTrackingMode(value?: anychart.enums.TimeTrackingMode | string): anychart.charts.Resource;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(resourceIndex?: number | Array<number>, activityIndex?: number): anychart.charts.Resource;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(resourceIndex?: number | Array<number>, activityIndex?: number): void;
        verticalScrollBar(): anychart.core.ui.Scroller;
        verticalScrollBar(value?: Object | boolean): anychart.charts.Resource;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.DateTimeWithCalendar;
        xScale(value?: Object): anychart.charts.Resource;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zoomLevel(): number | string;
        zoomLevel(indexOrId?: number | string): anychart.charts.Resource;
        zoomLevels(): Array<anychart.charts.Resource.ZoomLevel>;
        zoomLevels(value?: Array<anychart.charts.Resource.ZoomLevel>): anychart.charts.Resource;
    }
    namespace Resource {
    interface ZoomLevel {
        count: number;
        id: string;
        levels: Array<anychart.core.resource.TimeLine.Level>;
        unit: anychart.enums.Interval;
        unitPixSize: number;
    }
    }
    interface Sparkline extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        clip(): boolean | anychart.math.Rect;
        clip(value?: anychart.math.Rect): anychart.charts.Sparkline;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.charts.Sparkline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Sparkline;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        fill(color: string, opacity?: number): anychart.charts.Sparkline;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstFill(): anychart.graphics.vector.Fill;
        firstFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstFill(color: string, opacity?: number): anychart.charts.Sparkline;
        firstFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        firstFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        firstFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        firstHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        firstLabels(): anychart.core.ui.LabelsFactory.Label;
        firstLabels(value?: Object | boolean): anychart.charts.Sparkline;
        firstMarkers(): anychart.core.ui.MarkersFactory.Marker;
        firstMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        inMarquee(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory.Label;
        labels(value?: Object | boolean): anychart.charts.Sparkline;
        lastFill(): anychart.graphics.vector.Fill;
        lastFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        lastFill(color: string, opacity?: number): anychart.charts.Sparkline;
        lastFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        lastFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        lastFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        lastHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        lastHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        lastLabels(): anychart.core.ui.LabelsFactory.Label;
        lastLabels(value?: Object | boolean): anychart.charts.Sparkline;
        lastMarkers(): anychart.core.ui.MarkersFactory.Marker;
        lastMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Sparkline;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Sparkline;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markers(): anychart.core.ui.MarkersFactory.Marker;
        markers(value?: Object | boolean): anychart.charts.Sparkline;
        maxFill(): anychart.graphics.vector.Fill;
        maxFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        maxFill(color: string, opacity?: number): anychart.charts.Sparkline;
        maxFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        maxFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        maxFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        maxHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        maxHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxLabels(): anychart.core.ui.LabelsFactory.Label;
        maxLabels(value?: Object | boolean): anychart.charts.Sparkline;
        maxMarkers(): anychart.core.ui.MarkersFactory.Marker;
        maxMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minFill(): anychart.graphics.vector.Fill;
        minFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        minFill(color: string, opacity?: number): anychart.charts.Sparkline;
        minFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        minFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        minFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        minHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        minHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minLabels(): anychart.core.ui.LabelsFactory.Label;
        minLabels(value?: Object | boolean): anychart.charts.Sparkline;
        minMarkers(): anychart.core.ui.MarkersFactory.Marker;
        minMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        negativeFill(color: string, opacity?: number): anychart.charts.Sparkline;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        negativeLabels(): anychart.core.ui.LabelsFactory.Label;
        negativeLabels(value?: Object | boolean): anychart.charts.Sparkline;
        negativeMarkers(): anychart.core.ui.MarkersFactory.Marker;
        negativeMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Sparkline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Sparkline;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Sparkline;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        seriesType(): string | anychart.enums.SparklineSeriesType;
        seriesType(type?: string | anychart.enums.SparklineSeriesType): anychart.charts.Sparkline;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(func?: (() => void)): anychart.charts.Sparkline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Sparkline;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Sparkline;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Sparkline;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.enums.ScaleTypes | string | anychart.scales.Base | Object): anychart.charts.Sparkline;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.enums.ScaleTypes | string | anychart.scales.Base | Object): anychart.charts.Sparkline;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.radar.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        defaultSeriesType(): string | anychart.enums.RadarSeriesType;
        defaultSeriesType(value?: string | anychart.enums.RadarSeriesType): anychart.charts.Radar;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.radar.series.Base;
        getSeriesAt(index: number): anychart.core.radar.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXScales(): Array<any>;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Radar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        innerRadius(): number | string;
        innerRadius(value?: number | string): anychart.charts.Radar;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Radar;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Radar;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Radar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Radar;
        removeSeries(id: number | string): anychart.charts.Radar;
        removeSeriesAt(index: number): anychart.charts.Radar;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Radar;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.charts.Radar;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(): anychart.core.axes.Radar;
        xAxis(value?: Object | boolean): anychart.charts.Radar;
        xGrid(index?: number): anychart.core.grids.Radar;
        xGrid(value?: Object | boolean): anychart.charts.Radar;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.Radar;
        xMinorGrid(index?: number): anychart.core.grids.Radar;
        xMinorGrid(value?: Object | boolean): anychart.charts.Radar;
        xMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Radar;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: anychart.scales.Ordinal): anychart.charts.Radar;
        yAxis(): anychart.core.axes.Radar;
        yAxis(value?: Object | boolean): anychart.charts.Radar;
        yGrid(index?: number): anychart.core.grids.Radar;
        yGrid(value?: Object | boolean): anychart.charts.Radar;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.Radar;
        yMinorGrid(index?: number): anychart.core.grids.Radar;
        yMinorGrid(value?: Object | boolean): anychart.charts.Radar;
        yMinorGrid(index?: number, value?: Object | boolean): anychart.charts.Radar;
        yScale(): anychart.scales.Base;
        yScale(value?: Object | string | anychart.scales.Base | anychart.enums.ScaleTypes): anychart.charts.Radar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LinearGauge extends anychart.core.SeparateChart {
        addPointer(...var_args: (number)[]): Array<anychart.core.linearGauge.pointers.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axis(index?: number): anychart.core.axes.LinearGauge;
        axis(value?: Object | boolean): anychart.charts.LinearGauge;
        axis(index?: number, value?: Object | boolean): anychart.charts.LinearGauge;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bar(dataIndex: number): anychart.core.linearGauge.pointers.Bar;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
        defaultPointerType(): anychart.enums.LinearGaugePointerType | string;
        defaultPointerType(value?: string | anychart.enums.LinearGaugePointerType): anychart.charts.LinearGauge;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPointer(id: number | string): anychart.core.linearGauge.pointers.Base;
        getPointerAt(index: number): anychart.core.linearGauge.pointers.Base;
        getPointersCount(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalOffset(): string | number;
        globalOffset(value?: string | number): anychart.charts.LinearGauge;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.LinearGauge;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.charts.LinearGauge;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        layout(): anychart.enums.Layout | string;
        layout(value?: string | anychart.enums.Layout): anychart.charts.LinearGauge;
        led(dataIndex: number): anychart.core.linearGauge.pointers.Led;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(dataIndex: number): anychart.core.linearGauge.pointers.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.LinearGauge;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.LinearGauge;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        rangeBar(dataIndex: number): anychart.core.linearGauge.pointers.RangeBar;
        removeAllListeners(type?: string): number;
        removeAllPointers(): anychart.charts.LinearGauge;
        removePointer(id: number | string): anychart.charts.LinearGauge;
        removePointerAt(index: number): anychart.charts.LinearGauge;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scale(): anychart.scales.Base;
        scale(value?: anychart.enums.ScaleTypes | string | anychart.scales.Base | Object): anychart.charts.LinearGauge;
        scaleBar(index?: number): anychart.core.linearGauge.ScaleBar;
        scaleBar(value?: Object | boolean): anychart.charts.LinearGauge;
        scaleBar(index?: number, value?: Object | boolean): anychart.charts.LinearGauge;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        tank(dataIndex: number): anychart.core.linearGauge.pointers.Tank;
        thermometer(dataIndex: number): anychart.core.linearGauge.pointers.Thermometer;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface HeatMap extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        colorScale(): anychart.scales.OrdinalColor;
        colorScale(value?: anychart.scales.OrdinalColor | Object | anychart.enums.ScaleTypes | string): anychart.charts.HeatMap;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.HeatMap;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        fill(fillFunction?: (() => void)): anychart.charts.HeatMap;
        fill(color: string, opacity?: number): anychart.charts.HeatMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.HeatMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.HeatMap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        getPixelBounds(): anychart.math.Rect;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.HeatMap;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(indexOrIndexes?: number | Array<number>): anychart.charts.HeatMap;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.HeatMap;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.HeatMap;
        labelsDisplayMode(): string | anychart.enums.LabelsDisplayMode;
        labelsDisplayMode(value?: string | anychart.enums.LabelsDisplayMode): anychart.charts.HeatMap;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.HeatMap;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.HeatMap;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(indexOrIndexes?: number | Array<number>): anychart.charts.HeatMap;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.HeatMap;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: (() => void)): anychart.charts.HeatMap;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.HeatMap;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.HeatMap;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(value?: Object | boolean): anychart.charts.HeatMap;
        xGrid(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: anychart.enums.ScaleTypes | anychart.scales.Ordinal): anychart.charts.HeatMap;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(value?: Object | boolean): anychart.charts.HeatMap;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(value?: number | boolean | Object): anychart.charts.HeatMap;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.HeatMap;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(value?: Object | boolean): anychart.charts.HeatMap;
        yGrid(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        yScale(): anychart.scales.Ordinal;
        yScale(value?: anychart.enums.ScaleTypes | anychart.scales.Ordinal): anychart.charts.HeatMap;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(value?: Object | boolean): anychart.charts.HeatMap;
        yZoom(): anychart.core.utils.OrdinalZoom;
        yZoom(value?: number | boolean | Object): anychart.charts.HeatMap;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Gantt extends anychart.core.SeparateChart {
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        collapseAll(): anychart.charts.Gantt;
        collapseTask(taskId: string): anychart.charts.Gantt;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.charts.Gantt;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(value?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod | string): anychart.charts.Gantt;
        dataGrid(): anychart.core.ui.DataGrid;
        dataGrid(enabled?: boolean): anychart.charts.Gantt;
        defaultRowHeight(): number;
        defaultRowHeight(value?: number): anychart.charts.Gantt;
        draw(async?: boolean): anychart.charts.Gantt;
        editing(): boolean;
        editing(value?: boolean): anychart.charts.Gantt;
        expandAll(): anychart.charts.Gantt;
        expandTask(taskId: string): anychart.charts.Gantt;
        fitAll(): anychart.charts.Gantt;
        fitToTask(taskId: string): anychart.charts.Gantt;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getTimeline(): anychart.core.ui.Timeline;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        headerHeight(): number | string;
        headerHeight(value?: number | string): anychart.charts.Gantt;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.charts.Gantt;
        rowHoverFill(color: string, opacity?: number): anychart.charts.Gantt;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.charts.Gantt;
        rowSelectedFill(color: string, opacity?: number): anychart.charts.Gantt;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(value?: anychart.graphics.vector.Stroke | string): anychart.charts.Gantt;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scrollTo(pxOffset: number): anychart.charts.Gantt;
        scrollToEnd(index?: number): anychart.charts.Gantt;
        scrollToRow(rowIndex: number): anychart.charts.Gantt;
        splitterPosition(): number | string;
        splitterPosition(value?: string | number): anychart.charts.Gantt;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.GanttDateTime;
        xScale(value?: Object): anychart.charts.Gantt;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zoomIn(zoomFactor?: number): anychart.charts.Gantt;
        zoomOut(zoomFactor?: number): anychart.charts.Gantt;
        zoomTo(startDate: number, endDate?: number): anychart.charts.Gantt;
        zoomTo(unit: anychart.enums.Interval, count?: number, anchor?: anychart.enums.GanttRangeAnchor): anychart.charts.Gantt;
    }
    interface CircularGauge extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axis(): anychart.core.axes.Circular;
        axis(value?: Object | boolean): anychart.charts.CircularGauge;
        axis(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bar(index?: number): anychart.core.gauge.pointers.Bar;
        bar(value?: Object | boolean): anychart.charts.CircularGauge;
        bar(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        cap(): anychart.core.gauge.Cap;
        cap(value?: Object | boolean): anychart.charts.CircularGauge;
        circularPadding(): string;
        circularPadding(value?: number | string): anychart.charts.CircularGauge;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.CircularGauge;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        encloseWithStraightLine(): boolean;
        encloseWithStraightLine(value?: boolean): anychart.charts.CircularGauge;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill | string): anychart.charts.CircularGauge;
        fill(color: string, opacity?: number): anychart.charts.CircularGauge;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.CircularGauge;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.CircularGauge;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.CircularGauge;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        inMarquee(): boolean;
        knob(index?: number): anychart.core.gauge.pointers.Knob;
        knob(value?: Object | boolean): anychart.charts.CircularGauge;
        knob(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(index?: number): anychart.core.gauge.pointers.Marker;
        marker(value?: Object | boolean): anychart.charts.CircularGauge;
        marker(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        needle(index?: number): anychart.core.gauge.pointers.Needle;
        needle(value?: Object | boolean): anychart.charts.CircularGauge;
        needle(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        range(index?: number): anychart.core.axisMarkers.CircularRange;
        range(value?: Object | boolean): anychart.charts.CircularGauge;
        range(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        startAngle(): number;
        startAngle(value?: string | number): anychart.charts.CircularGauge;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.CircularGauge;
        sweepAngle(): number;
        sweepAngle(value?: string | number): anychart.charts.CircularGauge;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Mekko extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.mekko.series.Mekko>;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Mekko;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Mekko;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPlotBounds(): anychart.math.Rect;
        getSeries(id: number | string): anychart.core.mekko.series.Mekko;
        getSeriesAt(index: number): anychart.core.mekko.series.Mekko;
        getSeriesCount(): number;
        getType(): string;
        getXAxesCount(): number;
        getYAxesCount(): number;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Mekko;
        mekko(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.mekko.series.Mekko;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Mekko;
        pointsPadding(): number;
        pointsPadding(value?: number): anychart.charts.Mekko;
        removeAllSeries(): anychart.charts.Mekko;
        removeSeries(id: number | string): anychart.charts.Mekko;
        removeSeriesAt(index: number): anychart.charts.Mekko;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Mekko;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Mekko;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Ordinal): anychart.charts.Mekko;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Mekko;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Mekko;
        yScale(): anychart.scales.Base;
        yScale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Mekko;
    }
    interface Pie extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        connectorLength(): number | string;
        connectorLength(value?: number | string): anychart.charts.Pie;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | anychart.data.DataSettings | Array<any>, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Pie;
        draw(async?: boolean): anychart.core.Chart;
        explode(): string | number;
        explode(value?: string | number): anychart.charts.Pie;
        explodeSlice(index: number, explode?: boolean): anychart.charts.Pie;
        explodeSlices(value: boolean): anychart.charts.Pie;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(fillFunction?: (() => void)): anychart.charts.Pie;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Pie;
        fill(color: string, opacity?: number): anychart.charts.Pie;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pie;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pie;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pie;
        forceHoverLabels(): boolean;
        forceHoverLabels(value?: boolean): anychart.charts.Pie;
        getCenterPoint(): anychart.math.Coordinate;
        getPixelBounds(): anychart.math.Rect;
        getPixelExplode(): number;
        getPixelInnerRadius(): number;
        getPixelRadius(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        group(): (() => void);
        group(value?: string | (() => void)): anychart.charts.Pie;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pie;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pie;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index?: number): anychart.charts.Pie;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Pie;
        inMarquee(): boolean;
        innerRadius(): string | number | (() => void);
        innerRadius(value?: string | number | (() => void)): anychart.charts.Pie;
        insideLabelsOffset(): number | string;
        insideLabelsOffset(value?: number | string): anychart.charts.Pie;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Pie;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Pie;
        outsideLabelsCriticalAngle(): number | string;
        outsideLabelsCriticalAngle(value?: number | string): anychart.charts.Pie;
        outsideLabelsSpace(): number | string;
        outsideLabelsSpace(value?: number | string): anychart.charts.Pie;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Pie;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pie;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        radius(): string | number;
        radius(value?: string | number): anychart.charts.Pie;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        sort(): anychart.enums.Sort;
        sort(value?: anychart.enums.Sort | string): anychart.charts.Pie;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.charts.Pie;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.charts.Pie;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Pie;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.Pie;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Funnel extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        baseWidth(): string | number;
        baseWidth(value?: string | number): anychart.charts.Funnel;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        connectorLength(): number | string;
        connectorLength(value?: number | string): anychart.charts.Funnel;
        connectorStroke(): anychart.graphics.vector.Stroke | (() => void);
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Funnel;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(fillFunction?: (() => void)): anychart.charts.Funnel;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        fill(color: string, opacity?: number): anychart.charts.Funnel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Funnel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Funnel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Funnel;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Funnel;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index?: number): anychart.charts.Funnel;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Funnel;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Funnel;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Funnel;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.Funnel;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        neckHeight(): string | number;
        neckHeight(value?: string | number): anychart.charts.Funnel;
        neckWidth(): string | number;
        neckWidth(value?: string | number): anychart.charts.Funnel;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Funnel;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Funnel;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Funnel;
        pointsPadding(): string | number;
        pointsPadding(value?: string | number): anychart.charts.Funnel;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(index?: number): anychart.charts.Funnel;
        select(indexes?: Array<number>): anychart.charts.Funnel;
        select(): anychart.charts.Funnel;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Funnel;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.Funnel;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Funnel;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.Funnel;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Funnel;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Map extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.map.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axes(): anychart.core.axes.MapSettings;
        axes(value?: Object | boolean): anychart.charts.Map;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Bubble;
        callout(index?: number): anychart.core.ui.Callout;
        callout(value?: Object | boolean): anychart.charts.Map;
        callout(index?: number, value?: Object | boolean): anychart.charts.Map;
        cancelMarquee(): anychart.core.Chart;
        choropleth(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Choropleth;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(value?: Object): anychart.charts.Map;
        connector(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Connector;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Map;
        crs(value?: Object | (() => void) | anychart.enums.MapProjections | string): void;
        crsAnimation(): anychart.core.utils.Animation;
        crsAnimation(value?: boolean | Object, duration?: number): anychart.charts.Map;
        defaultSeriesType(): anychart.enums.MapSeriesType | string;
        defaultSeriesType(value?: string | anychart.enums.MapSeriesType): anychart.charts.Map;
        draw(async?: boolean): anychart.core.Chart;
        drillDownMap(value?: {[prop: string]: (Object|anychart.charts.Map)}): Object;
        drillTo(id: string, map?: anychart.charts.Map): anychart.charts.Map;
        drillUp(): anychart.charts.Map;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        featureCrs(id: string): string;
        featureCrs(id: string, crs?: string): anychart.charts.Map;
        featureScaleFactor(id: string): number;
        featureScaleFactor(id: string, ratio?: number): anychart.charts.Map;
        featureTranslation(id: string): Array<number>;
        featureTranslation(id: string, dx?: number, dy?: number): anychart.charts.Map;
        geoData(): Node | string | Object;
        geoData(data?: Node | string | Object): Node | string | Object;
        geoIdField(): string;
        geoIdField(value?: string): anychart.charts.Map;
        getDrilldownPath(): Array<anychart.core.MapPoint>;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.map.series.Base;
        getSeriesAt(index: number): anychart.core.map.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getZoomLevel(): number;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grids(): anychart.core.grids.MapSettings;
        grids(value?: Object | boolean): anychart.charts.Map;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Map;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Cartesian;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        inverseTransform(x: number, y: number): {[prop: string]: number};
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Map;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Map;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Map;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        maxZoomLevel(): number;
        maxZoomLevel(value?: number): anychart.charts.Map;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Map;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        move(dx: number, dy: number): anychart.charts.Map;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Cartesian;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Map;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Map;
        removeSeries(id: number | string): anychart.charts.Map;
        removeSeriesAt(index: number): anychart.charts.Map;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scale(): anychart.scales.Geo;
        scale(value?: anychart.scales.Geo | Object): anychart.scales.Geo;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Map;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toGeoJSON(): Object;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transform(xLong: number, yLat: number): {[prop: string]: number};
        translateFeature(id: string, dx: number, dy: number): anychart.charts.Map;
        unboundRegions(): anychart.core.utils.UnboundRegionsSettings | anychart.enums.MapUnboundRegionsMode;
        unboundRegions(value?: Object | anychart.enums.MapUnboundRegionsMode | string | boolean): anychart.charts.Map;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zoom(value: number, cx?: number, cy?: number, duration?: number): anychart.charts.Map;
        zoomTo(value: number, cx?: number, cy?: number): anychart.charts.Map;
        zoomToFeature(id: string): void;
    }
    interface Pyramid extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        baseWidth(): string | number;
        baseWidth(value?: string | number): anychart.charts.Pyramid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        connectorLength(): number | string;
        connectorLength(value?: number | string): anychart.charts.Pyramid;
        connectorStroke(): anychart.graphics.vector.Stroke | (() => void);
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.Pyramid;
        draw(async?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value?: anychart.graphics.vector.Fill | (() => void)): anychart.charts.Pyramid;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        fill(color: string, opacity?: number): anychart.charts.Pyramid;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pyramid;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pyramid;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pyramid;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pyramid;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index?: number): anychart.charts.Pyramid;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Pyramid;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Pyramid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Pyramid;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.Pyramid;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.charts.Pyramid;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Pyramid;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pyramid;
        pointsPadding(): string | number;
        pointsPadding(value?: string | number): anychart.charts.Pyramid;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        reversed(): boolean;
        reversed(value?: boolean): anychart.charts.Pyramid;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(): anychart.charts.Pyramid;
        select(index?: number): anychart.charts.Pyramid;
        select(indexes?: Array<number>): anychart.charts.Pyramid;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.charts.Pyramid;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.Pyramid;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Pyramid;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.Pyramid;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Pyramid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.color {
    function bipolarHueProgression(color1?: string, color2?: string, count?: number): Array<string>;
    function blend(rgb1: Array<number>, rgb2: Array<number>, factor: number): anychart.graphics.vector.SolidFill;
    function blendedHueProgression(color1?: string, color2?: string, count?: number): Array<string>;
    function darken(fillOrStroke: anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke, factor?: number): string | anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke;
    function lighten(fillOrStroke: anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke, factor?: number): string | anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke;
    function singleHueProgression(color?: string, count?: number, startOrTargetLightness?: number, endLightness?: number): Array<string>;
}

declare namespace anychart.core {
    interface MouseEvent {
        altKey: boolean;
        button: number;
        charCode: number;
        clientX: number;
        clientY: number;
        ctrlKey: boolean;
        currentTarget: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        domTarget: anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        keyCode: number;
        metaKey: boolean;
        offsetX: number;
        offsetY: number;
        platformModifierKey: boolean;
        relatedDomTarget: anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        relatedTarget: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        screenX: number;
        screenY: number;
        shiftKey: boolean;
        target: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        type: anychart.graphics.events.EventType;
    }
    interface VisualBase extends anychart.core.Base {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(value?: boolean): anychart.core.Point;
        set(field: string, value: any): anychart.core.Point;
    }
    interface StateSettings extends anychart.core.Base {
        dummyFill(): anychart.graphics.vector.Fill;
        dummyFill(fillFunction?: (() => void)): anychart.core.StateSettings;
        dummyFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        dummyStroke(): anychart.graphics.vector.Stroke;
        dummyStroke(strokeFunction?: (() => void)): anychart.core.StateSettings;
        dummyStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        emptyFill(): anychart.graphics.vector.Fill | (() => void);
        emptyFill(value: anychart.graphics.vector.Fill | string): anychart.core.StateSettings;
        emptyFill(fillFunction?: (() => void)): anychart.core.StateSettings;
        emptyFill(color: string, opacity?: number): anychart.core.StateSettings;
        emptyHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        emptyHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        fallingFill(fillFunction?: (() => void)): anychart.core.StateSettings;
        fallingFill(color: string, opacity?: number): anychart.core.StateSettings;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(fillFunction?: (() => void)): anychart.core.StateSettings;
        fallingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(fillFunction?: (() => void)): anychart.core.StateSettings;
        fill(value: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        fill(color: string, opacity?: number): anychart.core.StateSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.StateSettings;
        fontSize(): number;
        fontSize(value?: number | string): anychart.core.StateSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.StateSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.StateSettings;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.StateSettings;
        grid(): anychart.graphics.vector.Stroke;
        grid(gridFunction?: (() => void)): anychart.core.StateSettings;
        grid(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        headers(): anychart.core.ui.LabelsFactory;
        headers(value?: Object | boolean): anychart.core.StateSettings;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.StateSettings;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): object;
        labels(): anychart.core.ui.LabelsFactory | anychart.core.ui.CircularLabelsFactory;
        labels(value?: Object | boolean): anychart.core.StateSettings;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.StateSettings;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        lowerLabels(): anychart.core.ui.LabelsFactory;
        lowerLabels(value?: Object | boolean): anychart.core.StateSettings;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.StateSettings;
        medianStroke(): anychart.graphics.vector.Stroke | (() => void);
        medianStroke(value?: (() => void)): anychart.core.StateSettings;
        medianStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        negativeFill(fillFunction?: (() => void)): anychart.core.StateSettings;
        negativeFill(color: string, opacity?: number): anychart.core.StateSettings;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (() => void)): anychart.core.StateSettings;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): object;
        outlierMarkers(): anychart.core.ui.MarkersFactory;
        outlierMarkers(value?: Object | boolean | string): anychart.core.StateSettings;
        removeAllListeners(type?: string): number;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        risingFill(fillFunction?: (() => void)): anychart.core.StateSettings;
        risingFill(color: string, opacity?: number): anychart.core.StateSettings;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (() => void)): anychart.core.StateSettings;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): object;
        size(): number;
        size(value?: number): anychart.core.StateSettings;
        stemStroke(): anychart.graphics.vector.Stroke | (() => void);
        stemStroke(value?: (() => void)): anychart.core.StateSettings;
        stemStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.StateSettings;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.StateSettings;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.StateSettings;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        upperLabels(): anychart.core.ui.LabelsFactory;
        upperLabels(value?: Object | boolean): anychart.core.StateSettings;
        whiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        whiskerStroke(value?: (() => void)): anychart.core.StateSettings;
        whiskerStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        whiskerWidth(): number | string;
        whiskerWidth(value?: number | string): anychart.core.StateSettings;
    }
    interface Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeparateChart extends anychart.core.ChartWithCredits {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Chart extends anychart.core.VisualBaseWithBounds {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(value?: boolean | Object): anychart.core.Chart;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        exports(): anychart.core.utils.Exports;
        exports(value?: Object): anychart.core.Chart;
        getJpgBase64String(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getSvgBase64String(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        inMarquee(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        selectMarqueeFill(): anychart.graphics.vector.Fill;
        selectMarqueeFill(value: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectMarqueeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        shareAsJpg(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: (() => void) | Object, onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChartWithCredits extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface SeriesPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.SeriesPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.Point;
    }
    interface NoDataSettings extends anychart.core.Base {
        label(): anychart.core.ui.Label;
        label(value?: Object | string | boolean): anychart.core.NoDataSettings;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeriesBase extends anychart.core.VisualBaseWithBounds {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.SeriesBase;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.SeriesBase;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.SeriesBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.SeriesBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Text extends anychart.core.VisualBase {
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface TreeMapPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getNode(): anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.TreeMapPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.TreeMapPoint;
        set(field: string, value: any): anychart.core.TreeMapPoint;
    }
    interface VisualBaseWithBounds extends anychart.core.VisualBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChoroplethPoint extends anychart.core.SeriesPoint {
        crs(): string;
        crs(crs?: string): anychart.core.ChoroplethPoint;
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getFeatureBounds(): anychart.math.Rect;
        getFeatureProp(): Object;
        getIndex(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.SeriesPoint;
        middleX(): number;
        middleX(value?: number): anychart.core.ChoroplethPoint;
        middleY(): number;
        middleY(value?: number): anychart.core.ChoroplethPoint;
        scaleFactor(): number;
        scaleFactor(scale?: number): anychart.core.ChoroplethPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.Point;
        translate(dx: number, dy: number): anychart.core.ChoroplethPoint;
        translation(): Array<number>;
        translation(dx?: number, dy?: number): anychart.core.ChoroplethPoint;
    }
    interface PiePoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getEndAngle(): number;
        getIndex(): number;
        getStartAngle(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(value?: boolean): anychart.core.PiePoint;
        set(field: string, value: any): anychart.core.Point;
    }
    interface BubblePoint extends anychart.core.SeriesPoint {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getPixelRadius(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.SeriesPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.Point;
    }
    interface MapPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getCurrentChart(): anychart.core.SeparateChart;
        getId(): string;
        getIndex(): number;
        getParentChart(): anychart.core.SeparateChart;
        getProperties(): Object;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(value?: boolean): anychart.core.Point;
        set(field: string, value: any): anychart.core.Point;
    }
}

declare namespace anychart.core.annotations {
    interface AnnotationJSONFormat {
        allowEdit: boolean;
        anchor: anychart.enums.Anchor;
        color: anychart.graphics.vector.AnyColor;
        fill: anychart.graphics.vector.Fill | (() => void);
        grid: anychart.graphics.vector.Stroke | (() => void);
        hatchFill: anychart.graphics.vector.PatternFill | (() => void);
        hoverFill: anychart.graphics.vector.Fill | (() => void);
        hoverGap: number;
        hoverGrid: anychart.graphics.vector.Stroke | (() => void);
        hoverHatchFill: anychart.graphics.vector.PatternFill | (() => void);
        hoverSize: number;
        hoverStroke: anychart.graphics.vector.Stroke | (() => void);
        hoverTrend: anychart.graphics.vector.Stroke | (() => void);
        markerType: anychart.enums.MarkerType;
        offsetX: number;
        offsetY: number;
        secondValueAnchor: number;
        secondXAnchor: number;
        selectFill: anychart.graphics.vector.Fill | (() => void);
        selectGrid: anychart.graphics.vector.Stroke | (() => void);
        selectHatchFill: anychart.graphics.vector.PatternFill | (() => void);
        selectSize: number;
        selectStroke: anychart.graphics.vector.Stroke | (() => void);
        selectTrend: anychart.graphics.vector.Stroke | (() => void);
        size: number;
        stroke: anychart.graphics.vector.Stroke | (() => void);
        thirdValueAnchor: number;
        thirdXAnchor: number;
        trend: anychart.graphics.vector.Stroke | (() => void);
        valueAnchor: number;
        xAnchor: number;
    }
    interface Ray extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Ray;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Ray;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Ray;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ray;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Ray;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Ray;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface InfiniteLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.InfiniteLine;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.InfiniteLine;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.InfiniteLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.InfiniteLine;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.InfiniteLine;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.InfiniteLine;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface FibonacciFan extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        grid(): anychart.graphics.vector.Stroke;
        grid(gridFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        grid(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciFan;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciFan;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        timeLevels(): Array<number>;
        timeLevels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciFan;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciFan;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface Rectangle extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Rectangle;
        fill(color: string, opacity?: number): anychart.core.annotations.Rectangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Rectangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Rectangle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Rectangle;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.Rectangle;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.Rectangle;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Rectangle;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Rectangle;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Rectangle;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Rectangle;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface AndrewsPitchfork extends anychart.core.annotations.Base {
        color(): string;
        color(value: string): anychart.core.annotations.AndrewsPitchfork;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.AndrewsPitchfork;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.AndrewsPitchfork;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.AndrewsPitchfork;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.AndrewsPitchfork;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.AndrewsPitchfork;
        thirdValueAnchor(): any;
        thirdValueAnchor(Third: any): anychart.core.annotations.AndrewsPitchfork;
        thirdXAnchor(): any;
        thirdXAnchor(Third: any): anychart.core.annotations.AndrewsPitchfork;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.AndrewsPitchfork;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.AndrewsPitchfork;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface PlotController extends anychart.core.VisualBase {
        add(annotationTypeOrConfig: anychart.enums.AnnotationTypes | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        andrewsPitchfork(config?: Object): anychart.core.annotations.AndrewsPitchfork;
        cancelDrawing(): void;
        ellipse(config?: Object): anychart.core.annotations.Ellipse;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.annotations.PlotController;
        fibonacciArc(config?: Object): anychart.core.annotations.FibonacciArc;
        fibonacciFan(config?: Object): anychart.core.annotations.FibonacciFan;
        fibonacciRetracement(config?: Object): anychart.core.annotations.FibonacciRetracement;
        fibonacciTimezones(config?: Object): anychart.core.annotations.FibonacciTimezones;
        fromJson(config: Object | string): anychart.core.annotations.PlotController;
        fromXml(config: string | Node): anychart.core.annotations.PlotController;
        getAnnotationAt(index: number): anychart.core.annotations.Base;
        getAnnotationsCount(): number;
        getSelectedAnnotation(): anychart.core.annotations.Base;
        horizontalLine(config?: Object): anychart.core.annotations.HorizontalLine;
        infiniteLine(config?: Object): anychart.core.annotations.InfiniteLine;
        line(config?: Object): anychart.core.annotations.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        marker(config?: Object): anychart.core.annotations.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        ray(config?: Object): anychart.core.annotations.Ray;
        rectangle(config?: Object): anychart.core.annotations.Rectangle;
        removeAllAnnotations(): anychart.core.annotations.PlotController;
        removeAllListeners(type?: string): number;
        removeAnnotation(annotation: anychart.core.annotations.Base): anychart.core.annotations.PlotController;
        removeAnnotationAt(index: number): anychart.core.annotations.PlotController;
        select(annotation: anychart.core.annotations.Base): anychart.core.annotations.PlotController;
        startDrawing(annotationTypeOrConfig: anychart.enums.AnnotationTypes | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        trendChannel(config?: Object): anychart.core.annotations.TrendChannel;
        triangle(config?: Object): anychart.core.annotations.Triangle;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.annotations.PlotController;
        verticalLine(config?: Object): anychart.core.annotations.VerticalLine;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface FibonacciBase extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface Triangle extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Triangle;
        fill(color: string, opacity?: number): anychart.core.annotations.Triangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Triangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Triangle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Triangle;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Triangle;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Triangle;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Triangle;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Triangle;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Triangle;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Triangle;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface FibonacciRetracement extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface TrendChannel extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        fill(fillFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        fill(color: string, opacity?: number): anychart.core.annotations.TrendChannel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.TrendChannel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.TrendChannel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.TrendChannel;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.TrendChannel;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.TrendChannel;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.TrendChannel;
        thirdValueAnchor(): any;
        thirdValueAnchor(Third: any): anychart.core.annotations.TrendChannel;
        thirdXAnchor(): any;
        thirdXAnchor(Third: any): anychart.core.annotations.TrendChannel;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.TrendChannel;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.TrendChannel;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface VerticalLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.VerticalLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.VerticalLine;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.VerticalLine;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface HorizontalLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.HorizontalLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.HorizontalLine;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.HorizontalLine;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface ChartController extends anychart.core.Base {
        cancelDrawing(): void;
        getSelectedAnnotation(): anychart.core.annotations.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllAnnotations(): anychart.core.annotations.ChartController;
        removeAllListeners(type?: string): number;
        removeAnnotation(annotation: anychart.core.annotations.Base): anychart.core.annotations.ChartController;
        select(annotation: anychart.core.annotations.Base): anychart.core.annotations.ChartController;
        startDrawing(annotationTypeOrConfig: anychart.enums.AnnotationTypes | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.annotations.ChartController;
    }
    interface FibonacciArc extends anychart.core.annotations.FibonacciBase {
        color(): string;
        color(value: string): anychart.core.annotations.FibonacciArc;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FibonacciArc;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciArc;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciArc;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciArc;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciArc;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface Line extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Line;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Line;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Line;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Line;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Line;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface FibonacciTimezones extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciTimezones;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciTimezones;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface Ellipse extends anychart.core.annotations.Base {
        color(): string;
        color(value: string): anychart.core.annotations.Ellipse;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Ellipse;
        fill(color: string, opacity?: number): anychart.core.annotations.Ellipse;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Ellipse;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Ellipse;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Ellipse;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Ellipse;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Ellipse;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Ellipse;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Ellipse;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ellipse;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Ellipse;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Ellipse;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
    interface Marker extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        anchor(): anychart.enums.Anchor | string;
        anchor(value: anychart.enums.Anchor | string): anychart.core.annotations.Marker;
        color(): string;
        color(value: string): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Marker;
        fill(color: string, opacity?: number): anychart.core.annotations.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Marker;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.annotations.Base;
        markerType(): anychart.enums.MarkerType | string;
        markerType(value: anychart.enums.MarkerType | string): anychart.core.annotations.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.annotations.Base;
        offsetX(): number | string;
        offsetX(value: number | string): anychart.core.annotations.Marker;
        offsetY(): number | string;
        offsetY(value: number | string): anychart.core.annotations.Marker;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.annotations.Base;
        size(): number;
        size(value?: number): anychart.core.annotations.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Marker;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Marker;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Marker;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes): anychart.core.annotations.Base;
    }
}

declare namespace anychart.core.axes {
    interface CircularTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill | string): anychart.core.axes.CircularTicks;
        fill(color: string, opacity?: number): anychart.core.axes.CircularTicks;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.CircularTicks;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.CircularTicks;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.CircularTicks;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.axes.CircularTicks;
        length(): string;
        length(value?: number | string): anychart.core.axes.CircularTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.SidePosition | string;
        position(value?: anychart.enums.SidePosition | string): anychart.core.axes.CircularTicks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.axes.CircularTicks;
        stroke(value?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.CircularTicks;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.axes.CircularTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Polar extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Polar;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Polar;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Polar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.ScatterBase;
        scale(value?: anychart.scales.ScatterBase | anychart.enums.ScaleTypes | string | Object): anychart.core.axes.Polar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Polar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface MapSettings extends anychart.core.VisualBase {
        bottom(): anychart.core.axes.Map;
        bottom(value?: boolean | Object): anychart.core.axes.MapSettings;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.MapSettings;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.MapSettings;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.axes.MapSettings;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.MapSettings;
        left(): anychart.core.axes.Map;
        left(value?: boolean | Object): anychart.core.axes.MapSettings;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.MapSettings;
        minorTicks(): anychart.core.axes.MapTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.MapSettings;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.MapSettings;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): anychart.core.axes.Map;
        right(value?: boolean | Object): anychart.core.axes.MapSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.MapSettings;
        ticks(): anychart.core.axes.MapTicks;
        ticks(value?: Object | boolean): anychart.core.axes.MapSettings;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.MapSettings;
        top(): anychart.core.axes.Map;
        top(value?: boolean | Object): anychart.core.axes.MapSettings;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StockTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke): anychart.core.axes.Ticks;
        stroke(color?: string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.StockTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radial extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Radial;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Radial;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radial;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Radial;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Radial;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Radial;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Radial;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radial;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radial;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RadialTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        length(): number;
        length(value?: number): anychart.core.axes.RadialTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke): anychart.core.axes.Ticks;
        stroke(color?: string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.RadialTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Ticks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        length(): number;
        length(value?: number): anychart.core.axes.Ticks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.SidePosition | string;
        position(value?: anychart.enums.SidePosition | string): anychart.core.axes.Ticks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke): anychart.core.axes.Ticks;
        stroke(color?: string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Ticks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Circular extends anychart.core.VisualBase {
        cornersRounding(): string;
        cornersRounding(value?: number | string): anychart.core.axes.Circular;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Circular;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Circular;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill | string): anychart.core.axes.Circular;
        fill(color: string, opacity?: number): anychart.core.axes.Circular;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.Circular;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.Circular;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.Circular;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Circular;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Circular;
        minorTicks(): anychart.core.axes.CircularTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Circular;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.axes.Circular;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.axes.Circular;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Linear | anychart.scales.Logarithmic;
        scale(value?: anychart.enums.GaugeScaleTypes | anychart.scales.Linear | Object): anychart.core.axes.Circular;
        startAngle(): number;
        startAngle(value?: string | number): anychart.core.axes.Circular;
        sweepAngle(): number;
        sweepAngle(value?: string | number): anychart.core.axes.Circular;
        ticks(): anychart.core.axes.CircularTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Circular;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): string;
        width(value?: number | string): anychart.core.axes.Circular;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StockDateTime extends anychart.core.VisualBase {
        background(): anychart.core.ui.Background;
        background(value?: Object | boolean | string): anychart.core.axes.StockDateTime;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        height(): number;
        height(value?: number): anychart.core.axes.StockDateTime;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.StockDateTime;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.StockDateTime;
        minorTicks(): anychart.core.axes.StockTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.StockDateTime;
        overlapMode(): anychart.enums.StockLabelsOverlapMode;
        overlapMode(value?: anychart.enums.StockLabelsOverlapMode): anychart.core.axes.StockDateTime;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        showHelperLabel(): boolean;
        showHelperLabel(value?: boolean): anychart.core.axes.StockDateTime;
        ticks(): anychart.core.axes.StockTicks;
        ticks(value?: Object | boolean): anychart.core.axes.StockDateTime;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | anychart.enums.ScaleTypes | Object): anychart.core.axes.Radar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LinearGauge extends anychart.core.axes.Linear {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        offset(): string;
        offset(value?: string): anychart.core.axes.LinearGauge;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface MapTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        length(): number;
        length(value?: number | string): anychart.core.axes.MapTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.SidePosition | string;
        position(value?: anychart.enums.SidePosition | string): anychart.core.axes.MapTicks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.MapTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Map extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Map;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Map;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Map;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Map;
        minorTicks(): anychart.core.axes.MapTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Map;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Map;
        ticks(): anychart.core.axes.MapTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Map;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Map;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.axisMarkers {
    interface GanttLine extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.GanttLine;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.GanttLine;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): number | anychart.enums.GanttDateTimeMarkers;
        value(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttLine;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface GanttText extends anychart.core.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.axisMarkers.GanttText;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.axisMarkers.GanttText;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.axisMarkers.GanttText;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.GanttText;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.axisMarkers.GanttText;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.axisMarkers.GanttText;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.axisMarkers.GanttText;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttText;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.axisMarkers.GanttText;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        value(): number | anychart.enums.GanttDateTimeMarkers | string;
        value(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttText;
        width(): number | string;
        width(value?: number | string): anychart.core.axisMarkers.GanttText;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface GanttRange extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axisMarkers.GanttRange;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.GanttRange;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.GanttRange;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.GanttRange;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.GanttRange;
        from(): number | anychart.enums.GanttDateTimeMarkers | string;
        from(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttRange;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.GanttRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttRange;
        to(): number | anychart.enums.GanttDateTimeMarkers | string;
        to(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttRange;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface CircularRange extends anychart.core.VisualBase {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.axisMarkers.CircularRange;
        cornersRounding(): string;
        cornersRounding(value?: number | string): anychart.core.axisMarkers.CircularRange;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endSize(): string;
        endSize(value?: number | string): anychart.core.axisMarkers.CircularRange;
        fill(): anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.axisMarkers.CircularRange;
        from(): number;
        from(value?: number): anychart.core.axisMarkers.CircularRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.GaugeSidePosition | string;
        position(value?: anychart.enums.GaugeSidePosition | string): anychart.core.axisMarkers.CircularRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.axisMarkers.CircularRange;
        removeAllListeners(type?: string): number;
        startSize(): string;
        startSize(value?: number | string): anychart.core.axisMarkers.CircularRange;
        to(): number;
        to(value?: number): anychart.core.axisMarkers.CircularRange;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Text extends anychart.core.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.axisMarkers.Text;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.axisMarkers.Text;
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.axisMarkers.Text;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Text;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.axisMarkers.Text;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.axisMarkers.Text;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.axisMarkers.Text;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axisMarkers.Text;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.axisMarkers.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        value(): number;
        value(value?: number): anychart.core.axisMarkers.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.axisMarkers.Text;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface CurrentPriceIndicator extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: number | anychart.core.axes.Linear): anychart.core.axisMarkers.CurrentPriceIndicator;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingLabel(): anychart.core.ui.Label;
        fallingLabel(index?: string | number, value?: boolean | Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.CurrentPriceIndicator;
        label(): anychart.core.ui.Label;
        label(index?: string | number, value?: boolean | Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        risingLabel(): anychart.core.ui.Label;
        risingLabel(index?: string | number, value?: boolean | Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.CurrentPriceIndicator;
        series(): anychart.core.stock.series.Base;
        series(value?: number | anychart.core.stock.series.Base): anychart.core.axisMarkers.CurrentPriceIndicator;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.CurrentPriceIndicator;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): string | anychart.enums.PriceIndicatorDataSource | number | Date;
        value(value?: string | anychart.enums.PriceIndicatorDataSource | number | Date): anychart.core.axisMarkers.CurrentPriceIndicator;
        valueField(): string;
        valueField(value: string): string;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axisMarkers.Line;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.Line;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): number;
        value(newValue?: number): anychart.core.axisMarkers.Line;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Range extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.Range;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        from(): number;
        from(value?: number): anychart.core.axisMarkers.Range;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Range;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axisMarkers.Range;
        to(): number;
        to(value?: number): anychart.core.axisMarkers.Range;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.cartesian {
}

declare namespace anychart.core.cartesian.series {
    interface ContinuousBase extends anychart.core.cartesian.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Box extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Box;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Box;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Box;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Box;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Box;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        medianStroke(): anychart.graphics.vector.Stroke | (() => void);
        medianStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        medianStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        outlierMarkers(): anychart.core.ui.MarkersFactory;
        outlierMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.Box;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stemStroke(): anychart.graphics.vector.Stroke | (() => void);
        stemStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        stemStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Box;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Box;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        whiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        whiskerStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        whiskerStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        whiskerWidth(): number | string;
        whiskerWidth(value?: number | string): anychart.core.cartesian.series.Box;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line3d extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface SplineArea extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.SplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.SplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Spline extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Spline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Spline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface DiscreteBase extends anychart.core.cartesian.series.BaseWithMarkers {
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        unhover(): anychart.core.radar.series.Base;
        unhover(index?: number): anychart.core.radar.series.Base;
        unhover(indexes?: Array<number>): anychart.core.radar.series.Base;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
    }
    interface RangeStepArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeStepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.cartesian.series.RangeStepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepArea extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.StepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.cartesian.series.StepArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeBar extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeBar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeBar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column3d extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ContinuousRangeBase extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Area;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Stick extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Stick;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Stick;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bubble extends anychart.core.cartesian.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        displayNegative(): boolean;
        displayNegative(value?: boolean): anychart.core.cartesian.series.Bubble;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        negativeFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area3d extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface OHLC extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        fallingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Candlestick extends anychart.core.cartesian.series.OHLC {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        fallingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        fallingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        fallingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        risingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        risingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Column;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Column;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Column;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface WidthBased extends anychart.core.cartesian.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface BaseWithMarkers extends anychart.core.cartesian.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface JumpLine extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.JumpLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.JumpLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepLine extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.cartesian.series.StepLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeSplineArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeSplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Hilo extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Hilo;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Hilo;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.cartesian.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        size(): number;
        size(value?: number): anychart.core.cartesian.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.cartesian.series.Marker;
        unhover(): anychart.core.cartesian.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar3d extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.cartesian.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.gantt {
    interface TimelineHeader extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.gantt.TimelineHeader;
        backgroundFill(color: string, opacity?: number): anychart.core.gantt.TimelineHeader;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.TimelineHeader;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.TimelineHeader;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.TimelineHeader;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        levelsSeparationStroke(): string | anychart.graphics.vector.Stroke;
        levelsSeparationStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.gantt.TimelineHeader;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowLevel(): anychart.core.gantt.TimelineHeader.Level;
        lowLevel(value?: Object | boolean): anychart.core.gantt.TimelineHeader;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        midLevel(): anychart.core.gantt.TimelineHeader.Level;
        midLevel(value?: Object | boolean): anychart.core.gantt.TimelineHeader;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        topLevel(): anychart.core.gantt.TimelineHeader.Level;
        topLevel(value?: Object | boolean): anychart.core.gantt.TimelineHeader;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module TimelineHeader {
    interface Level extends anychart.core.VisualBaseWithBounds {
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.gantt.TimelineHeader.Level;
        tileFill(): anychart.graphics.vector.Fill | string;
        tileFill(value: anychart.graphics.vector.Fill): anychart.core.gantt.TimelineHeader.Level;
        tileFill(color: string, opacity?: number): anychart.core.gantt.TimelineHeader.Level;
        tileFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.TimelineHeader.Level;
        tileFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.TimelineHeader.Level;
        tileFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.TimelineHeader.Level;
        tilesSeparationStroke(): anychart.graphics.vector.Stroke | string;
        tilesSeparationStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.TimelineHeader.Level;
    }
    }
}

declare namespace anychart.core.gauge {
    interface Cap extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.Cap;
        fill(color: string, opacity?: number): anychart.core.gauge.Cap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.Cap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.Cap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.Cap;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.Cap;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.gauge.Cap;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.Cap;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.gauge.pointers {
    interface Needle extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endRadius(): string;
        endRadius(value?: number | string): anychart.core.gauge.pointers.Needle;
        endWidth(): string;
        endWidth(value?: number | string): anychart.core.gauge.pointers.Needle;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        middleRadius(): string;
        middleRadius(value?: number | string): anychart.core.gauge.pointers.Needle;
        middleWidth(): string;
        middleWidth(value?: number | string): anychart.core.gauge.pointers.Needle;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        startRadius(): string;
        startRadius(value?: number | string): anychart.core.gauge.pointers.Needle;
        startWidth(): string;
        startWidth(value?: number | string): anychart.core.gauge.pointers.Needle;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBase {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.GaugeSidePosition | string;
        position(value?: anychart.enums.GaugeSidePosition | string): anychart.core.gauge.pointers.Bar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.gauge.pointers.Bar;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): string;
        width(value?: number | string): anychart.core.gauge.pointers.Bar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Knob extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        bottomRadius(): string;
        bottomRadius(value?: number | string): anychart.core.gauge.pointers.Knob;
        bottomRatio(): number;
        bottomRatio(value?: number): anychart.core.gauge.pointers.Knob;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        topRadius(): string;
        topRadius(value?: number | string): anychart.core.gauge.pointers.Knob;
        topRatio(): number;
        topRatio(value?: number): anychart.core.gauge.pointers.Knob;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticesCount(): number;
        verticesCount(value?: number): anychart.core.gauge.pointers.Knob;
        verticesCurvature(): number;
        verticesCurvature(value?: number): anychart.core.gauge.pointers.Knob;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.GaugeSidePosition | string;
        position(value?: anychart.enums.GaugeSidePosition | string): anychart.core.gauge.pointers.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.gauge.pointers.Marker;
        removeAllListeners(type?: string): number;
        size(): string;
        size(value?: number | string): anychart.core.gauge.pointers.Marker;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        type(): anychart.enums.MarkerType | (() => void);
        type(value?: anychart.enums.MarkerType | (() => void) | string): anychart.core.gauge.pointers.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.grids {
    interface Polar extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Polar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Polar | anychart.core.axes.Radial): anychart.core.grids.Polar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Polar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Polar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Polar;
        isRadial(): boolean;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xScale(): anychart.scales.Base;
        xScale(value?: (anychart.scales.Base|anychart.enums.ScaleTypes|string|Object) ): anychart.core.grids.Polar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.grids.Linear;
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Linear;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        fill(fillFunction?: (() => void)): anychart.core.grids.Linear;
        fill(color: string, opacity?: number): anychart.core.grids.Linear;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.core.grids.Linear;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface MapSettings extends anychart.core.Base {
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.MapSettings;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.MapSettings;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.grids.MapSettings;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.MapSettings;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.MapSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.MapSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.MapSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.MapSettings;
        horizontal(): anychart.core.grids.Map;
        horizontal(value?: boolean | Object): anychart.core.grids.MapSettings;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorStroke(): string | anychart.graphics.vector.Stroke;
        minorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.MapSettings;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.MapSettings;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        vertical(): anychart.core.grids.Map;
        vertical(value?: boolean | Object): anychart.core.grids.MapSettings;
        zIndex(): number | anychart.enums.MapGridZIndex;
        zIndex(value?: number | anychart.enums.MapGridZIndex): anychart.core.grids.MapSettings;
    }
    interface Stock extends anychart.core.VisualBase {
        axis(): anychart.core.axes.StockDateTime | anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.StockDateTime | anychart.core.axes.Linear): anychart.core.grids.Stock;
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Stock;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Stock;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Stock;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Stock;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Stock;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Stock;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        scale(value?: Object | anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.grids.Stock;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Stock;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Radar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Radar | anychart.core.axes.Radial): anychart.core.grids.Radar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Radar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Radar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Radar;
        isRadial(): boolean;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Map extends anychart.core.VisualBase {
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Map;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Map;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.grids.Map;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Map;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Map;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Map;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Map;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Map;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorStroke(): string | anychart.graphics.vector.Stroke;
        minorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Map;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Map;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number | anychart.enums.MapGridZIndex;
        zIndex(value?: number | anychart.enums.MapGridZIndex): anychart.core.grids.Map;
    }
}

declare namespace anychart.core.linearGauge {
    interface ScaleBar extends anychart.core.VisualBase {
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | anychart.enums.ScaleTypes | string): anychart.core.linearGauge.ScaleBar;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.ScaleBar;
        fill(color: string, opacity?: number): anychart.core.linearGauge.ScaleBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.ScaleBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.ScaleBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.ScaleBar;
        from(): string | number;
        from(value?: string | number): anychart.core.linearGauge.ScaleBar;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.ScaleBar;
        points(): Array<anychart.core.linearGauge.ScaleBar.ControlPoint>;
        points(value?: Array<anychart.core.linearGauge.ScaleBar.ControlPoint>): anychart.core.linearGauge.ScaleBar;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.scales.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.ScaleBar;
        to(): string | number;
        to(value?: string | number): anychart.core.linearGauge.ScaleBar;
        width(): string;
        width(value?: string): string | anychart.core.linearGauge.ScaleBar;
    }
    namespace ScaleBar {
    interface ControlPoint {
        height: number;
        left: number;
        right: number;
    }
    }
}

declare namespace anychart.core.linearGauge.pointers {
    interface Tank extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        emptyFill(): anychart.graphics.vector.Fill | (() => void);
        emptyFill(value: anychart.graphics.vector.Fill | string): anychart.core.linearGauge.pointers.Tank;
        emptyFill(fillFunction?: (() => void)): anychart.core.linearGauge.pointers.Tank;
        emptyFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Tank;
        emptyHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        emptyHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Tank;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBase {
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
    }
    interface RangeBar extends anychart.core.linearGauge.pointers.Bar {
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Led extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        colorScale(): anychart.core.linearGauge.pointers.Led;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.linearGauge.pointers.Led;
        count(): number;
        count(value?: number): anychart.core.linearGauge.pointers.Led;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        dimmer(): (() => void);
        dimmer(value?: (() => void)): anychart.core.linearGauge.pointers.Led;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        gap(): number | string;
        gap(value?: number | string): anychart.core.linearGauge.pointers.Led;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        size(): number | string;
        size(value?: number | string): anychart.core.linearGauge.pointers.Led;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
    }
    interface Marker extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        type(): string;
        type(value?: string | anychart.enums.MarkerType): anychart.core.linearGauge.pointers.Marker;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
    }
    interface Thermometer extends anychart.core.linearGauge.pointers.Base {
        bulbPadding(): string | number;
        bulbPadding(value?: string | number): anychart.core.linearGauge.pointers.Thermometer;
        bulbRadius(): string;
        bulbRadius(value?: string): anychart.core.linearGauge.pointers.Thermometer;
        color(): string;
        color(value: string): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.map {
}

declare namespace anychart.core.map.series {
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.map.series.Base;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Choropleth extends anychart.core.map.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.map.series.Base;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.map.series.Base;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bubble extends anychart.core.map.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        displayNegative(): boolean;
        displayNegative(value?: boolean): anychart.core.map.series.Bubble;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.map.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        negativeHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Bubble;
        negativeStroke(): anychart.core.map.series.Bubble;
        negativeStroke(strokeFunction?: (() => void)): anychart.core.map.series.Bubble;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Bubble;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.map.series.Base;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface BaseWithMarkers extends anychart.core.map.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Connector extends anychart.core.map.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.map.series.Base;
        curvature(): string | number;
        curvature(value?: number | string): anychart.core.map.series.Connector;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endSize(): string | number;
        endSize(value?: number | string): anychart.core.map.series.Connector;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.map.series.Base;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        startSize(): number | string;
        startSize(value?: number | string): anychart.core.map.series.Connector;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.map.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.map.series.Base;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.map.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        type(): anychart.enums.MarkerType | string | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.map.series.Marker;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.mekko {
}

declare namespace anychart.core.mekko.series {
    interface Mekko extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.mekko.series.Mekko;
        fill(fillFunction?: (() => void)): anychart.core.mekko.series.Mekko;
        fill(color: string, opacity?: number): anychart.core.mekko.series.Mekko;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.mekko.series.Mekko;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.mekko.series.Mekko;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.mekko.series.Mekko;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.mekko.series.Mekko;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.mekko.series.Mekko;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.mekko.series.Mekko;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.mekko.series.Mekko;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.mekko.series.Mekko;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.mekko.series.Mekko;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.pert {
    interface Tasks {
        color(): string;
        color(value: string): anychart.core.pert.Tasks;
        dummyFill(): anychart.graphics.vector.Fill;
        dummyFill(fillFunction?: (() => void)): anychart.core.pert.Tasks;
        dummyFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        dummyStroke(): anychart.graphics.vector.Stroke;
        dummyStroke(strokeFunction?: (() => void)): anychart.core.pert.Tasks;
        dummyStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        fill(): anychart.graphics.vector.Fill;
        fill(fillFunction?: (() => void)): anychart.core.pert.Tasks;
        fill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.pert.Tasks;
        lowerLabels(): anychart.core.ui.LabelsFactory;
        lowerLabels(value?: Object | boolean): anychart.core.pert.Tasks;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.pert.Tasks;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.pert.Tasks;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.pert.Tasks;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.pert.Tasks;
        upperLabels(): anychart.core.ui.LabelsFactory;
        upperLabels(value?: Object | boolean): anychart.core.pert.Tasks;
    }
    interface Milestones {
        color(): string;
        color(value: string): anychart.core.pert.Milestones;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        fill(fillFunction?: (() => void)): anychart.core.pert.Milestones;
        fill(color: string, opacity?: number): anychart.core.pert.Milestones;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Milestones;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Milestones;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.pert.Milestones;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.pert.Milestones;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.pert.Milestones;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.pert.Milestones;
        shape(): anychart.enums.MilestoneShape | string;
        shape(value?: anychart.enums.MilestoneShape | string): anychart.core.pert.Milestones;
        size(): number | string;
        size(value?: number | string): anychart.core.pert.Milestones;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.pert.Milestones;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Milestones;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.pert.Milestones;
    }
    interface CriticalPath extends anychart.core.Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        milestones(): anychart.core.pert.Milestones;
        milestones(value?: Object): anychart.core.pert.CriticalPath;
        removeAllListeners(type?: string): number;
        tasks(): anychart.core.pert.Tasks;
        tasks(value?: Object): anychart.core.pert.CriticalPath;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.polar {
}

declare namespace anychart.core.polar.series {
    interface Polyline extends anychart.core.polar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.polar.series.Polyline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Polyline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ContinuousBase extends anychart.core.polar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.polar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        fill(color: string, opacity?: number): anychart.core.polar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.polar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Column;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.Column;
        fill(color: string, opacity?: number): anychart.core.polar.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Column;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Column;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.polar.series.Column;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Column;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.polar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.polar.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.polar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.polar.series.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.RangeColumn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.polar.series.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.polar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        fill(color: string, opacity?: number): anychart.core.polar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.polar.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        stroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.polar.series.Marker;
        unhover(): anychart.core.polar.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Polygon extends anychart.core.polar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Polygon;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.Polygon;
        fill(color: string, opacity?: number): anychart.core.polar.series.Polygon;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Polygon;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Polygon;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Polygon;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Polygon;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.polar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.polar.series.Polygon;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Polygon;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.radar {
}

declare namespace anychart.core.radar.series {
    interface ContinuousBase extends anychart.core.radar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.radar.series.Base;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.radar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.radar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.radar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.radar.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.radar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.radar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.radar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.Base;
        unhover(index?: number): anychart.core.radar.series.Base;
        unhover(indexes?: Array<number>): anychart.core.radar.series.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.radar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.radar.series.Base;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.radar.series.Area;
        fill(color: string, opacity?: number): anychart.core.radar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.radar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.radar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.radar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.radar.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.radar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.radar.series.Base;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.radar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.radar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.radar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(fillFunction?: (() => void)): anychart.core.radar.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.radar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): string;
        color(value: string): anychart.core.radar.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        fill(fillFunction?: (() => void)): anychart.core.radar.series.Marker;
        fill(color: string, opacity?: number): anychart.core.radar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.radar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.radar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.radar.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.radar.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.radar.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.radar.series.Marker;
        unhover(): anychart.core.radar.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.resource {
    interface Conflicts extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.resource.Conflicts;
        fill(color: string, opacity?: number): anychart.core.resource.Conflicts;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Conflicts;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Conflicts;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Conflicts;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Conflicts;
        height(): number;
        height(value?: number): anychart.core.resource.Conflicts;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.resource.Conflicts;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.core.resource.Conflicts;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Conflicts;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface TimeLine extends anychart.core.VisualBaseWithBounds {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.resource.TimeLine;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.resource.TimeLine;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.resource.TimeLine;
        drawBottomLine(): boolean;
        drawBottomLine(value?: boolean): anychart.core.resource.Grid;
        drawLeftLine(): boolean;
        drawLeftLine(value?: boolean): anychart.core.resource.Grid;
        drawRightLine(): boolean;
        drawRightLine(value?: boolean): anychart.core.resource.Grid;
        drawTopLine(): boolean;
        drawTopLine(value?: boolean): anychart.core.resource.Grid;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.resource.TimeLine;
        fill(color: string, opacity?: number): anychart.core.resource.TimeLine;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.TimeLine;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.TimeLine;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.TimeLine;
        fontColor(): string;
        fontColor(value?: string): anychart.core.resource.TimeLine;
        fontDecoration(): anychart.graphics.vector.Text.Decoration;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.resource.TimeLine;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.resource.TimeLine;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.resource.TimeLine;
        fontSize(): number;
        fontSize(value?: number | string): anychart.core.resource.TimeLine;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(value?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.resource.TimeLine;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.resource.TimeLine;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.resource.TimeLine;
        format(): (() => void) | string;
        format(value?: (() => void) | string): anychart.core.resource.TimeLineLevelHolidaysSettings;
        getPixelBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(value?: string | anychart.graphics.vector.Text.HAlign): anychart.core.resource.TimeLine;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        holidays(): anychart.core.resource.TimeLineLevelHolidaysSettings;
        holidays(value?: Object): anychart.core.resource.TimeLine;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        letterSpacing(): number;
        letterSpacing(value?: number | string): anychart.core.resource.TimeLine;
        levelHeight(): number;
        levelHeight(value: number): anychart.core.resource.TimeLine;
        lineHeight(): number | string;
        lineHeight(value?: number | string): anychart.core.resource.TimeLine;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.resource.TimeLine;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.resource.TimeLine;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        overlay(): anychart.core.ui.Overlay;
        overlay(value?: Object | boolean): anychart.core.resource.TimeLine;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.resource.TimeLine;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.TimeLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.resource.TimeLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.TimeLine;
        textDirection(): anychart.graphics.vector.Text.Direction;
        textDirection(value?: string | anychart.graphics.vector.Text.Direction): anychart.core.resource.TimeLine;
        textIndent(): number;
        textIndent(value?: number): anychart.core.resource.TimeLine;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.resource.TimeLine;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.resource.TimeLine;
        vAlign(): anychart.graphics.vector.Text.VAlign;
        vAlign(value?: string | anychart.graphics.vector.Text.VAlign): anychart.core.resource.TimeLine;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.resource.TimeLine;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.resource.TimeLine;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    namespace TimeLine {
    interface Level {
        adjustFontSize: boolean | Array<boolean> | Object;
        count: number;
        disablePointerEvents: boolean;
        fill: anychart.graphics.vector.Fill;
        fontColor: string;
        fontDecoration: string;
        fontFamily: string;
        fontOpacity: number;
        fontSize: number;
        fontStyle: anychart.enums.FontStyle | string;
        fontVariant: anychart.enums.FontVariant | string;
        fontWeight: string | number;
        format: (() => void);
        formats: string | Array<string>;
        hAlign: anychart.enums.HAlign | string;
        height: number | string;
        holiday: {[prop: string]: {fill: (anychart.graphics.vector.Fill), padding: (Object|Array<number>|number|string), minFontSize: (number), maxFontSize: (number), adjustFontSize: (boolean|Array<boolean>|{width:boolean, height:boolean}), fontSize: (number), fontFamily: (string), fontColor: (string), fontOpacity: (number), fontDecoration: (string), fontStyle: (anychart.enums.FontStyle|string), fontVariant: (anychart.enums.FontVariant|string), fontWeight: (string|number), letterSpacing: (number|string), textDirection: (string), lineHeight: (number|string), textIndent: (number), vAlign: (anychart.enums.VAlign|string), hAlign: (anychart.enums.HAlign|string), wordWrap: (string), wordBreak: (string), textOverflow: (anychart.graphics.vector.Text.TextOverflow|string), selectable: (boolean), disablePointerEvents: (boolean), useHtml: (boolean), format: (Function)}};
        letterSpacing: number | string;
        lineHeight: number | string;
        maxFontSize: number;
        minFontSize: number;
        padding: Object | Array<any> | number | string;
        selectable: boolean;
        textDirection: string;
        textIndent: number;
        textOverflow: anychart.graphics.vector.Text.TextOverflow | string;
        unit: anychart.enums.Interval;
        useHtml: boolean;
        vAlign: anychart.enums.VAlign | string;
        wordBreak: string;
        wordWrap: string;
    }
    }
    interface Activities extends anychart.core.Base {
        color(): string;
        color(value: string): anychart.core.resource.Activities;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.resource.Activities;
        fill(fillFunction?: (() => void)): anychart.core.resource.Activities;
        fill(color: string, opacity?: number): anychart.core.resource.Activities;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Activities;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Activities;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Activities;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Activities;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.resource.Activities;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.resource.Activities;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.resource.Activities;
        removeAllListeners(type?: string): number;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.resource.Activities;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.resource.Activities;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Activities;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TimeLineLevelHolidaysSettings extends anychart.core.Base {
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.resource.TimeLineLevelHolidaysSettings;
        fill(color: string, opacity?: number): anychart.core.resource.TimeLineLevelHolidaysSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.TimeLineLevelHolidaysSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.TimeLineLevelHolidaysSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.TimeLineLevelHolidaysSettings;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.resource.TimeLineLevelHolidaysSettings;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.TimeLineLevelHolidaysSettings;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Grid extends anychart.core.VisualBaseWithBounds {
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.resource.Grid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        drawBottomLine(): boolean;
        drawBottomLine(value?: boolean): anychart.core.resource.Grid;
        drawLeftLine(): boolean;
        drawLeftLine(value?: boolean): anychart.core.resource.Grid;
        drawRightLine(): boolean;
        drawRightLine(value?: boolean): anychart.core.resource.Grid;
        drawTopLine(): boolean;
        drawTopLine(value?: boolean): anychart.core.resource.Grid;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): anychart.graphics.vector.Fill;
        evenFill(value: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        evenFill(color: string, opacity?: number): anychart.core.resource.Grid;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        evenHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        evenHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        evenHolidayFill(): anychart.graphics.vector.Fill;
        evenHolidayFill(value: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        evenHolidayFill(color: string, opacity?: number): anychart.core.resource.Grid;
        evenHolidayFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        evenHolidayFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        evenHolidayFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        evenHolidayHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        evenHolidayHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalStroke(): anychart.graphics.vector.Stroke | (() => void);
        horizontalStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Grid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(value: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        oddFill(color: string, opacity?: number): anychart.core.resource.Grid;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        oddHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        oddHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        oddHolidayFill(): anychart.graphics.vector.Fill;
        oddHolidayFill(value: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        oddHolidayFill(color: string, opacity?: number): anychart.core.resource.Grid;
        oddHolidayFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        oddHolidayFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        oddHolidayFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        oddHolidayHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        oddHolidayHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        overlay(): anychart.core.ui.Overlay;
        overlay(value?: Object | boolean): anychart.core.resource.Grid;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalStroke(): anychart.graphics.vector.Stroke | (() => void);
        verticalStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Grid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Logo extends anychart.core.ui.Background {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cornerType(): anychart.enums.BackgroundCornersType;
        cornerType(value?: anychart.enums.BackgroundCornersType): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(value?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        overlay(): anychart.core.ui.Overlay;
        overlay(value?: Object | boolean): anychart.core.resource.Logo;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        stroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ResourceList extends anychart.core.VisualBaseWithBounds {
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.resource.ResourceList;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        descriptions(): anychart.core.resource.resourceList.TextSettings;
        descriptions(value?: Object): anychart.core.resource.ResourceList;
        drawBottomLine(): boolean;
        drawBottomLine(value?: boolean): anychart.core.resource.ResourceList;
        drawLeftLine(): boolean;
        drawLeftLine(value?: boolean): anychart.core.resource.ResourceList;
        drawRightLine(): boolean;
        drawRightLine(value?: boolean): anychart.core.resource.ResourceList;
        drawTopLine(): boolean;
        drawTopLine(value?: boolean): anychart.core.resource.ResourceList;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): anychart.graphics.vector.Fill;
        evenFill(value: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        evenFill(color: string, opacity?: number): anychart.core.resource.ResourceList;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.ResourceList;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.ResourceList;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        images(): anychart.core.resource.resourceList.ImageSettings;
        images(value?: Object): anychart.core.resource.ResourceList;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        names(): anychart.core.resource.resourceList.TextSettings;
        names(value?: Object): anychart.core.resource.ResourceList;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(value: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        oddFill(color: string, opacity?: number): anychart.core.resource.ResourceList;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.ResourceList;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.ResourceList;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        overlay(): anychart.core.ui.Overlay;
        overlay(value?: string | Object | boolean): anychart.core.resource.ResourceList;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.ResourceList;
        tags(): anychart.core.resource.resourceList.TagsSettings;
        tags(value?: Object): anychart.core.resource.ResourceList;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        types(): anychart.core.resource.resourceList.TextSettings;
        types(value?: Object): anychart.core.resource.ResourceList;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.resource.resourceList {
    interface TagsSettings extends anychart.core.resource.resourceList.TextSettings {
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.resource.resourceList.TagsSettings;
        fontColor(): string;
        fontColor(value?: string): anychart.core.resource.resourceList.TextSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.resource.resourceList.TextSettings;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.resource.resourceList.TextSettings;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.resource.resourceList.TextSettings;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.resource.resourceList.TextSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.resource.resourceList.TextSettings;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.resource.resourceList.TextSettings;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.resource.resourceList.SettingsWithMargin;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.SettingsWithMargin;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.resource.resourceList.TagsSettings;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.TagsSettings;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.resource.resourceList.TextSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.resource.resourceList.TextSettings;
        textIndent(): number;
        textIndent(value?: number): anychart.core.resource.resourceList.TextSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.resource.resourceList.TextSettings;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.resource.resourceList.TextSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.resource.resourceList.TextSettings;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.resource.resourceList.TextSettings;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.resource.resourceList.TextSettings;
    }
    interface ImageSettings extends anychart.core.resource.resourceList.SettingsWithMargin {
        align(): string;
        align(value: string | anychart.graphics.vector.Image.Align): anychart.core.resource.resourceList.ImageSettings;
        borderRadius(): Array<number>;
        borderRadius(value?: number | Array<number>): anychart.core.resource.resourceList.ImageSettings;
        fittingMode(): string;
        fittingMode(value: string | anychart.graphics.vector.Image.Fitting): anychart.core.resource.resourceList.ImageSettings;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.resource.resourceList.SettingsWithMargin;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.SettingsWithMargin;
        opacity(): string;
        opacity(value?: number): anychart.core.resource.resourceList.ImageSettings;
        size(): string | number;
        size(value?: string | number): anychart.core.resource.resourceList.ImageSettings;
    }
    interface TextSettings extends anychart.core.resource.resourceList.SettingsWithMargin {
        fontColor(): string;
        fontColor(value?: string): anychart.core.resource.resourceList.TextSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.resource.resourceList.TextSettings;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.resource.resourceList.TextSettings;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.resource.resourceList.TextSettings;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.resource.resourceList.TextSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.resource.resourceList.TextSettings;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.resource.resourceList.TextSettings;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.resource.resourceList.TextSettings;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.resource.resourceList.SettingsWithMargin;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.SettingsWithMargin;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.resource.resourceList.TextSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.resource.resourceList.TextSettings;
        textIndent(): number;
        textIndent(value?: number): anychart.core.resource.resourceList.TextSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.resource.resourceList.TextSettings;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.resource.resourceList.TextSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.resource.resourceList.TextSettings;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.resource.resourceList.TextSettings;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.resource.resourceList.TextSettings;
    }
    interface SettingsWithMargin {
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.resource.resourceList.SettingsWithMargin;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.SettingsWithMargin;
    }
}

declare namespace anychart.core.scatter {
}

declare namespace anychart.core.scatter.series {
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.scatter.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.scatter.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.scatter.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bubble extends anychart.core.scatter.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        displayNegative(): boolean;
        displayNegative(value?: boolean): anychart.core.scatter.series.Bubble;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.scatter.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.scatter.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.scatter.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(): anychart.core.scatter.series.Bubble;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface BaseWithMarkers extends anychart.core.scatter.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.scatter.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.scatter.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.scatter.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.scatter.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.scatter.series.Line;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.scatter.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.scatter.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.scatter.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(): anychart.core.scatter.series.Line;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.scatter.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        fill(color: string, opacity?: number): anychart.core.scatter.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.scatter.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.scatter.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.scatter.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.scatter.series.Marker;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.scatter.series.Marker;
        unhover(): anychart.core.scatter.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.series {
    interface RenderingSettings extends anychart.core.Base {
        finish(): (() => void);
        finish(finishFunction?: (() => void)): anychart.core.series.RenderingSettings;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        needsWidth(): boolean;
        needsWidth(value?: boolean): anychart.core.series.RenderingSettings;
        needsZero(): boolean;
        needsZero(value?: boolean): anychart.core.series.RenderingSettings;
        point(): (() => void);
        point(pointFunction?: (() => void)): anychart.core.series.RenderingSettings;
        removeAllListeners(type?: string): number;
        shapes(): Array<anychart.core.series.RenderingSettings.ShapeConfig>;
        shapes(value?: Array<anychart.core.series.RenderingSettings.ShapeConfig>): anychart.core.series.RenderingSettings;
        start(): (() => void);
        start(startFunction?: (() => void)): anychart.core.series.RenderingSettings;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        updatePoint(): (() => void);
        updatePoint(pointFunction?: (() => void)): anychart.core.series.RenderingSettings;
        yValues(): Array<string>;
        yValues(value?: Array<string>): anychart.core.series.RenderingSettings;
    }
    namespace RenderingSettings {
    interface ShapeConfig {
        fillNames: Array<string>;
        isHatchFill: boolean;
        name: string;
        shapeType: anychart.enums.ShapeType;
        strokeNames: Array<string>;
        zIndex: number;
    }
    }
    module RenderingSettings {
    interface Context {
        getShapesGroup(state?: anychart.enums.PointState, baseZIndex?: number, restrictShapes?: {[prop: string]: string}): {[prop: string]: anychart.graphics.vector.Shape};
        getStat(key?: string): any;
    }
    }
    module RenderingSettings {
    interface PointContext extends anychart.core.series.RenderingSettings.Context {
        getDataValue(name: string): any;
        getShapesGroup(state?: anychart.enums.PointState, baseZIndex?: number, restrictShapes?: {[prop: string]: string}): {[prop: string]: anychart.graphics.vector.Shape};
        getStackedValue(): any;
        getStackedZero(): any;
        getStat(key?: string): any;
    }
    }
}

declare namespace anychart.core.stock {
    interface Scroller extends anychart.core.ui.Scroller {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.stock.scrollerSeries.Base>;
        adl(mapping: anychart.data.TableMapping, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.ADL;
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        ama(mapping: anychart.data.TableMapping, period?: number, fastPeriod?: number, slowPeriod?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.AMA;
        area(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Area;
        aroon(mapping: anychart.data.TableMapping, period?: number, upSeriesType?: anychart.enums.StockSeriesType, downSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.Aroon;
        atr(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.ATR;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        bbands(mapping: anychart.data.TableMapping, period?: number, deviation?: number, upperSeriesType?: anychart.enums.StockSeriesType | string, lowerSeriesType?: anychart.enums.StockSeriesType | string, middleSeriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBands;
        bbandsB(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBandsB;
        bbandsWidth(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBandsWidth;
        candlestick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        cci(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CCI;
        cho(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CHO;
        cmf(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CMF;
        column(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Column;
        defaultSeriesType(): string | anychart.enums.StockSeriesType;
        defaultSeriesType(value?: string | anychart.enums.StockSeriesType): anychart.core.stock.Scroller;
        dmi(mapping: anychart.data.TableMapping, period?: number, adxPeriod?: number, useWildersSmoothing?: boolean, pdiSeriesType?: anychart.enums.StockSeriesType, ndiSeriesType?: anychart.enums.StockSeriesType, adxSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.DMI;
        ema(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.EMA;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        getSeries(id: number | string): anychart.core.stock.scrollerSeries.Base;
        getSeriesAt(index: number): anychart.core.stock.scrollerSeries.Base;
        getSeriesCount(): number;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.core.stock.Scroller;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        hilo(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Hilo;
        jumpLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.JumpLine;
        kdj(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType, kMultiplier?: number, dMultiplier?: number, kSeriesType?: anychart.enums.StockSeriesType, dSeriesType?: anychart.enums.StockSeriesType, jSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.KDJ;
        line(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        macd(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number, macdSeriesType?: string | anychart.enums.StockSeriesType, signalSeriesType?: string | anychart.enums.StockSeriesType, histogramSeriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        marker(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Marker;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        mma(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.MMA;
        ohlc(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.stock.Scroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        rangeArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        rangeColumn(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        rangeSplineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        rangeStepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.core.stock.Scroller;
        removeSeries(id: number | string): anychart.core.stock.Scroller;
        removeSeriesAt(index: number): anychart.core.stock.Scroller;
        roc(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RoC;
        rsi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RSI;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        sma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.SMA;
        spline(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Spline;
        splineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        stepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        stepLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        stick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Stick;
        stochastic(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType, kSeriesType?: anychart.enums.StockSeriesType, dSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.Stochastic;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xAxis(): anychart.core.axes.StockDateTime;
        xAxis(value?: Object | boolean): anychart.core.stock.Scroller;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase | Object): anychart.core.stock.Scroller;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Plot extends anychart.core.VisualBaseWithBounds {
        addSeries(...var_args: (anychart.data.TableMapping)[]): Array<anychart.core.stock.series.Base>;
        adl(mapping: anychart.data.TableMapping, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.ADL;
        ama(mapping: anychart.data.TableMapping, period?: number, fastPeriod?: number, slowPeriod?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.AMA;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.core.stock.Plot;
        area(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Area;
        aroon(mapping: anychart.data.TableMapping, period?: number, upSeriesType?: anychart.enums.StockSeriesType, downSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.Aroon;
        atr(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.ATR;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.stock.Plot;
        bbands(mapping: anychart.data.TableMapping, period?: number, deviation?: number, upperSeriesType?: anychart.enums.StockSeriesType | string, lowerSeriesType?: anychart.enums.StockSeriesType | string, middleSeriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBands;
        bbandsB(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBandsB;
        bbandsWidth(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBandsWidth;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        candlestick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Candlestick;
        cci(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CCI;
        cho(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string | anychart.enums.MovingAverageType, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CHO;
        cmf(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CMF;
        column(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Column;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.core.stock.Plot;
        defaultSeriesType(): string | anychart.enums.StockSeriesType;
        defaultSeriesType(value?: string | anychart.enums.StockSeriesType): anychart.core.stock.Plot;
        dmi(mapping: anychart.data.TableMapping, period?: number, adxPeriod?: number, useWildersSmoothing?: boolean, pdiSeriesType?: anychart.enums.StockSeriesType, ndiSeriesType?: anychart.enums.StockSeriesType, adxSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.DMI;
        ema(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.EMA;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getSeries(id: number | string): anychart.core.stock.series.Base;
        getSeriesAt(index: number): anychart.core.stock.series.Base;
        getSeriesCount(): number;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.palettes.HatchFills | anychart.core.stock.Plot;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hilo(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Hilo;
        jumpLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.JumpLine;
        kdj(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType, kMultiplier?: number, dMultiplier?: number, kSeriesType?: anychart.enums.StockSeriesType, dSeriesType?: anychart.enums.StockSeriesType, jSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.KDJ;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.stock.Plot;
        line(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        macd(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number, macdSeriesType?: string | anychart.enums.StockSeriesType, signalSeriesType?: string | anychart.enums.StockSeriesType, histogramSeriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        marker(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.core.stock.Plot;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.Plot;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.Plot;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        mma(mapping: anychart.data.TableMapping, period?: number, seriesType?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.MMA;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.stock.Plot;
        ohlc(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.OHLC;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.stock.Plot;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.Plot;
        priceIndicator(index?: number): anychart.core.axisMarkers.CurrentPriceIndicator;
        priceIndicator(value?: Object | boolean): anychart.core.stock.Plot;
        priceIndicator(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        rangeArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeArea;
        rangeColumn(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeColumn;
        rangeSplineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeSplineArea;
        rangeStepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.core.stock.Plot;
        removeSeries(id: number | string): anychart.core.stock.Plot;
        removeSeriesAt(index: number): anychart.core.stock.Plot;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        roc(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RoC;
        rsi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RSI;
        sma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.SMA;
        spline(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Spline;
        splineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.SplineArea;
        stepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.StepArea;
        stepLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.StepLine;
        stick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Stick;
        stochastic(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType, kSeriesType?: anychart.enums.StockSeriesType, dSeriesType?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.Stochastic;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(): anychart.core.axes.StockDateTime;
        xAxis(value?: Object | boolean): anychart.core.stock.Plot;
        xGrid(index?: number): anychart.core.grids.Stock;
        xGrid(value?: Object | boolean): anychart.core.stock.Plot;
        xGrid(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        xMinorGrid(index?: number): anychart.core.grids.Stock;
        xMinorGrid(value?: Object | boolean): anychart.core.stock.Plot;
        xMinorGrid(indexOrValue?: number, value?: Object | boolean): anychart.core.stock.Plot;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.core.stock.Plot;
        yAxis(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        yGrid(index?: number): anychart.core.grids.Stock;
        yGrid(value?: Object | boolean): anychart.core.stock.Plot;
        yGrid(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        yMinorGrid(index?: number): anychart.core.grids.Stock;
        yMinorGrid(value?: Object | boolean): anychart.core.stock.Plot;
        yMinorGrid(indexOrValue?: number, value?: Object | boolean): anychart.core.stock.Plot;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase | Object): anychart.core.stock.Plot;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Grouping extends anychart.core.Base {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.stock.Grouping;
        forced(): boolean;
        forced(value?: boolean): anychart.core.stock.Grouping;
        getCurrentDataInterval(): anychart.core.stock.Grouping.Level;
        isGrouped(): boolean;
        levels(): Array<anychart.core.stock.Grouping.Level>;
        levels(value?: Array<(anychart.core.stock.Grouping.Level|string)>): anychart.core.stock.Grouping;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxVisiblePoints(): number;
        maxVisiblePoints(value?: number): anychart.core.stock.Grouping;
        minPixPerPoint(): number;
        minPixPerPoint(value?: number): anychart.core.stock.Grouping;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Grouping {
    interface Level {
        count: number;
        unit: anychart.enums.Interval;
    }
    }
}

declare namespace anychart.core.stock.indicators {
    interface Stochastic {
        dMAType(): anychart.enums.MovingAverageType;
        dMAType(value?: anychart.enums.MovingAverageType): anychart.core.stock.indicators.Stochastic;
        dPeriod(): number;
        dPeriod(value?: number): anychart.core.stock.indicators.Stochastic;
        dSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        dSeries(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.Stochastic;
        kMAPeriod(): number;
        kMAPeriod(value?: number): anychart.core.stock.indicators.Stochastic;
        kMAType(): anychart.enums.MovingAverageType;
        kMAType(value?: anychart.enums.MovingAverageType): anychart.core.stock.indicators.Stochastic;
        kPeriod(): number;
        kPeriod(value?: number): anychart.core.stock.indicators.Stochastic;
        kSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        kSeries(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.Stochastic;
    }
    interface AMA {
        fastPeriod(): number;
        fastPeriod(value?: number): anychart.core.stock.indicators.AMA;
        period(): number;
        period(value?: number): anychart.core.stock.indicators.AMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.AMA;
        slowPeriod(): number;
        slowPeriod(value?: number): anychart.core.stock.indicators.AMA;
    }
    interface RoC {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.RoC;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RoC;
    }
    interface BBandsWidth {
        deviation(): number;
        deviation(value?: number): anychart.core.stock.indicators.BBandsWidth;
        period(): number;
        period(value?: number): anychart.core.stock.indicators.BBandsWidth;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBandsWidth;
    }
    interface MACD {
        fastPeriod(): number;
        fastPeriod(value?: number): anychart.core.stock.indicators.MACD;
        histogramSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        histogramSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        macdSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        macdSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        signalPeriod(): number;
        signalPeriod(value?: number): anychart.core.stock.indicators.MACD;
        signalSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        signalSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        slowPeriod(): number;
        slowPeriod(value?: number): anychart.core.stock.indicators.MACD;
    }
    interface KDJ {
        dMAType(): anychart.enums.MovingAverageType;
        dMAType(value?: anychart.enums.MovingAverageType): anychart.core.stock.indicators.KDJ;
        dMultiplier(): number;
        dMultiplier(value?: number): anychart.core.stock.indicators.KDJ;
        dPeriod(): number;
        dPeriod(value?: number): anychart.core.stock.indicators.KDJ;
        dSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        dSeries(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.KDJ;
        jSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        jSeries(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.KDJ;
        kMAPeriod(): number;
        kMAPeriod(value?: number): anychart.core.stock.indicators.KDJ;
        kMAType(): anychart.enums.MovingAverageType;
        kMAType(value?: anychart.enums.MovingAverageType): anychart.core.stock.indicators.KDJ;
        kMultiplier(): number;
        kMultiplier(value?: number): anychart.core.stock.indicators.KDJ;
        kPeriod(): number;
        kPeriod(value?: number): anychart.core.stock.indicators.KDJ;
        kSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        kSeries(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.KDJ;
    }
    interface BBandsB {
        deviation(): number;
        deviation(value?: number): number | anychart.core.stock.indicators.BBandsB;
        period(): number;
        period(value?: number): anychart.core.stock.indicators.BBandsB;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBandsB;
    }
    interface ATR {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.ATR;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.ATR;
    }
    interface SMA {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.SMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.SMA;
    }
    interface CHO {
        fastPeriod(): number;
        fastPeriod(value?: number): anychart.core.stock.indicators.CHO;
        maType(): string | anychart.enums.MovingAverageType;
        maType(value?: anychart.enums.MovingAverageType | string): anychart.core.stock.indicators.CHO;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CHO;
        slowPeriod(): number;
        slowPeriod(value?: number): anychart.core.stock.indicators.CHO;
    }
    interface Aroon {
        downSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        downSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.Aroon;
        period(): number;
        period(value?: number): anychart.core.stock.indicators.Aroon;
        upSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        upSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.Aroon;
    }
    interface RSI {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.RSI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RSI;
    }
    interface CCI {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.CCI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CCI;
    }
    interface MMA {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.MMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.MMA;
    }
    interface EMA {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.EMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.EMA;
    }
    interface ADL {
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.ADL;
    }
    interface CMF {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.CMF;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.CMF;
    }
    interface DMI {
        adxPeriod(): number;
        adxPeriod(value?: number): anychart.core.stock.indicators.DMI;
        adxSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        adxSeries(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.DMI;
        ndiSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        ndiSeries(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.DMI;
        pdiSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        pdiSeries(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.DMI;
        period(): number;
        period(value?: number): anychart.core.stock.indicators.DMI;
        useWildersSmoothing(): boolean;
        useWildersSmoothing(value?: boolean): anychart.core.stock.indicators.DMI;
    }
    interface BBands {
        deviation(): number;
        deviation(value?: number): anychart.core.stock.indicators.BBands;
        lowerSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        lowerSeries(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBands;
        middleSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        middleSeries(type?: anychart.enums.StockSeriesType): anychart.core.stock.indicators.BBands;
        period(): number;
        period(value?: number): anychart.core.stock.indicators.BBands;
        upperSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        upperSeries(type?: anychart.enums.StockSeriesType | string): anychart.core.stock.indicators.BBands;
    }
}

declare namespace anychart.core.stock.scrollerSeries {
    interface SplineArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.SplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.SplineArea;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Spline extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Spline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Spline;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface DiscreteBase extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeStepArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.StepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.stock.scrollerSeries.StepArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepArea;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.scrollerSeries.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.scrollerSeries.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Area;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Stick extends anychart.core.stock.scrollerSeries.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.scrollerSeries.Stick;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.scrollerSeries.Stick;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Stick;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface OHLC extends anychart.core.stock.scrollerSeries.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Candlestick extends anychart.core.stock.scrollerSeries.OHLC {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingFill(): anychart.graphics.vector.Fill | (() => void);
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Base;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Base;
        risingFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Base;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.stock.scrollerSeries.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.scrollerSeries.Column;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.scrollerSeries.Column;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Column;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface JumpLine extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.JumpLine;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepLine extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.stock.scrollerSeries.StepLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepLine;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Line;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeColumn;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeSplineArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Hilo extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Hilo;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        size(): number;
        size(value?: number): anychart.core.stock.scrollerSeries.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Marker;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.scrollerSeries.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.stock.series {
    interface SplineArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.SplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.SplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Spline extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Spline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Spline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface DiscreteBase extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeStepArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeStepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeStepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeStepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.stock.series.RangeStepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.StepArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.StepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.stock.series.StepArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.Area;
        fill(color: string, opacity?: number): anychart.core.stock.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Stick extends anychart.core.stock.series.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Stick;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface OHLC extends anychart.core.stock.series.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(fillFunction?: (() => void)): anychart.core.stock.series.OHLC;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Candlestick extends anychart.core.stock.series.OHLC {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.stock.series.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.Column;
        fill(color: string, opacity?: number): anychart.core.stock.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Column;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface JumpLine extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.JumpLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.JumpLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepLine extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stepDirection(): anychart.enums.StepDirection | string;
        stepDirection(value?: anychart.enums.StepDirection | string): anychart.core.stock.series.StepLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Line;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeSplineArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeSplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeSplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeSplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Hilo extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Hilo;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Hilo;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Marker;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.stock.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        size(): number;
        size(value?: number): anychart.core.stock.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase | Object | anychart.enums.ScaleTypes | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.ui {
    interface Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(): anychart.graphics.vector.Fill | string;
        baseFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baseFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseLabels(): anychart.core.ui.LabelsFactory;
        baseLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        baseStroke(): anychart.graphics.vector.Stroke | string;
        baseStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        baselineAbove(): boolean;
        baselineAbove(value?: boolean): anychart.core.ui.Timeline;
        baselineFill(): anychart.graphics.vector.Fill | string;
        baselineFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baselineFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineLabels(): anychart.core.ui.LabelsFactory;
        baselineLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        baselineStroke(): anychart.graphics.vector.Stroke | string;
        baselineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.Timeline;
        connectorFill(): anychart.graphics.vector.Fill | string;
        connectorFill(value?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        connectorPreviewStroke(): anychart.graphics.vector.Stroke | string;
        connectorPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        connectorStroke(): anychart.graphics.vector.Stroke | string;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editConnectorThumbFill(): anychart.graphics.vector.Fill | string;
        editConnectorThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbStroke(): anychart.graphics.vector.Stroke | string;
        editConnectorThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editFinishConnectorMarkerHorizontalOffset(): number;
        editFinishConnectorMarkerHorizontalOffset(value?: number): anychart.core.ui.Timeline;
        editFinishConnectorMarkerSize(): number;
        editFinishConnectorMarkerSize(value?: number): anychart.core.ui.Timeline;
        editFinishConnectorMarkerType(): anychart.enums.MarkerType | string;
        editFinishConnectorMarkerType(value?: anychart.enums.MarkerType): anychart.enums.MarkerType;
        editFinishConnectorMarkerVerticalOffset(): number;
        editFinishConnectorMarkerVerticalOffset(value?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(): anychart.graphics.vector.Fill | string;
        editIntervalThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbStroke(): anychart.graphics.vector.Stroke | string;
        editIntervalThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editIntervalWidth(): number;
        editIntervalWidth(value?: number): anychart.core.ui.Timeline;
        editPreviewFill(): anychart.graphics.vector.Fill | string;
        editPreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editPreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewStroke(): anychart.graphics.vector.Stroke | string;
        editPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editProgressFill(): anychart.graphics.vector.Fill | string;
        editProgressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editProgressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressStroke(): anychart.graphics.vector.Stroke | string;
        editProgressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStartConnectorMarkerHorizontalOffset(): number;
        editStartConnectorMarkerHorizontalOffset(value?: number): anychart.core.ui.Timeline;
        editStartConnectorMarkerSize(): number;
        editStartConnectorMarkerSize(value?: number): anychart.core.ui.Timeline;
        editStartConnectorMarkerType(): anychart.enums.MarkerType | string;
        editStartConnectorMarkerType(value?: anychart.enums.MarkerType): anychart.enums.MarkerType;
        editStartConnectorMarkerVerticalOffset(): number;
        editStartConnectorMarkerVerticalOffset(value?: number): anychart.core.ui.Timeline;
        editStructurePreviewDashStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editing(): boolean;
        editing(value?: boolean): anychart.core.ui.Timeline;
        header(): anychart.core.gantt.TimelineHeader;
        header(value?: Object): anychart.core.ui.Timeline;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(value?: Object): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        milestoneFill(): anychart.graphics.vector.Fill | string;
        milestoneFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        milestoneFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneLabels(): anychart.core.ui.LabelsFactory;
        milestoneLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        milestoneStroke(): anychart.graphics.vector.Stroke | string;
        milestoneStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        parentFill(): anychart.graphics.vector.Fill | string;
        parentFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        parentFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentLabels(): anychart.core.ui.LabelsFactory;
        parentLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        parentStroke(): anychart.graphics.vector.Stroke | string;
        parentStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        progressFill(): anychart.graphics.vector.Fill | string;
        progressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        progressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressLabels(): anychart.core.ui.LabelsFactory;
        progressLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        progressStroke(): anychart.graphics.vector.Stroke | string;
        progressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: Object): anychart.core.ui.Timeline;
        selectedElementFill(): anychart.graphics.vector.Fill | string;
        selectedElementFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        selectedElementFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementStroke(): anychart.graphics.vector.Stroke | string;
        selectedElementStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
        verticalScrollBar(): anychart.core.ui.ScrollBar;
        verticalScrollBar(value?: Object): anychart.core.ui.Timeline;
    }
    interface DataGrid extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        column(index?: number): anychart.core.ui.DataGrid.Column;
        column(value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        column(index?: number, value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        data(): anychart.data.Tree;
        data(value?: anychart.data.Tree): anychart.core.ui.DataGrid;
        draw(): anychart.core.ui.DataGrid;
        editStructurePreviewDashStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editing(): boolean;
        editing(value?: boolean): anychart.standalones.DataGrid;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endIndex(): number;
        endIndex(value?: number): anychart.core.ui.DataGrid;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalOffset(): number;
        horizontalOffset(value?: number): anychart.core.ui.DataGrid;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(value?: Object): anychart.core.ui.DataGrid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowHoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        startIndex(): number;
        startIndex(value?: number): anychart.core.ui.DataGrid;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.DataGrid;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalOffset(): number;
        verticalOffset(value?: number): anychart.core.ui.DataGrid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module DataGrid {
    interface Column extends anychart.core.VisualBase {
        buttonCursor(): anychart.enums.Cursor | string;
        buttonCursor(valueCursor?: anychart.enums.Cursor | string): anychart.core.ui.DataGrid.Column;
        cellTextSettings(): anychart.core.ui.LabelsFactory;
        cellTextSettings(value?: Object): anychart.core.ui.DataGrid.Column;
        cellTextSettingsOverrider(): (() => void);
        cellTextSettingsOverrider(value?: (() => void)): anychart.core.ui.DataGrid.Column;
        collapseExpandButtons(): boolean;
        collapseExpandButtons(value?: boolean): anychart.core.ui.DataGrid.Column;
        defaultWidth(): number;
        defaultWidth(value?: number): anychart.core.ui.DataGrid.Column;
        depthPaddingMultiplier(): number;
        depthPaddingMultiplier(value?: number): anychart.core.ui.DataGrid.Column;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.DataGrid.Column;
        format(func?: (() => void)): anychart.core.ui.DataGrid.Column;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        setColumnFormat(fieldName: string, presetValue: anychart.enums.ColumnFormats): anychart.core.ui.DataGrid.Column;
        setColumnFormat(fieldName: string, settings: Object): anychart.core.ui.DataGrid.Column;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.DataGrid.Column;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.DataGrid.Column;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface MarkersFactory extends anychart.core.VisualBase {
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.MarkersFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory;
        position(): string;
        position(value?: string): anychart.core.ui.MarkersFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.MarkersFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module MarkersFactory {
    interface Marker extends anychart.core.VisualBase {
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory.Marker;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory.Marker;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory.Marker;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        position(): anychart.enums.Position | string;
        position(value?: anychart.enums.Position | string): anychart.core.ui.MarkersFactory.Marker;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory.Marker;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory.Marker;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory.Marker;
        type(): anychart.enums.MarkerType | (() => void);
        type(value?: anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface Scroller extends anychart.core.VisualBase {
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module Scroller {
    interface Thumbs {
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller.Thumbs;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.Scroller.Thumbs;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller.Thumbs;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.ui.Scroller.Thumbs;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.ui.Scroller.Thumbs;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller.Thumbs;
    }
    }
    interface ColorRange extends anychart.core.axes.Linear {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.ColorRange;
        colorLineSize(): number;
        colorLineSize(value?: number): anychart.core.ui.ColorRange;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        length(): number | string;
        length(value?: string | number): anychart.core.ui.ColorRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        marker(): anychart.core.ui.MarkersFactory.Marker;
        marker(value?: anychart.core.ui.MarkersFactory.Marker | Object): anychart.core.ui.ColorRange;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Label extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.Label;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Label;
        position(): anychart.enums.Position;
        position(value?: anychart.enums.Position | string): anychart.core.ui.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Label;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface CrosshairLabel extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.CrosshairLabel;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.CrosshairLabel;
        axisIndex(): number;
        axisIndex(value?: number): anychart.core.ui.CrosshairLabel;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.CrosshairLabel;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        format(): (() => void);
        format(func?: (() => void)): anychart.core.ui.CrosshairLabel;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.CrosshairLabel;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.CrosshairLabel;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.CrosshairLabel;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.CrosshairLabel;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.CrosshairLabel;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.CrosshairLabel;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.CrosshairLabel;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.CrosshairLabel;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Overlay extends anychart.core.Base {
        className(): string;
        className(value?: string): anychart.core.ui.Overlay;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.Overlay;
        getElement(): Element;
        id(): string;
        id(value?: string): anychart.core.ui.Overlay;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StageCredits {
        alt(): string;
        alt(value?: string): anychart.core.ui.StageCredits;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.StageCredits;
        imgAlt(): string;
        imgAlt(value?: string): anychart.core.ui.StageCredits;
        logoSrc(): string;
        logoSrc(value?: string): anychart.core.ui.StageCredits;
        text(): string;
        text(value?: string): anychart.core.ui.StageCredits;
        url(): string;
        url(value?: string): anychart.core.ui.StageCredits;
    }
    interface Tooltip extends anychart.core.VisualBase {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.ui.Tooltip;
        allowLeaveChart(): boolean;
        allowLeaveChart(value?: boolean): anychart.core.ui.Tooltip;
        allowLeaveScreen(): boolean;
        allowLeaveScreen(value?: boolean): anychart.core.ui.Tooltip;
        allowLeaveStage(): boolean;
        allowLeaveStage(value?: boolean): anychart.core.ui.Tooltip;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.Tooltip;
        background(): anychart.core.ui.Background;
        background(value?: boolean | Object | string): anychart.core.ui.Tooltip;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.Tooltip;
        displayMode(): anychart.enums.TooltipDisplayMode;
        displayMode(value?: anychart.enums.TooltipDisplayMode | string): anychart.core.ui.Tooltip;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.Tooltip;
        fontDecoration(): anychart.graphics.vector.Text.Decoration;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Tooltip;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.Tooltip;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.Tooltip;
        fontSize(): number;
        fontSize(value?: number | string): anychart.core.ui.Tooltip;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(value?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.ui.Tooltip;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.ui.Tooltip;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.Tooltip;
        format(): (() => void) | string;
        format(value?: (() => void) | string): anychart.core.ui.Tooltip;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(value?: string | anychart.graphics.vector.Text.HAlign): anychart.core.ui.Tooltip;
        height(): string | number;
        height(value?: string | number): anychart.core.ui.Tooltip;
        hide(force?: boolean, event?: anychart.core.MouseEvent): boolean;
        hideDelay(): number;
        hideDelay(value?: number): anychart.core.ui.Tooltip;
        letterSpacing(): number;
        letterSpacing(value?: number): anychart.core.ui.Tooltip;
        lineHeight(): number | string;
        lineHeight(value?: number | string): anychart.core.ui.Tooltip;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.Tooltip;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.Tooltip;
        offsetX(): number;
        offsetX(value?: number): anychart.core.ui.Tooltip;
        offsetY(): number;
        offsetY(value?: number): anychart.core.ui.Tooltip;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.Tooltip;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Tooltip;
        position(): anychart.enums.Position | string;
        position(value?: anychart.enums.Position | string): anychart.core.ui.Tooltip;
        positionMode(): string;
        positionMode(value?: string | anychart.enums.TooltipPositionMode): anychart.core.ui.Tooltip;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.Tooltip;
        separator(): anychart.core.ui.Separator;
        separator(value?: boolean | Object): anychart.core.ui.Tooltip;
        textDirection(): anychart.graphics.vector.Text.Direction;
        textDirection(value?: string | anychart.graphics.vector.Text.Direction): anychart.core.ui.Tooltip;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.Tooltip;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Tooltip;
        textSettings(): Object | string | number | boolean;
        textSettings(value?: Object): anychart.core.ui.Tooltip;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.ui.Tooltip;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object): anychart.core.ui.Tooltip;
        titleFormat(): (() => void) | string;
        titleFormat(value?: (() => void) | string): anychart.core.ui.Tooltip;
        unionFormat(): (() => void) | string;
        unionFormat(value?: (() => void) | string): anychart.core.ui.Tooltip;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.Tooltip;
        vAlign(): anychart.graphics.vector.Text.VAlign;
        vAlign(value?: string | anychart.graphics.vector.Text.VAlign): anychart.core.ui.Tooltip;
        valuePostfix(): string;
        valuePostfix(value?: string): anychart.core.ui.Tooltip;
        valuePrefix(): string;
        valuePrefix(value?: string): anychart.core.ui.Tooltip;
        width(): string | number;
        width(value?: string | number): anychart.core.ui.Tooltip;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.Tooltip;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.Tooltip;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Background extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bottomStroke(): anychart.graphics.vector.Stroke;
        bottomStroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        bottomStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cornerType(): anychart.enums.BackgroundCornersType;
        cornerType(value?: anychart.enums.BackgroundCornersType): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(value?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        leftStroke(): anychart.graphics.vector.Stroke;
        leftStroke(value: anychart.graphics.vector.Stroke | string): anychart.core.ui.Background;
        leftStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rightStroke(): anychart.graphics.vector.Stroke;
        rightStroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        rightStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        stroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        topStroke(): anychart.graphics.vector.Stroke;
        topStroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        topStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Legend extends anychart.core.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Legend;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Legend;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        drag(): boolean;
        drag(value?: boolean): anychart.core.ui.Legend;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Legend;
        hoverCursor(): anychart.enums.Cursor | string;
        hoverCursor(value?: anychart.enums.Cursor | string): anychart.core.ui.Legend;
        iconSize(): number;
        iconSize(value?: number | string): anychart.core.ui.Legend;
        iconTextSpacing(): number;
        iconTextSpacing(value?: string | number): anychart.core.ui.Legend;
        inverted(): boolean;
        inverted(value?: boolean): anychart.core.ui.Legend;
        items(): Array<anychart.core.ui.Legend.LegendItemProvider>;
        items(value?: Array<anychart.core.ui.Legend.LegendItemProvider>): anychart.core.ui.Legend;
        itemsFormat(): (() => void);
        itemsFormat(value?: (() => void)): anychart.core.ui.Legend;
        itemsFormatter(): (() => void);
        itemsFormatter(value?: (() => void)): anychart.core.ui.Legend;
        itemsLayout(): anychart.enums.LegendLayout | string;
        itemsLayout(value?: string | anychart.enums.LegendLayout): anychart.core.ui.Legend;
        itemsSourceMode(): string | anychart.enums.LegendItemsSourceMode;
        itemsSourceMode(value?: string | anychart.enums.LegendItemsSourceMode): anychart.core.ui.Legend;
        itemsSpacing(): string | number;
        itemsSpacing(value?: string | number): anychart.core.ui.Legend;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Legend;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.ui.Legend;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        paginator(): anychart.core.ui.Paginator;
        paginator(value?: Object | boolean): anychart.core.ui.Legend;
        position(): anychart.enums.Orientation | string;
        position(value?: anychart.enums.Orientation | string): anychart.core.ui.Legend;
        positionMode(): anychart.enums.LegendPositionMode | string;
        positionMode(value?: anychart.enums.LegendPositionMode | string): anychart.core.ui.Legend;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.Legend;
        titleFormat(): string | (() => void);
        titleFormat(value?: string | (() => void)): anychart.core.ui.Legend;
        titleSeparator(): anychart.core.ui.Separator;
        titleSeparator(value?: Object | boolean): anychart.core.ui.Legend;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Legend;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Legend;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    namespace Legend {
    interface LegendItemProvider {
        disabled: boolean;
        iconEnabled: boolean;
        iconFill: anychart.graphics.vector.Fill;
        iconHatchFill: anychart.graphics.vector.HatchFill.HatchFillType | anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill;
        iconMarkerFill: anychart.graphics.vector.Fill;
        iconMarkerStroke: anychart.graphics.vector.Stroke;
        iconMarkerType: string;
        iconStroke: anychart.graphics.vector.Stroke;
        iconTextSpacing: number;
        iconType: string;
        index: number;
        meta: Object;
        text: string;
    }
    }
    interface Separator extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Fill | anychart.core.ui.Separator;
        getRemainingBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Separator;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(spaceOrTopOrTopAndBottom?: string | number | Array<(number|string)> | Object, rightOrRightAndLeft?: string | number, bottom?: string | number, left?: string | number): anychart.core.ui.Separator | anychart.core.utils.Margin;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Separator | anychart.enums.Orientation;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Separator | anychart.graphics.vector.Stroke;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Separator;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Title extends anychart.core.Text {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Title;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Title;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Title;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(allValues?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        orientation(): anychart.enums.Orientation;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Title;
        padding(): anychart.core.utils.Padding;
        padding(value?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.Title;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Title;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Title;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Paginator extends anychart.core.Text {
        background(value?: string | Object | boolean): anychart.core.ui.Paginator | anychart.core.ui.Background;
        currentPage(): number;
        currentPage(value?: number | string): anychart.core.ui.Paginator;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        layout(): anychart.enums.Layout;
        layout(value?: string | anychart.enums.Layout): anychart.core.ui.Paginator;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(spaceOrTopOrTopAndBottom?: string | number | Array<(number|string)> | Object, rightOrRightAndLeft?: string | number, bottom?: string | number, left?: string | number): anychart.core.ui.Paginator | anychart.core.utils.Margin;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Paginator | anychart.enums.Orientation;
        padding(spaceOrTopOrTopAndBottom?: string | number | Array<(number|string)> | Object, rightOrRightAndLeft?: string | number, bottom?: string | number, left?: string | number): anychart.core.ui.Paginator | anychart.core.utils.Padding;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChartScroller extends anychart.core.ui.Scroller {
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        inverted(): boolean;
        inverted(value?: boolean): anychart.core.ui.ChartScroller;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        position(): anychart.enums.ChartScrollerPosition;
        position(value?: anychart.enums.ChartScrollerPosition | string): anychart.core.ui.ChartScroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ScrollBar extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.ui.ScrollBar;
        backgroundStroke(): anychart.graphics.vector.Stroke | string;
        backgroundStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.ScrollBar;
        barSize(): number;
        barSize(value?: number): anychart.core.ui.ScrollBar;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        buttonsVisible(): boolean;
        buttonsVisible(value?: boolean): boolean | anychart.core.ui.ScrollBar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        mouseOutOpacity(): number;
        mouseOutOpacity(value?: number): anychart.core.ui.ScrollBar;
        mouseOverOpacity(): number;
        mouseOverOpacity(value?: number): anychart.core.ui.ScrollBar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        sliderFill(): anychart.graphics.vector.Fill | string;
        sliderFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.ui.ScrollBar;
        sliderStroke(): anychart.graphics.vector.Stroke | string;
        sliderStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.ScrollBar;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface CircularLabelsFactory extends anychart.core.ui.LabelsFactory {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.LabelsFactory;
        autoRotate(): boolean;
        autoRotate(value?: boolean): anychart.core.ui.CircularLabelsFactory;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module CircularLabelsFactory {
    interface Label extends anychart.core.ui.LabelsFactory.Label {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory.Label;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.enums.Anchor;
        autoRotate(): boolean;
        autoRotate(value?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory.Label;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getIndex(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory.Label;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory.Label;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory.Label;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface Crosshair extends anychart.core.VisualBase {
        displayMode(): anychart.enums.CrosshairDisplayMode;
        displayMode(value?: anychart.enums.CrosshairDisplayMode | string): anychart.core.ui.Crosshair;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xLabel(): anychart.core.ui.CrosshairLabel;
        xLabel(value?: Object | boolean): anychart.core.ui.Crosshair;
        xStroke(): anychart.graphics.vector.Stroke;
        xStroke(value?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Crosshair;
        yLabel(): anychart.core.ui.CrosshairLabel;
        yLabel(value?: Object | boolean): anychart.core.ui.Crosshair;
        yStroke(): anychart.graphics.vector.Stroke;
        yStroke(value?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Crosshair;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Table extends anychart.core.VisualBaseWithBounds {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cellBorder(): anychart.graphics.vector.Stroke;
        cellBorder(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellFill(color: string, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.Table;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Table;
        colsCount(): number;
        colsCount(value?: number): anychart.core.ui.Table;
        colsMaxWidth(): string | number;
        colsMaxWidth(value?: string | number): anychart.core.ui.Table;
        colsMinWidth(): string | number;
        colsMinWidth(value?: string | number): anychart.core.ui.Table;
        colsWidth(): string | number;
        colsWidth(value?: string | number): anychart.core.ui.Table;
        contents(): Array<Array<(anychart.core.VisualBase)>>;
        contents(tableValues?: Array<Array<(anychart.core.VisualBase|string|number)>>, demergeCells?: boolean): anychart.core.ui.Table;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.Table;
        draw(): anychart.core.ui.Table;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.Table;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Table;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.Table;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.Table;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.Table;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Table;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Table;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.Table;
        getCell(row: number, col: number): anychart.core.ui.table.Cell;
        getCol(col: number): anychart.core.ui.table.Column;
        getJpgBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number): void;
        getRow(row: number): anychart.core.ui.table.Row;
        getSvgBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Table;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.Table;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.Table;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(): anychart.graphics.vector.Fill;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowsCount(): number;
        rowsCount(value?: number): anychart.core.ui.Table;
        rowsHeight(): string | number;
        rowsHeight(value?: string | number): anychart.core.ui.Table;
        rowsMaxHeight(): string | number;
        rowsMaxHeight(value?: string | number): anychart.core.ui.Table;
        rowsMinHeight(): string | number;
        rowsMinHeight(value?: string | number): anychart.core.ui.Table;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.Table;
        shareAsJpg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Table;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.Table;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Table;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.Table;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Table;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.Table;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.Table;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LegendItem extends anychart.core.Text {
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.core.ui.LegendItem;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getContentBounds(): anychart.math.Rect;
        getHeight(): number;
        getTextElement(): anychart.graphics.vector.Text;
        getWidth(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        iconFill(value?: anychart.graphics.vector.Fill): anychart.graphics.vector.Fill | anychart.core.ui.LegendItem;
        iconHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        iconHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.ui.LegendItem;
        iconStroke(value?: anychart.graphics.vector.Stroke): anychart.graphics.vector.Stroke | anychart.core.ui.LegendItem;
        iconTextSpacing(value?: number): anychart.core.ui.LegendItem | number;
        iconType(value?: string | (() => void)): string | (() => void) | anychart.core.ui.LegendItem;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.LegendItem;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.ui.LegendItem;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(value?: string): string | anychart.core.ui.LegendItem;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        x(value?: number | string): number | string | anychart.core.ui.LegendItem;
        y(value?: number | string): number | string | anychart.core.ui.LegendItem;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Callout extends anychart.core.VisualBase {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Callout;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Callout;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.ui.Callout;
        items(): Array<string>;
        items(value?: Array<string>): anychart.core.ui.Callout;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.ui.Callout;
        length(): number | string;
        length(value?: string | number): anychart.core.ui.Callout;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.ui.Callout;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Callout;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.ui.Callout;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.ui.Callout;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.Callout;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Callout;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.ui.Callout;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.Callout;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Callout;
    }
    interface LabelsFactory extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.LabelsFactory;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        format(): (() => void) | string;
        format(token?: string): anychart.core.ui.LabelsFactory;
        format(func?: (() => void)): anychart.core.ui.LabelsFactory;
        getLabel(index: number): anychart.core.ui.LabelsFactory.Label;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory;
        labelsCount(): number;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module LabelsFactory {
    interface Label extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory.Label;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.enums.Anchor;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory.Label;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getIndex(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory.Label;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory.Label;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory.Label;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface ChartCredits extends anychart.core.Base {
        alt(): string;
        alt(value?: string): anychart.core.ui.ChartCredits;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.ChartCredits;
        imgAlt(): string;
        imgAlt(value?: string): anychart.core.ui.ChartCredits;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        logoSrc(): string;
        logoSrc(value?: string): anychart.core.ui.ChartCredits;
        removeAllListeners(type?: string): number;
        text(): string;
        text(value?: string): anychart.core.ui.ChartCredits;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        url(): string;
        url(value?: string): anychart.core.ui.ChartCredits;
    }
}

declare namespace anychart.core.ui.table {
    interface Border {
        bottom(): anychart.graphics.vector.Stroke;
        bottom(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
        left(): anychart.graphics.vector.Stroke;
        left(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
        right(): anychart.graphics.vector.Stroke;
        right(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
        top(): anychart.graphics.vector.Stroke;
        top(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
    }
    interface Cell extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Cell;
        colSpan(): number;
        colSpan(value?: number): anychart.core.ui.table.Cell;
        content(): anychart.core.VisualBase;
        content(value?: anychart.core.VisualBase | string | number): anychart.core.ui.table.Cell;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.table.Cell;
        fill(color: string, opacity?: number): anychart.core.ui.table.Cell;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Cell;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Cell;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Cell;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        getBounds(): anychart.math.Rect;
        getCol(): anychart.core.ui.table.Column;
        getColNum(): number;
        getRow(): anychart.core.ui.table.Row;
        getRowNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        padding(): anychart.core.ui.table.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.table.Cell;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Cell;
        rowSpan(): number;
        rowSpan(value?: number): anychart.core.ui.table.Cell;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.table.Base;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.table.Base;
    }
    interface Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.table.Base;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.table.Base;
    }
    interface Row extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellFill(color: string, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Base;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.table.Base;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        getCell(col: number): anychart.core.ui.table.Cell;
        getRowNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        height(): string | number;
        height(value?: string | number): anychart.core.ui.table.Row;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        maxHeight(): string | number;
        maxHeight(value?: string | number): anychart.core.ui.table.Row;
        minHeight(): string | number;
        minHeight(value?: string | number): anychart.core.ui.table.Row;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.table.Base;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.table.Base;
    }
    interface Column extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellFill(color: string, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Base;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.table.Base;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        getCell(row: number): anychart.core.ui.table.Cell;
        getColNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        maxWidth(): string | number;
        maxWidth(value?: string | number): anychart.core.ui.table.Column;
        minWidth(): string | number;
        minWidth(value?: string | number): anychart.core.ui.table.Column;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
        width(): string | number;
        width(value?: string | number): anychart.core.ui.table.Column;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.table.Base;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.table.Base;
    }
    interface Padding {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.ui.table.Padding;
        left(): number | string;
        left(value?: number | string): anychart.core.ui.table.Padding;
        right(): number | string;
        right(value?: number | string): anychart.core.ui.table.Padding;
        top(): number | string;
        top(value?: number | string): anychart.core.ui.table.Padding;
    }
}

declare namespace anychart.core.utils {
    interface LegendItemSettings extends anychart.core.Text {
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        disabled(): boolean;
        disabled(value?: boolean): anychart.core.utils.LegendItemSettings;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        format(): string;
        format(value: string | (() => void)): anychart.core.utils.LegendItemSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        iconEnabled(): boolean;
        iconEnabled(value?: boolean): anychart.core.utils.LegendItemSettings;
        iconFill(): anychart.graphics.vector.Fill | (() => void);
        iconFill(value: anychart.graphics.vector.Fill): anychart.core.utils.LegendItemSettings;
        iconFill(color: string, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.LegendItemSettings;
        iconHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        iconHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(): anychart.graphics.vector.Fill | string;
        iconMarkerFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerStroke(): anychart.graphics.vector.Stroke | string;
        iconMarkerStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.LegendItemSettings;
        iconMarkerType(): anychart.enums.MarkerType | string | (() => void);
        iconMarkerType(value?: anychart.enums.MarkerType | string | (() => void)): anychart.core.utils.LegendItemSettings;
        iconSize(): number;
        iconSize(value?: number | string): anychart.core.utils.LegendItemSettings;
        iconStroke(): (() => void) | anychart.graphics.vector.Stroke;
        iconStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.LegendItemSettings;
        iconTextSpacing(): number;
        iconTextSpacing(value?: number): anychart.core.utils.LegendItemSettings;
        iconType(): anychart.enums.LegendItemIconType | string | (() => void);
        iconType(value?: anychart.enums.LegendItemIconType | string | (() => void)): anychart.core.utils.LegendItemSettings;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string | (() => void)): anychart.core.utils.LegendItemSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface UnboundRegionsSettings {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.utils.UnboundRegionsSettings;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.utils.UnboundRegionsSettings;
        fill(color: string, opacity?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.utils.UnboundRegionsSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.UnboundRegionsSettings;
    }
    interface StockInteractivity extends anychart.core.utils.Interactivity {
        scrollOnMouseWheel(): boolean;
        scrollOnMouseWheel(value?: boolean): anychart.core.utils.StockInteractivity;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(value?: boolean): anychart.core.utils.StockInteractivity;
    }
    interface Exports {
        facebook(): Object;
        facebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string, width?: string, height?: string, appId?: string): Object;
        filename(value?: string): string;
        image(): Object;
        image(widthOrOptions?: string | Object, height?: string): Object;
        linkedin(): Object;
        linkedin(captionOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
        pinterest(): Object;
        pinterest(linkOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
        twitter(): Object;
        twitter(urlOrOptions?: string | Object, width?: string, height?: string): Object;
    }
    interface Margin extends anychart.core.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.utils.Margin;
        left(): number | string;
        left(value?: number | string): anychart.core.utils.Margin;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.utils.Margin;
        set(value1?: string | number | Array<(number|string)> | Object, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Margin;
        top(): number | string;
        top(value?: number | string): anychart.core.utils.Margin;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MapInteractivity extends anychart.core.utils.Interactivity {
        copyFormat(): (() => void);
        copyFormat(value?: (() => void)): anychart.core.utils.MapInteractivity;
        drag(): boolean;
        drag(value?: boolean): anychart.core.utils.MapInteractivity;
        hoverMode(): anychart.enums.HoverMode | string;
        hoverMode(value?: anychart.enums.HoverMode | string): anychart.core.utils.Interactivity;
        keyboardZoomAndMove(): boolean;
        keyboardZoomAndMove(value?: boolean): anychart.core.utils.Interactivity;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.utils.Interactivity;
        spotRadius(): number;
        spotRadius(value?: number): anychart.core.utils.Interactivity;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zoomOnDoubleClick(): boolean;
        zoomOnDoubleClick(value?: boolean): anychart.core.utils.Interactivity;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(value?: boolean): anychart.core.utils.Interactivity;
    }
    interface Error extends anychart.core.Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mode(): anychart.enums.ErrorMode | string;
        mode(value?: string | anychart.enums.ErrorMode): anychart.core.utils.Error;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valueError(): string | number;
        valueError(value?: string | number): anychart.core.utils.Error;
        valueErrorStroke(): anychart.graphics.vector.Stroke;
        valueErrorStroke(fillFunction?: (() => void)): anychart.core.utils.Error;
        valueErrorStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Error;
        valueErrorWidth(): number;
        valueErrorWidth(value?: number): anychart.core.utils.Error;
        valueLowerError(): string | number;
        valueLowerError(value?: string | number): anychart.core.utils.Error;
        valueUpperError(): string | number;
        valueUpperError(value?: string | number): anychart.core.utils.Error;
        xError(): string | number;
        xError(value?: string | number): anychart.core.utils.Error;
        xErrorStroke(): anychart.graphics.vector.Stroke;
        xErrorStroke(fillFunction?: (() => void)): anychart.core.utils.Error;
        xErrorStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Error;
        xErrorWidth(): number;
        xErrorWidth(value?: number): anychart.core.utils.Error;
        xLowerError(): string | number;
        xLowerError(value?: string | number): anychart.core.utils.Error;
        xUpperError(): string | number;
        xUpperError(value?: string | number): anychart.core.utils.Error;
    }
    interface QuarterSettings extends anychart.core.Base {
        leftBottom(): anychart.core.utils.Quarter;
        leftBottom(value?: Object): anychart.core.utils.QuarterSettings;
        leftTop(): anychart.core.utils.Quarter;
        leftTop(value?: Object): anychart.core.utils.QuarterSettings;
        rightBottom(): anychart.core.utils.Quarter;
        rightBottom(value?: Object): anychart.core.utils.QuarterSettings;
        rightTop(): anychart.core.utils.Quarter;
        rightTop(value?: Object): anychart.core.utils.QuarterSettings;
    }
    interface Interactivity extends anychart.core.Base {
        hoverMode(): anychart.enums.HoverMode | string;
        hoverMode(value?: anychart.enums.HoverMode | string): anychart.core.utils.Interactivity;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.utils.Interactivity;
        spotRadius(): number;
        spotRadius(value?: number): anychart.core.utils.Interactivity;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface A11y extends anychart.core.Base {

    }
    interface ChartA11y extends anychart.core.utils.A11y {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.utils.ChartA11y;
        mode(): anychart.enums.A11yMode;
        mode(value?: anychart.enums.A11yMode | string): anychart.core.utils.ChartA11y;
        titleFormat(): (() => void) | string;
        titleFormat(value?: (() => void) | string): anychart.core.utils.ChartA11y;
    }
    interface SeriesA11y extends anychart.core.utils.A11y {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.utils.SeriesA11y;
        titleFormat(): (() => void) | string;
        titleFormat(value?: (() => void) | string): anychart.core.utils.SeriesA11y;
    }
    interface Quarter extends anychart.core.ui.Background {
        bottomStroke(): anychart.graphics.vector.Stroke;
        bottomStroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        bottomStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        cornerType(): anychart.enums.BackgroundCornersType;
        cornerType(value?: anychart.enums.BackgroundCornersType): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(value?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        leftStroke(): anychart.graphics.vector.Stroke;
        leftStroke(value: anychart.graphics.vector.Stroke | string): anychart.core.ui.Background;
        leftStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.utils.Quarter;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Quarter;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        rightStroke(): anychart.graphics.vector.Stroke;
        rightStroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        rightStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        stroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.utils.Quarter;
        topStroke(): anychart.graphics.vector.Stroke;
        topStroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        topStroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
    }
    interface Crossing extends anychart.core.Base {
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Crossing;
    }
    interface OrdinalZoom {
        continuous(): boolean;
        continuous(value?: boolean): anychart.core.utils.OrdinalZoom;
        getEndRatio(): number;
        getStartRatio(): number;
        setTo(startRatio: number, endRatio: number): anychart.core.utils.OrdinalZoom;
        setToPointsCount(pointsCount: number, fromEnd?: boolean, scale?: anychart.scales.Base): anychart.core.utils.OrdinalZoom;
        setToValues(startValue: any, endValue: any, scale?: anychart.scales.Base): anychart.core.utils.OrdinalZoom;
    }
    interface Animation extends anychart.core.Base {
        duration(): number;
        duration(value: number): anychart.core.utils.Animation;
        enabled(): boolean;
        enabled(value: boolean): anychart.core.utils.Animation;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Padding extends anychart.core.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.utils.Padding;
        left(): number | string;
        left(value?: number | string): anychart.core.utils.Padding;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.utils.Padding;
        set(value1?: string | number | Array<(number|string)> | Object, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Padding;
        top(): number | string;
        top(value?: number | string): anychart.core.utils.Padding;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bounds extends anychart.core.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.utils.Bounds;
        height(): number | string;
        height(value?: number | string): anychart.core.utils.Bounds;
        left(): number | string;
        left(value?: number | string): anychart.core.utils.Bounds;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.utils.Bounds;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.utils.Bounds;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.utils.Bounds;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.utils.Bounds;
        right(): number | string;
        right(value?: number | string): anychart.core.utils.Bounds;
        set(xOrRect?: number | string | Array<(number|string)> | anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds, y?: number | string, width?: number | string, height?: number | string): anychart.core.utils.Bounds;
        toRect(parentLeftOrRect?: number | anychart.math.Rect | Object, parentTop?: number, parentWidth?: number, parentHeight?: number): anychart.math.Rect;
        top(): number | string;
        top(value?: number | string): anychart.core.utils.Bounds;
        width(): number | string;
        width(value?: number | string): anychart.core.utils.Bounds;
    }
}

declare namespace anychart.core.venn {
    interface Intersections extends anychart.core.Base {
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.venn.Intersections;
        fill(fillFunction?: (() => void)): anychart.core.venn.Intersections;
        fill(color: string, opacity?: number): anychart.core.venn.Intersections;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.venn.Intersections;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.venn.Intersections;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.venn.Intersections;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.venn.Intersections;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.venn.Intersections;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.venn.Intersections;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.venn.Intersections;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.venn.Intersections;
        removeAllListeners(type?: string): number;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.venn.Intersections;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.core.venn.Intersections;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.venn.Intersections;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.venn.Intersections;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.waterfall {
}

declare namespace anychart.core.waterfall.series {
    interface Waterfall extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        fallingFill(fillFunction?: (() => void)): anychart.core.waterfall.series.Waterfall;
        fallingFill(color: string, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.waterfall.series.Waterfall;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        fill(fillFunction?: (() => void)): anychart.core.waterfall.series.Waterfall;
        fill(color: string, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.waterfall.series.Waterfall;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.waterfall.series.Waterfall;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.waterfall.series.Waterfall;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.waterfall.series.Waterfall;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.waterfall.series.Waterfall;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.waterfall.series.Waterfall;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(value?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        risingFill(fillFunction?: (() => void)): anychart.core.waterfall.series.Waterfall;
        risingFill(color: string, opacity?: number): anychart.core.waterfall.series.Waterfall;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.waterfall.series.Waterfall;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.waterfall.series.Waterfall;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.waterfall.series.Waterfall;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.data {
    function buildMapping(dataSet: anychart.data.Set, fromIndex: number, toIndex: number, names: Array<string>, keys?: Array<string>): anychart.data.Mapping;
    function loadCsvFile(url: string, onSuccess: (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function loadGoogleSpreadsheet(key: string | Object, onSuccess: (() => void), onError?: (() => void), timeoutInterval?: number, context?: any): void;
    function loadJsonFile(url: string, onSuccess: (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function loadXmlFile(url: string, onSuccess: (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function mapAsTable(data: Array<Array<any>>, mode?: anychart.enums.MapAsTableMode | string, seriesCount?: number): Array<anychart.data.Mapping>;
    function parseHtmlTable(tableSelector?: string, rowsSelector?: string, cellsSelector?: string, headersSelector?: string, captionSelector?: string, valueProcessor?: (() => void)): anychart.data.DataSettings;
    function parseText(text: string, settings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): Array<Array<(string|number)>>;
    function set(data?: Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.data.Set;
    function table(keyColumnIndex?: number, dateTimePattern?: string, timeOffset?: number, baseDate?: number | Date, locale?: string | anychart.format.Locale): anychart.data.Table;
    function tree(data?: Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod): anychart.data.Tree;
    interface TextParsingSettings {
        columnsSeparator: string;
        cutLength: number;
        ignoreFirstRow: boolean;
        ignoreItems: Array<string>;
        ignoreTrailingSpaces: boolean;
        maxItems: number;
        maxLength: number;
        minLength: number;
        mode: anychart.enums.TextParsingMode;
        rowsSeparator: string;
    }
    interface DataSettings {
        caption: string;
        header: Array<string>;
        rows: Array<any>;
        text: string;
        textSettings: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings;
    }
    interface Tree extends anychart.core.Base {
        addChild(child: Object): anychart.data.Tree.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.Tree.DataItem;
        addData(data: Array<Object> | string, fillingMethod?: anychart.enums.TreeFillingMethod | string, csvSettingsOrDeps?: Object | Array<anychart.data.Tree.Dependency>): anychart.data.Tree;
        createIndexOn(field: string, asString?: boolean): anychart.data.Tree;
        dispatchEvents(): boolean;
        dispatchEvents(value?: boolean): anychart.data.Tree;
        getChildAt(index: number): anychart.data.Tree.DataItem;
        getChildren(): Array<anychart.data.Tree.DataItem>;
        getTraverser(): anychart.data.Traverser;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(mapping?: Object): anychart.data.TreeView;
        numChildren(): number;
        removeAllListeners(type?: string): number;
        removeChild(child: anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        removeChildAt(index: number): anychart.data.Tree.DataItem;
        removeChildren(): anychart.data.Tree;
        removeIndexOn(field: string): anychart.data.Tree;
        search(soughtField: string, value: string | number | boolean, comparisonFn?: (() => void)): anychart.data.Tree.DataItem | Array<anychart.data.Tree.DataItem>;
        searchItems(soughtField: string, value: string | number | boolean, comparisonFn?: (() => void)): Array<anychart.data.Tree.DataItem>;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Tree {
    interface Dependency {
        from: string | number;
        to: string | number;
    }
    }
    module Tree {
    interface DataItem {
        addChild(child: Object | anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.Tree.DataItem;
        del(...var_args: (any)[]): anychart.data.Tree.DataItem;
        get(key: string): any;
        getChildAt(index: number): anychart.data.Tree.DataItem;
        getChildren(): Array<anychart.data.Tree.DataItem>;
        getParent(): anychart.data.Tree.DataItem;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        numChildren(): number;
        remove(): anychart.data.Tree.DataItem;
        removeChild(child: anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        removeChildAt(index: number): anychart.data.Tree.DataItem;
        removeChildren(): anychart.data.Tree.DataItem;
        set(...var_args: (any)[]): anychart.data.Tree.DataItem;
    }
    }
    interface Traverser {
        advance(): boolean;
        current(): anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem;
        get(key: string): any;
        getDepth(): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        nodeYieldCondition(): (() => void);
        nodeYieldCondition(value?: (() => void)): (() => void) | anychart.data.Traverser;
        reset(): anychart.data.Traverser;
        set(key: string, value: any): anychart.data.Traverser;
        toArray(): Array<(anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)>;
        traverseChildrenCondition(): (() => void);
        traverseChildrenCondition(value?: (() => void)): (() => void) | anychart.data.Traverser;
    }
    interface TableIterator {
        advance(): boolean;
        get(field: string): any;
        getIndex(): number;
        getKey(): number;
        reset(): void;
    }
    interface Mapping extends anychart.data.View {
        concat(otherView: anychart.data.View | Array<any>): anychart.data.View;
        derive(): anychart.data.View;
        filter(fieldName: string, func: (() => void)): anychart.data.View;
        find(fieldName: string, fieldValue: any): number;
        get(rowIndex: number, fieldName: string): any;
        getIterator(): anychart.data.Iterator;
        getMapping(): {[prop: string]: Array<(number|string)>};
        getRowsCount(): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        meta(index: number, name: string): any;
        meta(index: number, name: string, value?: any): anychart.data.View;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        set(rowIndex: number, fieldName: string, value: any): anychart.data.View;
        sort(fieldName: string, comparator?: (() => void)): anychart.data.View;
        sort(fieldName: string, order?: anychart.enums.Sort): anychart.data.View;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TreeView extends anychart.core.Base {
        addChild(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.TreeView.DataItem;
        addData(data: Array<Object> | string, fillMethodOrCsvMapping?: anychart.enums.TreeFillingMethod | Object, csvSettingsOrDeps?: Object | Array<anychart.data.Tree.Dependency>): anychart.data.TreeView;
        getChildAt(index: number): anychart.data.TreeView.DataItem;
        getChildren(): Array<anychart.data.TreeView.DataItem>;
        getTraverser(): anychart.data.Traverser;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        numChildren(): number;
        removeChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        removeChildAt(index: number): anychart.data.TreeView.DataItem;
        removeChildren(): anychart.data.TreeView;
        search(soughtField: string, value: string | number | boolean, comparisonFn?: (() => void) | Object): anychart.data.TreeView.DataItem | Array<anychart.data.TreeView.DataItem>;
        searchItems(soughtField: string, value: string | number | boolean, comparisonFn?: (() => void) | Object): Array<anychart.data.TreeView.DataItem>;
    }
    module TreeView {
    interface DataItem {
        addChild(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.TreeView.DataItem;
        del(...var_args: (any)[]): anychart.data.TreeView.DataItem;
        get(...var_args: (any)[]): any;
        getChildAt(index: number): anychart.data.TreeView.DataItem;
        getChildren(): Array<anychart.data.TreeView.DataItem>;
        getParent(): anychart.data.TreeView.DataItem;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        numChildren(): number;
        remove(): anychart.data.TreeView.DataItem;
        removeChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        removeChildAt(index: number): anychart.data.TreeView.DataItem;
        removeChildren(): anychart.data.TreeView.DataItem;
        set(...var_args: (any)[]): anychart.data.TreeView.DataItem;
    }
    }
    interface View extends anychart.core.Base {
        concat(otherView: anychart.data.View | Array<any>): anychart.data.View;
        derive(): anychart.data.View;
        filter(fieldName: string, func: (() => void)): anychart.data.View;
        find(fieldName: string, fieldValue: any): number;
        get(rowIndex: number, fieldName: string): any;
        getDataSets(): Array<anychart.data.Set>;
        getIterator(): anychart.data.Iterator;
        getRowsCount(): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        meta(index: number, name: string): any;
        meta(index: number, name: string, value?: any): anychart.data.View;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        set(rowIndex: number, fieldName: string, value: any): anychart.data.View;
        sort(fieldName: string, comparator?: (() => void)): anychart.data.View;
        sort(fieldName: string, order?: anychart.enums.Sort): anychart.data.View;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Set extends anychart.core.Base {
        append(...var_args: (any)[]): anychart.data.Set;
        data(): Array<any>;
        data(value?: Array<any> | string, settings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.data.Set;
        getRowsCount(): number;
        insert(row: any, index?: number): anychart.data.Set;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(mapping?: Object): anychart.data.Mapping;
        remove(index: number): anychart.data.Set;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TableSelectable {
        getIterator(): anychart.data.TableIterator;
        search(key: number, mode?: anychart.enums.TableSearchMode): anychart.data.TableSelectable.RowProxy;
        select(startDate: number | string | Date, endDate: number | string | Date, intervalUnit?: anychart.enums.Interval, intervalCount?: number): anychart.data.TableSelectable;
        selectAll(intervalUnit?: anychart.enums.Interval, intervalCount?: number): anychart.data.TableSelectable;
    }
    module TableSelectable {
    interface RowProxy {
        get(field: string): any;
        getColumn(column: number): any;
        getIndex(): number;
        getKey(): number;
    }
    }
    interface TableComputer {
        addOutputField(name: string, uid?: string): number;
        getFieldIndex(name: string): number;
        setCalculationFunction(value: (() => void)): void;
        setContext(value: Object): void;
        setStartFunction(func: (() => void)): void;
    }
    module TableComputer {
    interface RowProxy extends anychart.data.TableSelectable.RowProxy {
        get(field: string): any;
        getColumn(column: number): any;
        getIndex(): number;
        getKey(): number;
        set(name: string, value: any): boolean;
        setColumn(index: number, value: any): boolean;
    }
    }
    interface TableMapping extends anychart.core.Base {
        addField(name: string, column: number, type?: anychart.enums.AggregationType, weightsColumn?: number): anychart.data.TableMapping;
        createSelectable(): anychart.data.TableSelectable;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Table extends anychart.core.Base {
        addData(rawData: Array<any> | string, removeFromStart?: boolean | number, csvSettings?: Object): anychart.data.Table;
        createComputer(mappingSettingsOrMapping?: anychart.data.TableMapping | {[prop: string]: ({column: (number|string), type:anychart.enums.AggregationType, weights: (number|string)}|number|string)}): anychart.data.TableComputer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(fields?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}): anychart.data.TableMapping;
        remove(startKey?: number | string | Date, endKey?: number | string | Date): anychart.data.Table;
        removeAllListeners(type?: string): number;
        removeFirst(count?: number): anychart.data.Table;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Iterator {
        advance(): boolean;
        get(fieldName: string): any;
        getIndex(): number;
        getRowsCount(): number;
        meta(name: string): any;
        meta(name: string, value?: any): anychart.data.Iterator;
        reset(): anychart.data.Iterator;
        select(index: number): boolean;
    }
}

declare namespace anychart.enums {
    enum Anchor {
        AUTO,
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Position {
        AUTO,
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Align {
        BOTTOM,
        CENTER,
        LEFT,
        RIGHT,
        TOP
    }
    enum Layout {
        HORIZONTAL,
        VERTICAL
    }
    enum Orientation {
        BOTTOM,
        LEFT,
        RIGHT,
        TOP
    }
    enum Sort {
        ASC,
        DESC,
        NONE
    }
    enum MarkerType {
        ARROWHEAD,
        ARROW_DOWN,
        ARROW_LEFT,
        ARROW_RIGHT,
        ARROW_UP,
        CIRCLE,
        CROSS,
        DIAGONAL_CROSS,
        DIAMOND,
        LINE,
        PENTAGON,
        SQUARE,
        STAR10,
        STAR4,
        STAR5,
        STAR6,
        STAR7,
        TRAPEZIUM,
        TRIANGLE_DOWN,
        TRIANGLE_LEFT,
        TRIANGLE_RIGHT,
        TRIANGLE_UP
    }
    enum MapAsTableMode {
        OHLC,
        RANGE,
        VALUE
    }
    enum TreeFillingMethod {
        AS_TABLE,
        AS_TREE
    }
    enum LabelsOverlapMode {
        ALLOW_OVERLAP,
        NO_OVERLAP
    }
    enum BackgroundCornersType {
        CUT,
        NONE,
        ROUND,
        ROUND_INNER
    }
    enum LegendItemIconType {
        AREA,
        BAR,
        BUBBLE,
        CANDLESTICK,
        CIRCLE,
        COLUMN,
        LINE,
        MARKER,
        OHLC,
        RANGE_AREA,
        RANGE_BAR,
        RANGE_COLUMN,
        RANGE_SPLINE_AREA,
        RANGE_STEP_AREA,
        SPLINE,
        SPLINE_AREA,
        SQUARE,
        STEP_AREA,
        STEP_LINE
    }
    enum BulletMarkerType {
        BAR,
        ELLIPSE,
        LINE,
        X
    }
    enum SidePosition {
        CENTER,
        INSIDE,
        OUTSIDE
    }
    enum EventType {
        ANIMATION_END,
        ANIMATION_START,
        ANNOTATION_CHANGE,
        ANNOTATION_CHANGE_FINISH,
        ANNOTATION_CHANGE_START,
        ANNOTATION_DRAWING_FINISH,
        ANNOTATION_SELECT,
        ANNOTATION_UNSELECT,
        BEFORE_CREATE_CONNECTOR,
        CHART_DRAW,
        CLOSE,
        COMPLETE,
        CONNECTOR_CLICK,
        CONNECTOR_DBL_CLICK,
        CONNECTOR_MOUSE_DOWN,
        CONNECTOR_MOUSE_MOVE,
        CONNECTOR_MOUSE_OUT,
        CONNECTOR_MOUSE_OVER,
        CONNECTOR_MOUSE_UP,
        CONNECTOR_SELECT,
        DATA_CHANGED,
        DRAG,
        DRAG_END,
        DRAG_START,
        DRILL_CHANGE,
        LEGEND_ITEM_CLICK,
        LEGEND_ITEM_DBLCLICK,
        LEGEND_ITEM_MOUSE_DOWN,
        LEGEND_ITEM_MOUSE_MOVE,
        LEGEND_ITEM_MOUSE_OUT,
        LEGEND_ITEM_MOUSE_OVER,
        LEGEND_ITEM_MOUSE_UP,
        POINTS_HOVER,
        POINTS_SELECT,
        POINT_CLICK,
        POINT_DBLCLICK,
        POINT_MOUSE_DOWN,
        POINT_MOUSE_MOVE,
        POINT_MOUSE_OUT,
        POINT_MOUSE_OVER,
        POINT_MOUSE_UP,
        ROW_CLICK,
        ROW_DBL_CLICK,
        ROW_MOUSE_DOWN,
        ROW_MOUSE_MOVE,
        ROW_MOUSE_OUT,
        ROW_MOUSE_OVER,
        ROW_MOUSE_UP,
        ROW_SELECT,
        SCROLLER_CHANGE,
        SCROLLER_CHANGE_FINISH,
        SCROLLER_CHANGE_START,
        SCROLL_CHANGE,
        SELECTED_RANGE_BEFORE_CHANGE,
        SELECTED_RANGE_CHANGE,
        SELECTED_RANGE_CHANGE_FINISH,
        SELECTED_RANGE_CHANGE_START,
        SELECT_MARQUEE_CHANGE,
        SELECT_MARQUEE_FINISH,
        SELECT_MARQUEE_START,
        SIGNAL,
        SPLITTER_CHANGE,
        TREE_ITEM_CREATE,
        TREE_ITEM_MOVE,
        TREE_ITEM_REMOVE,
        TREE_ITEM_UPDATE,
        ZOOM,
        ZOOM_END,
        ZOOM_START
    }
    enum ScaleStackMode {
        NONE,
        PERCENT,
        VALUE
    }
    enum ScatterTicksMode {
        LINEAR,
        LOGARITHMIC
    }
    enum SparklineSeriesType {
        AREA,
        COLUMN,
        LINE,
        WIN_LOSS
    }
    enum GanttDataFields {
        ACTUAL,
        ACTUAL_END,
        ACTUAL_START,
        BASELINE,
        BASELINE_END,
        BASELINE_START,
        CHILDREN,
        COLLAPSED,
        CONNECTOR,
        CONNECTOR_TYPE,
        CONNECT_TO,
        END,
        END_MARKER,
        FILL,
        HOVER_FILL,
        HOVER_STROKE,
        ID,
        LABEL,
        MARKERS,
        MILESTONE,
        NAME,
        PARENT,
        PERIODS,
        PROGRESS,
        PROGRESS_VALUE,
        ROW_HEIGHT,
        START,
        START_MARKER,
        STROKE
    }
    enum ScaleTypes {
        DATE_TIME,
        DATE_TIME_WITH_CALENDAR,
        GANTT,
        LINEAR,
        LINEAR_COLOR,
        LOG,
        ORDINAL,
        ORDINAL_COLOR
    }
    enum ScatterScaleTypes {
        DATE_TIME,
        LINEAR,
        LOG
    }
    enum Interval {
        DAY,
        HOUR,
        MILLISECOND,
        MINUTE,
        MONTH,
        QUARTER,
        SECOND,
        SEMESTER,
        THIRD_OF_MONTH,
        WEEK,
        YEAR
    }
    enum ErrorMode {
        BOTH,
        NONE,
        VALUE,
        X
    }
    enum GaugeSidePosition {
        CENTER,
        INSIDE,
        OUTSIDE
    }
    enum GaugeScaleTypes {
        LINEAR,
        LOG
    }
    enum Cursor {
        CROSSHAIR,
        DEFAULT,
        EW_RESIZE,
        E_RESIZE,
        HELP,
        MOVE,
        NESW_RESIZE,
        NE_RESIZE,
        NS_RESIZE,
        NWSE_RESIZE,
        NW_RESIZE,
        N_RESIZE,
        POINTER,
        SE_RESIZE,
        SW_RESIZE,
        S_RESIZE,
        TEXT,
        WAIT,
        W_RESIZE
    }
    enum LegendItemsSourceMode {
        CATEGORIES,
        DEFAULT
    }
    enum PyramidLabelsPosition {
        INSIDE,
        OUTSIDE_LEFT,
        OUTSIDE_LEFT_IN_COLUMN,
        OUTSIDE_RIGHT,
        OUTSIDE_RIGHT_IN_COLUMN
    }
    enum ColumnFormats {
        DATE_COMMON_LOG,
        DATE_DMY_DOTS,
        DATE_ISO_8601,
        DATE_US_SHORT,
        DIRECT_NUMBERING,
        FINANCIAL,
        PERCENT,
        SHORT_TEXT,
        TEXT
    }
    enum AggregationType {
        AVERAGE,
        FIRST,
        FIRST_VALUE,
        LAST,
        LAST_VALUE,
        LIST,
        MAX,
        MIN,
        SUM,
        WEIGHTED_AVERAGE
    }
    enum StockLabelsOverlapMode {
        ALLOW_MAJOR_OVERLAP,
        ALLOW_MINOR_OVERLAP,
        ALLOW_OVERLAP,
        NO_OVERLAP
    }
    enum TableSearchMode {
        EXACT,
        EXACT_OR_NEXT,
        EXACT_OR_PREV,
        NEAREST
    }
    enum HoverMode {
        BY_SPOT,
        BY_X,
        SINGLE
    }
    enum SelectionMode {
        DRILL_DOWN,
        MULTI_SELECT,
        NONE,
        SINGLE_SELECT
    }
    enum TooltipDisplayMode {
        SEPARATED,
        SINGLE,
        UNION
    }
    enum TooltipPositionMode {
        CHART,
        FLOAT,
        POINT
    }
    enum CrosshairDisplayMode {
        FLOAT,
        STICKY
    }
    enum LabelsDisplayMode {
        ALWAYS_SHOW,
        CLIP,
        DROP
    }
    enum ChartScrollerPosition {
        AFTER_AXES,
        BEFORE_AXES
    }
    enum ConnectorType {
        FINISH_FINISH,
        FINISH_START,
        START_FINISH,
        START_START
    }
    enum GanttDateTimeMarkers {
        CURRENT,
        END,
        START
    }
    enum ChartDataExportMode {
        GROUPED,
        RAW,
        SELECTED,
        SPECIFIC
    }
    enum StringToken {
        ACTIVITY_INDEX,
        AVERAGE,
        AXIS_NAME,
        AXIS_SCALE_MAX,
        AXIS_SCALE_MIN,
        BUBBLE_SIZE,
        BUBBLE_SIZE_PERCENT_OF_CATEGORY,
        BUBBLE_SIZE_PERCENT_OF_SERIES,
        BUBBLE_SIZE_PERCENT_OF_TOTAL,
        CATEGORY_NAME,
        CATEGORY_Y_AVERAGE,
        CATEGORY_Y_MEDIAN,
        CATEGORY_Y_MODE,
        CATEGORY_Y_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_AVERAGE,
        CATEGORY_Y_RANGE_MAX,
        CATEGORY_Y_RANGE_MEDIAN,
        CATEGORY_Y_RANGE_MIN,
        CATEGORY_Y_RANGE_MODE,
        CATEGORY_Y_RANGE_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_SUM,
        CATEGORY_Y_SUM,
        CLOSE,
        CUMULATIVE_FREQUENCY,
        DATA_PLOT_BUBBLE_MAX_SIZE,
        DATA_PLOT_BUBBLE_MIN_SIZE,
        DATA_PLOT_BUBBLE_SIZE_AVERAGE,
        DATA_PLOT_BUBBLE_SIZE_SUM,
        DATA_PLOT_MAX_Y_SUM_SERIES_NAME,
        DATA_PLOT_MAX_Y_VALUE_POINT_NAME,
        DATA_PLOT_MAX_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MIN_Y_SUM_SERIES_NAME,
        DATA_PLOT_MIN_Y_VALUE_POINT_NAME,
        DATA_PLOT_MIN_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_POINT_COUNT,
        DATA_PLOT_SERIES_COUNT,
        DATA_PLOT_X_AVERAGE,
        DATA_PLOT_X_MAX,
        DATA_PLOT_X_MIN,
        DATA_PLOT_X_SUM,
        DATA_PLOT_Y_AVERAGE,
        DATA_PLOT_Y_MAX,
        DATA_PLOT_Y_MIN,
        DATA_PLOT_Y_RANGE_MAX,
        DATA_PLOT_Y_RANGE_MIN,
        DATA_PLOT_Y_RANGE_SUM,
        DATA_PLOT_Y_SUM,
        END,
        HIGH,
        INDEX,
        LOW,
        MINUTES_PER_DAY,
        NAME,
        OPEN,
        PERT_CHART_CRITICAL_PATH_STANDARD_DEVIATION,
        PERT_CHART_PROJECT_DURATION,
        RANGE,
        RANGE_END,
        RANGE_START,
        RELATIVE_FREQUENCY,
        RESOURCE_INDEX,
        SERIES_BUBBLE_MAX_SIZE,
        SERIES_BUBBLE_MIN_SIZE,
        SERIES_BUBBLE_SIZE_AVERAGE,
        SERIES_BUBBLE_SIZE_MEDIAN,
        SERIES_BUBBLE_SIZE_MODE,
        SERIES_BUBBLE_SIZE_SUM,
        SERIES_FIRST_X_VALUE,
        SERIES_FIRST_Y_VALUE,
        SERIES_LAST_X_VALUE,
        SERIES_LAST_Y_VALUE,
        SERIES_NAME,
        SERIES_POINT_COUNT,
        SERIES_X_AVERAGE,
        SERIES_X_AXIS_NAME,
        SERIES_X_MAX,
        SERIES_X_MEDIAN,
        SERIES_X_MIN,
        SERIES_X_MODE,
        SERIES_X_SUM,
        SERIES_Y_AVERAGE,
        SERIES_Y_AXIS_NAME,
        SERIES_Y_MAX,
        SERIES_Y_MEDIAN,
        SERIES_Y_MIN,
        SERIES_Y_MODE,
        SERIES_Y_RANGE_MAX,
        SERIES_Y_RANGE_MIN,
        SERIES_Y_RANGE_SUM,
        SERIES_Y_SUM,
        START,
        VALUE,
        X_PERCENT_OF_SERIES,
        X_PERCENT_OF_TOTAL,
        X_VALUE,
        Y_PERCENT_OF_CATEGORY,
        Y_PERCENT_OF_SERIES,
        Y_PERCENT_OF_TOTAL,
        Y_VALUE
    }
    enum Statistics {
        AVERAGE,
        BUBBLE_SIZE,
        BUBBLE_SIZE_PERCENT_OF_CATEGORY,
        BUBBLE_SIZE_PERCENT_OF_SERIES,
        BUBBLE_SIZE_PERCENT_OF_TOTAL,
        CATEGORY_NAME,
        CATEGORY_Y_AVERAGE,
        CATEGORY_Y_MAX,
        CATEGORY_Y_MEDIAN,
        CATEGORY_Y_MIN,
        CATEGORY_Y_MODE,
        CATEGORY_Y_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_AVERAGE,
        CATEGORY_Y_RANGE_MAX,
        CATEGORY_Y_RANGE_MEDIAN,
        CATEGORY_Y_RANGE_MIN,
        CATEGORY_Y_RANGE_MODE,
        CATEGORY_Y_RANGE_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_SUM,
        CATEGORY_Y_SUM,
        CLOSE,
        COUNT,
        DATA_PLOT_BUBBLE_MAX_SIZE,
        DATA_PLOT_BUBBLE_MIN_SIZE,
        DATA_PLOT_BUBBLE_SIZE_AVERAGE,
        DATA_PLOT_BUBBLE_SIZE_SUM,
        DATA_PLOT_MAX_X_SUM_SERIES_NAME,
        DATA_PLOT_MAX_X_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MAX_Y_SUM_SERIES_NAME,
        DATA_PLOT_MAX_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MIN_X_SUM_SERIES_NAME,
        DATA_PLOT_MIN_X_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MIN_Y_SUM_SERIES_NAME,
        DATA_PLOT_MIN_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_POINT_COUNT,
        DATA_PLOT_SERIES_COUNT,
        DATA_PLOT_X_AVERAGE,
        DATA_PLOT_X_MAX,
        DATA_PLOT_X_MIN,
        DATA_PLOT_X_SUM,
        DATA_PLOT_Y_AVERAGE,
        DATA_PLOT_Y_MAX,
        DATA_PLOT_Y_MIN,
        DATA_PLOT_Y_RANGE_MAX,
        DATA_PLOT_Y_RANGE_MIN,
        DATA_PLOT_Y_RANGE_SUM,
        DATA_PLOT_Y_SUM,
        HIGH,
        INDEX,
        LOW,
        MAX,
        MIN,
        NAME,
        OPEN,
        PERT_CHART_CRITICAL_PATH_STANDARD_DEVIATION,
        PERT_CHART_PROJECT_DURATION,
        POINTS_COUNT,
        RANGE,
        RANGE_END,
        RANGE_START,
        SERIES_AVERAGE,
        SERIES_BUBBLE_MAX_SIZE,
        SERIES_BUBBLE_MIN_SIZE,
        SERIES_BUBBLE_SIZE_AVERAGE,
        SERIES_BUBBLE_SIZE_MEDIAN,
        SERIES_BUBBLE_SIZE_MODE,
        SERIES_BUBBLE_SIZE_SUM,
        SERIES_FIRST_X_VALUE,
        SERIES_FIRST_Y_VALUE,
        SERIES_LAST_X_VALUE,
        SERIES_LAST_Y_VALUE,
        SERIES_MAX,
        SERIES_MIN,
        SERIES_NAME,
        SERIES_POINTS_COUNT,
        SERIES_POINT_COUNT,
        SERIES_SUM,
        SERIES_X_AVERAGE,
        SERIES_X_MAX,
        SERIES_X_MEDIAN,
        SERIES_X_MIN,
        SERIES_X_MODE,
        SERIES_X_SUM,
        SERIES_Y_AVERAGE,
        SERIES_Y_MAX,
        SERIES_Y_MEDIAN,
        SERIES_Y_MIN,
        SERIES_Y_MODE,
        SERIES_Y_RANGE_AVERAGE,
        SERIES_Y_RANGE_MAX,
        SERIES_Y_RANGE_MEDIAN,
        SERIES_Y_RANGE_MIN,
        SERIES_Y_RANGE_MODE,
        SERIES_Y_RANGE_SUM,
        SERIES_Y_SUM,
        SUM,
        VALUE,
        X_PERCENT_OF_SERIES,
        X_PERCENT_OF_TOTAL,
        X_SCALES_MAX,
        X_SCALES_MIN,
        X_VALUE,
        Y_PERCENT_OF_CATEGORY,
        Y_PERCENT_OF_SERIES,
        Y_PERCENT_OF_TOTAL,
        Y_SCALES_MAX,
        Y_SCALES_MIN,
        Y_VALUE
    }
    enum MapProjections {
        AITOFF,
        AUGUST,
        BONNE,
        ECKERT1,
        ECKERT3,
        EQUIRECTANGULAR,
        FAHEY,
        HAMMER,
        MERCATOR,
        ORTHOGRAPHIC,
        ROBINSON,
        WAGNER6,
        WSG84
    }
    enum A11yMode {
        CHART_ELEMENTS,
        DATA_TABLE
    }
    enum MilestoneShape {
        CIRCLE,
        RECTANGLE,
        RHOMBUS
    }
    enum DataField {
        DEPENDS_ON,
        DURATION,
        EXPECTED,
        FROM,
        ID,
        MOST_LIKELY,
        NAME,
        OPTIMISTIC,
        PESSIMISTIC,
        TO
    }
    enum MapUnboundRegionsMode {
        AS_IS,
        HIDE
    }
    enum ScaleComparisonMode {
        NONE,
        PERCENT,
        VALUE
    }
    enum ScaleCompareWithMode {
        FIRST_VISIBLE,
        SERIES_START
    }
    enum AnnotationTypes {
        ANDREWS_PITCHFORK,
        ELLIPSE,
        FIBONACCI_ARC,
        FIBONACCI_FAN,
        FIBONACCI_RETRACEMENT,
        FIBONACCI_TIMEZONES,
        HORIZONTAL_LINE,
        INFINITE_LINE,
        LINE,
        MARKER,
        RAY,
        RECTANGLE,
        TREND_CHANNEL,
        TRIANGLE,
        VERTICAL_LINE
    }
    enum LinearGaugePointerType {
        BAR,
        LED,
        MARKER,
        RANGE_BAR,
        TANK,
        THERMOMETER
    }
    enum MapSeriesType {
        BUBBLE,
        CHOROPLETH,
        CONNECTOR,
        MARKER
    }
    enum CartesianSeriesType {
        AREA,
        BAR,
        BOX,
        BUBBLE,
        CANDLESTICK,
        COLUMN,
        JUMP_LINE,
        LINE,
        MARKER,
        OHLC,
        RANGE_AREA,
        RANGE_BAR,
        RANGE_COLUMN,
        RANGE_SPLINE_AREA,
        RANGE_STEP_AREA,
        SPLINE,
        SPLINE_AREA,
        STEP_AREA,
        STEP_LINE,
        STICK
    }
    enum Cartesian3dSeriesType {
        AREA,
        BAR,
        COLUMN
    }
    enum ScatterSeriesType {
        BUBBLE,
        LINE,
        MARKER
    }
    enum StockSeriesType {
        AREA,
        CANDLESTICK,
        COLUMN,
        JUMP_LINE,
        LINE,
        MARKER,
        OHLC,
        RANGE_AREA,
        RANGE_COLUMN,
        RANGE_SPLINE_AREA,
        RANGE_STEP_AREA,
        SPLINE,
        SPLINE_AREA,
        STEP_AREA,
        STEP_LINE,
        STICK
    }
    enum RadarSeriesType {
        AREA,
        LINE,
        MARKER
    }
    enum PolarSeriesType {
        AREA,
        COLUMN,
        LINE,
        MARKER,
        POLYGON,
        POLYLINE,
        RANGE_COLUMN
    }
    enum AvailabilityPeriod {
        DAY,
        NONE,
        WEEK,
        YEAR
    }
    enum LocaleDateTimeFormat {
        DAY,
        DAY_HOUR,
        DAY_MILLISECOND,
        DAY_MINUTE,
        DAY_SECOND,
        HOUR,
        HOUR_MILLISECOND,
        HOUR_MINUTE,
        HOUR_SECOND,
        MILLISECOND,
        MINUTE,
        MINUTE_MILLISECOND,
        MINUTE_SECOND,
        MONTH,
        MONTH_DAY,
        MONTH_HOUR,
        MONTH_MILLISECOND,
        MONTH_MINUTE,
        MONTH_SECOND,
        MONTH_THIRD_OF_MONTH,
        MONTH_WEEK,
        QUARTER,
        QUARTER_DAY,
        QUARTER_HOUR,
        QUARTER_MILLISECOND,
        QUARTER_MINUTE,
        QUARTER_MONTH,
        QUARTER_SECOND,
        QUARTER_THIRD_OF_MONTH,
        QUARTER_WEEK,
        SECOND,
        SECOND_MILLISECOND,
        SEMESTER,
        SEMESTER_DAY,
        SEMESTER_HOUR,
        SEMESTER_MILLISECOND,
        SEMESTER_MINUTE,
        SEMESTER_MONTH,
        SEMESTER_QUARTER,
        SEMESTER_SECOND,
        SEMESTER_THIRD_OF_MONTH,
        SEMESTER_WEEK,
        THIRD_OF_MONTH,
        THIRD_OF_MONTH_DAY,
        THIRD_OF_MONTH_HOUR,
        THIRD_OF_MONTH_MILLISECOND,
        THIRD_OF_MONTH_MINUTE,
        THIRD_OF_MONTH_SECOND,
        THIRD_OF_MONTH_WEEK,
        WEEK,
        WEEK_DAY,
        WEEK_HOUR,
        WEEK_MILLISECOND,
        WEEK_MINUTE,
        WEEK_SECOND,
        YEAR,
        YEAR_DAY,
        YEAR_HOUR,
        YEAR_MILLISECOND,
        YEAR_MINUTE,
        YEAR_MONTH,
        YEAR_QUARTER,
        YEAR_SECOND,
        YEAR_SEMESTER,
        YEAR_THIRD_OF_MONTH,
        YEAR_WEEK
    }
    enum MapGridZIndex {
        OVER_MAP = 45,
        UNDER_MAP = 5
    }
    enum GanttRangeAnchor {
        FIRST_DATE,
        FIRST_VISIBLE_DATE,
        LAST_DATE,
        LAST_VISIBLE_DATE
    }
    enum StockRangeAnchor {
        FIRST_DATE,
        FIRST_VISIBLE_DATE,
        LAST_DATE,
        LAST_VISIBLE_DATE
    }
    enum StockRangeType {
        MAX,
        MTD,
        QTD,
        UNIT,
        YTD
    }
    enum TimeTrackingMode {
        ACTIVITY_PER_CHART,
        ACTIVITY_PER_RESOURCE,
        AVAILABILITY_PER_CHART,
        AVAILABILITY_PER_RESOURCE
    }
    enum ShapeType {
        CIRCLE,
        ELLIPSE,
        PATH,
        RECT
    }
    enum StepDirection {
        BACKWARD,
        CENTER,
        FORWARD
    }
    enum FontStyle {
        ITALIC,
        NORMAL,
        OBLIQUE
    }
    enum FontVariant {
        NORMAL,
        SMALL_CAP
    }
    enum HAlign {
        CENTER,
        END,
        LEFT,
        RIGHT,
        START
    }
    enum VAlign {
        BOTTOM,
        MIDDLE,
        TOP
    }
    enum WordBreak {
        BREAK_ALL,
        KEEP_ALL,
        NORMAL
    }
    enum WordWrap {
        BREAK_WORD,
        NORMAL
    }
    enum MovingAverageType {
        EMA,
        SMA
    }
    enum LegendLayout {
        HORIZONTAL,
        HORIZONTAL_EXPANDABLE,
        VERTICAL,
        VERTICAL_EXPANDABLE
    }
    enum LegendPositionMode {
        INSIDE,
        OUTSIDE
    }
    enum PointState {
        HOVER = 1,
        NORMAL = 0,
        SELECT = 2
    }
    enum MekkoSeriesType {
        MEKKO
    }
    enum TextParsingMode {
        BY_CHAR,
        BY_WORD,
        CSV
    }
    enum TagCloudMode {
        RECT,
        SPIRAL
    }
    enum WaterfallDataMode {
        ABSOLUTE,
        DIFF
    }
    enum PriceIndicatorDataSource {
        FIRST_VISIBLE,
        LAST_VISIBLE,
        SERIES_END,
        SERIES_START
    }
    enum ScaleStackDirection {
        DIRECT,
        REVERSE
    }
}

declare namespace anychart.exports {
    function facebook(): Object;
    function facebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string, width?: string, height?: string, appId?: string): Object;
    function filename(value?: string): string;
    function image(): Object;
    function image(widthOrOptions?: string | Object, height?: string): Object;
    function linkedin(): Object;
    function linkedin(captionOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
    function pinterest(): Object;
    function pinterest(linkOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
    function server(address?: string): string;
    function twitter(): Object;
    function twitter(urlOrOptions?: string | Object, width?: string, height?: string): Object;
}

declare namespace anychart.format {
    function date(date: number | Date, timeZone?: number, locale?: string | anychart.format.Locale): string;
    function dateTime(date: number | Date, format?: string, timeZone?: number, locale?: string | anychart.format.Locale): string;
    function getDateTimeFormat(identifier: string, index?: number, locale?: anychart.format.Locale): string;
    function getDateTimeFormats(identifier: string, locale?: anychart.format.Locale): string;
    function getIntervalIdentifier(intervalUnit: anychart.enums.Interval, parentIntervalUnit?: anychart.enums.Interval): string;
    function getMessage(keyword: string): string;
    function inputBaseDate(): Date | Date;
    function inputBaseDate(value: Date | number): Date;
    function inputDateTimeFormat(): string;
    function inputDateTimeFormat(value?: string): string;
    function inputLocale(): string | anychart.format.Locale;
    function inputLocale(value?: string | anychart.format.Locale): string | anychart.format.Locale;
    function number(number: number, decimalsCountOrLocal?: number | anychart.format.NumberLocale | string, decimalPoint?: string, groupsSeparator?: string, scale?: Object | boolean, zeroFillDecimals?: boolean, scaleSuffixSeparator?: string, useBracketsForNegative?: boolean): string;
    function number(number: number, object?: anychart.format.NumberLocale): string;
    function outputDateFormat(): string;
    function outputDateFormat(value?: string): void;
    function outputDateTimeFormat(): string;
    function outputDateTimeFormat(value?: string): void;
    function outputLocale(): string | anychart.format.Locale;
    function outputLocale(value?: string | anychart.format.Locale): string | anychart.format.Locale;
    function outputTimeFormat(): string;
    function outputTimeFormat(value?: string): void;
    function outputTimezone(): number;
    function outputTimezone(value?: number): number;
    function parseDateTime(value: any, format?: string, baseDate?: Date, locale?: string | anychart.format.Locale): Date;
    function parseNumber(value: any, locale?: anychart.format.NumberLocale | string): number;
    function subs(string: string, ...var_args: (any)[]): string;
    function time(date: number | Date, timeZone?: number, locale?: string | anychart.format.Locale): string;
    interface locales {
        localeName: string;
        localeSettings: anychart.format.Locale;
    }
    interface NumberLocale {
        decimalPoint: string;
        decimalsCount: number;
        groupsSeparator: string;
        scale: Object | boolean;
        scaleSuffixSeparator: string;
        useBracketsForNegative: boolean;
        zeroFillDecimals: boolean;
    }
    interface DateTimeLocale {
        ampms: Array<string>;
        dateFormats: string;
        dateTimeFormats: string;
        eras: Array<string>;
        erasNames: Array<string>;
        firstDayOfWeek: number;
        firstWeekCutOfDay: number;
        formats: {[prop: string]: (string|Array<string>)};
        months: Array<string>;
        narrowMonths: Array<string>;
        narrowWeekdays: Array<string>;
        quarters: Array<string>;
        shortMonths: Array<string>;
        shortQuarters: Array<string>;
        shortWeekdays: Array<string>;
        standaloneMonths: Array<string>;
        standaloneNarrowMonths: Array<string>;
        standaloneNarrowWeekdays: Array<string>;
        standaloneShortMonths: Array<string>;
        standaloneShortWeekdays: Array<string>;
        standaloneWeekdays: Array<string>;
        timeFormats: string;
        weekdays: Array<string>;
        weekendRange: Array<number>;
    }
    interface Locale {
        dateTimeLocale: anychart.format.DateTimeLocale;
        messages: {[prop: string]: string};
        numberLocale: anychart.format.NumberLocale;
    }
    interface Context {
        getData(fieldPath: any): any;
        getData(...var_args: (any)[]): any;
        getMeta(name: string): any;
        getStat(key: string): any;
    }
}

declare namespace anychart.gauges {
    function circular(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.CircularGauge;
    function led(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
    function linear(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
    function tank(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
    function thermometer(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: anychart.enums.TextParsingMode | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
}

declare namespace anychart.graphics {
    function circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
    function clip(leftorRect?: number | Array<number> | anychart.graphics.math.Rect | Object, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
    function create(container?: Element | string, width?: string | number, height?: string | number): anychart.graphics.vector.Stage;
    function ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
    function hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType, color?: string, thickness?: number, size?: number): anychart.graphics.vector.HatchFill;
    function image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
    function layer(): anychart.graphics.vector.Layer;
    function path(): anychart.graphics.vector.Path;
    function patternFill(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
    function rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
    function server(address?: string): string;
    function text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
    function type(): anychart.graphics.StageType;
    function updateReferences(): void;
    function useAbsoluteReferences(value?: boolean): boolean;
    enum StageType {
        SVG,
        VML
    }
}

declare namespace anychart.graphics.events {
    function listen(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capture?: boolean, handler?: Object): Object;
    function listenOnce(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capture?: boolean, handler?: Object): Object;
    function removeAll(target: anychart.graphics.vector.Element, type?: string): number;
    function unlisten(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capture?: boolean, handler?: Object): boolean;
    function unlistenByKey(key: Object): boolean;
    enum EventType {
        CLICK,
        CONTEXTMENU,
        DBLCLICK,
        DRAG,
        DRAG_BEFORE,
        DRAG_EARLY_CANCEL,
        DRAG_END,
        DRAG_START,
        MOUSEDOWN,
        MOUSEMOVE,
        MOUSEOUT,
        MOUSEOVER,
        MOUSEUP,
        TAP,
        TOUCHCANCEL,
        TOUCHEND,
        TOUCHMOVE,
        TOUCHSTART
    }
    interface BrowserEvent {
        preventDefault(): void;
        stopPropagation(): void;
        stopWrapperPropagation(): void;
    }
}

declare namespace anychart.graphics.math {
    interface Rect {
        getBottom(): number;
        getHeight(): number;
        getLeft(): number;
        getRight(): number;
        getTop(): number;
        getWidth(): number;
    }
}

declare namespace anychart.graphics.vector {
    function normalizeFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Fill;
    function normalizeHatchFill(patternFillOrType?: anychart.graphics.vector.HatchFill | anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill.HatchFillType | string | Object, color?: string, thickness?: string | number, size?: string | number): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill;
    function normalizeStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Stroke;
    interface GradientKey {
        color: string;
        offset: number;
        opacity: number;
    }
    interface SolidFill {
        color: string;
        opacity: number;
    }
    interface LinearGradientFill {
        angle: number;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        mode: boolean | anychart.graphics.math.Rect;
        opacity: number;
    }
    interface RadialGradientFill {
        cx: number;
        cy: number;
        fx: number;
        fy: number;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        mode: anychart.graphics.math.Rect;
        opacity: number;
    }
    interface ImageFill {
        mode: anychart.graphics.vector.ImageFillMode;
        src: string;
    }
    type ColoredFill = string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill;
    type Fill = string | anychart.graphics.vector.ImageFill | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | anychart.graphics.vector.PatternFill;
    interface SolidStroke {
        color: string;
        dash: string;
        lineCap: string;
        lineJoin: string;
        opacity: number;
        thickness: number;
    }
    interface LinearGradientStroke {
        angle: number;
        dash: string;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        lineCap: string;
        lineJoin: string;
        mode: boolean | anychart.graphics.math.Rect;
        opacity: number;
        thickness: number;
    }
    interface RadialGradientStroke {
        cx: number;
        cy: number;
        dash: string;
        fx: number;
        fy: number;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        lineCap: string;
        lineJoin: string;
        mode: anychart.graphics.math.Rect;
        opacity: number;
        thickness: number;
    }
    type Stroke = string | anychart.graphics.vector.SolidStroke | anychart.graphics.vector.LinearGradientStroke | anychart.graphics.vector.RadialGradientStroke;
    type AnyColor = anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke | anychart.graphics.vector.PatternFill;
    interface TextStyle {
        color: string;
        decoration: anychart.graphics.vector.Text.Decoration | string;
        direction: anychart.graphics.vector.Text.Direction | string;
        fontFamily: string;
        fontSize: string | number;
        fontStyle: anychart.graphics.vector.Text.FontStyle | string;
        fontVariant: anychart.graphics.vector.Text.FontVariant | string;
        fontWeight: number | string;
        hAlign: anychart.graphics.vector.Text.HAlign | string;
        height: number | string;
        letterSpacing: string;
        lineHeight: string | number;
        opacity: number;
        selectable: boolean;
        textIndent: number;
        textOverflow: anychart.graphics.vector.Text.TextOverflow;
        vAlign: anychart.graphics.vector.Text.VAlign | string;
        width: number | string;
        wordBreak: string;
        wordWrap: string;
    }
    interface TextSegmentStyle {
        color: string;
        decoration: string;
        fontFamily: string;
        fontSize: string | number;
        fontStyle: string;
        fontVariant: string;
        fontWeight: number | string;
        letterSpacing: string;
        opacity: number;
    }
    enum Anchor {
        AUTO,
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Cursor {
        CROSSHAIR,
        DEFAULT,
        EW_RESIZE,
        E_RESIZE,
        HELP,
        MOVE,
        NESW_RESIZE,
        NE_RESIZE,
        NS_RESIZE,
        NWSE_RESIZE,
        NW_RESIZE,
        N_RESIZE,
        POINTER,
        SE_RESIZE,
        SW_RESIZE,
        S_RESIZE,
        TEXT,
        WAIT,
        W_RESIZE
    }
    enum StrokeLineJoin {
        BEVEL,
        MITER,
        ROUND
    }
    enum StrokeLineCap {
        BUTT,
        ROUND,
        SQUARE
    }
    enum ImageFillMode {
        FIT,
        FIT_MAX,
        STRETCH,
        TILE
    }
    enum PaperSize {
        A0,
        A1,
        A2,
        A3,
        A4,
        A5,
        A6,
        US_LETTER
    }
    interface LinearGradient {
        dispose(): void;
    }
    interface Shape extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Stage {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Stage;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Stage;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Stage;
        asyncMode(): boolean;
        asyncMode(value?: boolean): anychart.graphics.vector.Stage;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect): anychart.graphics.vector.Stage;
        container(): Element;
        container(value?: Element): anychart.graphics.vector.Stage;
        createClip(rect?: Array<number> | anychart.graphics.math.Rect | Object): anychart.graphics.vector.Clip;
        createClip(left?: number, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
        credits(): anychart.core.ui.StageCredits;
        credits(value?: Object | boolean): anychart.graphics.vector.Stage;
        cross(): void;
        data(): Object;
        data(value?: Object): anychart.graphics.vector.Stage;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Stage;
        diagonalCross(): void;
        diamond(): void;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Stage;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getContainerElement(): Element;
        getDomWrapper(): Element;
        getJpgBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPngBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number): void;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getSvgBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getTransformationMatrix(): Array<number>;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType, color?: string, thickness?: number, size?: number): anychart.graphics.vector.HatchFill;
        height(): number;
        height(value?: string | number): anychart.graphics.vector.Stage;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Stage;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        isRendering(): boolean;
        isSuspended(): boolean;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string | anychart.graphics.vector.Stage.EventType, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string | anychart.graphics.vector.Stage.EventType, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxResizeDelay(): number;
        maxResizeDelay(value?: number): anychart.graphics.vector.Stage;
        numChildren(): number;
        parent(): anychart.graphics.vector.Stage;
        path(): anychart.graphics.vector.Path;
        pattern(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
        pie(): void;
        print(paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Stage;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        resize(width: number | string, height: number | string): void;
        resume(force?: boolean): anychart.graphics.vector.Stage;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        setPosition(x: number, y: number): anychart.graphics.vector.Stage;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Stage;
        shareAsJpg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        suspend(): anychart.graphics.vector.Stage;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Stage;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Stage;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Stage;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        translate(tx: number, ty: number): anychart.graphics.vector.Stage;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        unlisten(type: string | anychart.graphics.vector.Stage.EventType, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Stage;
        width(): number;
        width(value?: string | number): anychart.graphics.vector.Stage;
    }
    namespace Stage {
    enum EventType {
        RENDER_FINISH,
        RENDER_START,
        STAGE_RENDERED,
        STAGE_RESIZE
    }
    }
    interface PatternFill extends anychart.graphics.vector.Layer {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void)): anychart.graphics.vector.Layer;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface RadialGradient {
        dispose(): void;
    }
    interface Circle extends anychart.graphics.vector.Ellipse {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        center(): anychart.math.Coordinate;
        center(value?: anychart.math.Coordinate): anychart.graphics.vector.Ellipse;
        centerX(): number;
        centerX(value?: number): anychart.graphics.vector.Ellipse;
        centerY(): number;
        centerY(value?: number): anychart.graphics.vector.Ellipse;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        radius(): number;
        radius(value?: number): anychart.graphics.vector.Circle;
        radiusX(): number;
        radiusX(value?: number): anychart.graphics.vector.Ellipse;
        radiusY(): number;
        radiusY(value?: number): anychart.graphics.vector.Ellipse;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRadius(rx: number, ry: number): anychart.graphics.vector.Ellipse;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface UnmanagedLayer extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        content(): Element | string;
        content(value?: string | Element): anychart.graphics.vector.UnmanagedLayer;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Rect extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        cut(radiusAll: string | number): anychart.graphics.vector.Rect;
        cut(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        round(radiusAll: string | number): anychart.graphics.vector.Rect;
        round(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        roundInner(radiusAll: string | number): anychart.graphics.vector.Rect;
        roundInner(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setBounds(value: anychart.graphics.math.Rect): anychart.graphics.vector.Rect;
        setHeight(value: number): anychart.graphics.vector.Rect;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        setWidth(value: number): anychart.graphics.vector.Rect;
        setX(value: number): anychart.graphics.vector.Rect;
        setY(value: number): anychart.graphics.vector.Rect;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Layer extends anychart.graphics.vector.Element {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void)): anychart.graphics.vector.Layer;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Path {
        arcTo(rx: number, ry: number, fromAngle: number, extent: number): anychart.graphics.vector.Path;
        arcToAsCurves(rx: number, ry: number, fromAngle: number, extent: number): anychart.graphics.vector.Path;
        arcToByEndPoint(x: number, y: number, rx: number, ry: number, largeArc: boolean, clockwiseArc: boolean): anychart.graphics.vector.Path;
        circularArc(cx: number, cy: number, rx: number, ry: number, fromAngle: number, sweep: number, lineTo?: boolean): anychart.graphics.vector.Path;
        clear(): anychart.graphics.vector.Path;
        close(): anychart.graphics.vector.Path;
        curveTo(control1X: number, control1Y: number, control2X: number, control2Y: number, endX: number, endY: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        getCurrentPoint(): anychart.math.Coordinate;
        getLength(): number;
        lineTo(x: number, y: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        moveTo(x: number, y: number): anychart.graphics.vector.Path;
        quadraticCurveTo(controlX: number, controlY: number, endX: number, endY: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
    }
    interface Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Image extends anychart.graphics.vector.Element {
        align(): anychart.graphics.vector.Image.Align;
        align(value?: anychart.graphics.vector.Image.Align): anychart.graphics.vector.Image;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fittingMode(): anychart.graphics.vector.Image.Fitting;
        fittingMode(value?: anychart.graphics.vector.Image.Fitting | string): anychart.graphics.vector.Image;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        height(): number;
        height(value?: number): anychart.graphics.vector.Image;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        src(): string;
        src(value?: string): anychart.graphics.vector.Image;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        width(): number;
        width(value?: number): anychart.graphics.vector.Image;
        x(): number;
        x(value?: number): anychart.graphics.vector.Image;
        y(): number;
        y(value?: number): anychart.graphics.vector.Image;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    namespace Image {
    enum Fitting {
        MEET,
        SLICE
    }
    enum Align {
        NONE,
        X_MAX_Y_MAX,
        X_MAX_Y_MID,
        X_MAX_Y_MIN,
        X_MID_Y_MAX,
        X_MID_Y_MID,
        X_MID_Y_MIN,
        X_MIN_Y_MAX,
        X_MIN_Y_MID,
        X_MIN_Y_MIN
    }
    }
    interface HatchFill extends anychart.graphics.vector.PatternFill {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void)): anychart.graphics.vector.Layer;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    namespace HatchFill {
    enum HatchFillType {
        BACKWARD_DIAGONAL,
        CHECKER_BOARD,
        CONFETTI,
        DASHED_BACKWARD_DIAGONAL,
        DASHED_FORWARD_DIAGONAL,
        DASHED_HORIZONTAL,
        DASHED_VERTICAL,
        DIAGONAL_BRICK,
        DIAGONAL_CROSS,
        DIVOT,
        FORWARD_DIAGONAL,
        GRID,
        HORIZONTAL,
        HORIZONTAL_BRICK,
        PERCENT_05,
        PERCENT_10,
        PERCENT_20,
        PERCENT_25,
        PERCENT_30,
        PERCENT_40,
        PERCENT_50,
        PERCENT_60,
        PERCENT_70,
        PERCENT_75,
        PERCENT_80,
        PERCENT_90,
        PLAID,
        SOLID_DIAMOND,
        VERTICAL,
        VERTICAL_BRICK,
        WEAVE,
        ZIG_ZAG
    }
    }
    interface Text extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        color(): string;
        color(value?: string): anychart.graphics.vector.Text;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        decoration(): string;
        decoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.graphics.vector.Text;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        direction(): string;
        direction(value?: anychart.graphics.vector.Text.Direction | string): anychart.graphics.vector.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fontFamily(): string;
        fontFamily(value?: string): anychart.graphics.vector.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.graphics.vector.Text;
        fontStyle(): string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.graphics.vector.Text;
        fontVariant(): string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.graphics.vector.Text;
        fontWeight(): string;
        fontWeight(value?: string | number): anychart.graphics.vector.Text;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hAlign(): string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.graphics.vector.Text;
        hasParent(): boolean;
        height(): number | string;
        height(value?: number | string): anychart.graphics.vector.Text;
        htmlText(): string;
        htmlText(value?: string): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        letterSpacing(): string;
        letterSpacing(value?: string | number): anychart.graphics.vector.Text;
        lineHeight(): string;
        lineHeight(value?: string | number): anychart.graphics.vector.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        opacity(): number;
        opacity(value?: number): anychart.graphics.vector.Text;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        path(value?: anychart.graphics.vector.Path): anychart.graphics.vector.Text;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        selectable(): boolean;
        selectable(value?: boolean): anychart.graphics.vector.Text;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        style(): anychart.graphics.vector.TextStyle;
        style(value?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        text(): string;
        text(value?: string): anychart.graphics.vector.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.graphics.vector.Text;
        textOverflow(): string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vAlign(): string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.graphics.vector.Text;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        width(): number | string;
        width(value?: number | string): anychart.graphics.vector.Text;
        wordBreak(): string | anychart.graphics.vector.Text.WordBreak;
        wordBreak(value?: string | anychart.graphics.vector.Text.WordBreak): anychart.graphics.vector.Text;
        wordWrap(): string | anychart.graphics.vector.Text.WordWrap;
        wordWrap(value?: string | anychart.graphics.vector.Text.WordWrap): string | anychart.graphics.vector.Text;
        x(): number;
        x(value?: number): anychart.graphics.vector.Text;
        y(): number;
        y(value?: number): anychart.graphics.vector.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    namespace Text {
    enum WordBreak {
        BREAK_ALL,
        KEEP_ALL,
        NORMAL
    }
    enum WordWrap {
        BREAK_WORD,
        NORMAL
    }
    enum TextOverflow {
        CLIP,
        ELLIPSIS
    }
    enum HAlign {
        CENTER,
        END,
        LEFT,
        RIGHT,
        START
    }
    enum VAlign {
        BOTTOM,
        MIDDLE,
        TOP
    }
    enum Decoration {
        BLINK,
        LINE_THROUGH,
        NONE,
        OVERLINE,
        UNDERLINE
    }
    enum FontVariant {
        NORMAL,
        SMALL_CAP
    }
    enum FontStyle {
        ITALIC,
        NORMAL,
        OBLIQUE
    }
    enum Direction {
        LTR,
        RTL
    }
    }
    interface Ellipse extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        center(): anychart.math.Coordinate;
        center(value?: anychart.math.Coordinate): anychart.graphics.vector.Ellipse;
        centerX(): number;
        centerX(value?: number): anychart.graphics.vector.Ellipse;
        centerY(): number;
        centerY(value?: number): anychart.graphics.vector.Ellipse;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        radiusX(): number;
        radiusX(value?: number): anychart.graphics.vector.Ellipse;
        radiusY(): number;
        radiusY(value?: number): anychart.graphics.vector.Ellipse;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRadius(rx: number, ry: number): anychart.graphics.vector.Ellipse;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Clip {
        dispose(): void;
        shape(): anychart.graphics.vector.Shape;
        shape(shape?: Array<number> | anychart.graphics.vector.Shape | anychart.graphics.math.Rect | Object): anychart.graphics.vector.Clip;
        shape(left?: number, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
    }
}

declare namespace anychart.graphics.vector.primitives {
    function cross(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function diagonalCross(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function diamond(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function donut(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, cx: number, cy: number, outerR: number, innerR: number, start: number, sweep: number): anychart.graphics.vector.Path;
    function hLine(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function pie(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, cx: number, cy: number, r: number, start: number, sweep: number): anychart.graphics.vector.Path;
    function roundedInnerRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function roundedRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function star(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number, innerRadius: number, numberOfSpikes: number, startDegrees?: number, curvature?: number): anychart.graphics.vector.Path;
    function star10(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star4(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star5(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star6(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star7(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleDown(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleLeft(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleRight(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleUp(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function truncatedRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function vLine(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
}

declare namespace anychart.graphics.vector.vml {
    interface Text extends anychart.graphics.vector.Text {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        color(): string;
        color(value?: string): anychart.graphics.vector.Text;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        decoration(): string;
        decoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.graphics.vector.Text;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        direction(): string;
        direction(value?: anychart.graphics.vector.Text.Direction | string): anychart.graphics.vector.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fontFamily(): string;
        fontFamily(value?: string): anychart.graphics.vector.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.graphics.vector.Text;
        fontStyle(): string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.graphics.vector.Text;
        fontVariant(): string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.graphics.vector.Text;
        fontWeight(): string;
        fontWeight(value?: string | number): anychart.graphics.vector.Text;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hAlign(): string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.graphics.vector.Text;
        hasParent(): boolean;
        height(): number | string;
        height(value?: number | string): anychart.graphics.vector.Text;
        htmlText(): string;
        htmlText(value?: string): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        letterSpacing(): string;
        letterSpacing(value?: string | number): anychart.graphics.vector.Text;
        lineHeight(): string;
        lineHeight(value?: string | number): anychart.graphics.vector.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        opacity(): number;
        opacity(value?: number): anychart.graphics.vector.Text;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        selectable(): boolean;
        selectable(value?: boolean): anychart.graphics.vector.Text;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        style(): anychart.graphics.vector.TextStyle;
        style(value?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        text(): string;
        text(value?: string): anychart.graphics.vector.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.graphics.vector.Text;
        textOverflow(): string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vAlign(): string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.graphics.vector.Text;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        width(): number | string;
        width(value?: number | string): anychart.graphics.vector.Text;
        wordBreak(): string | anychart.graphics.vector.Text.WordBreak;
        wordBreak(value?: string | anychart.graphics.vector.Text.WordBreak): anychart.graphics.vector.Text;
        wordWrap(): string | anychart.graphics.vector.Text.WordWrap;
        wordWrap(value?: string | anychart.graphics.vector.Text.WordWrap): string | anychart.graphics.vector.Text;
        x(): number;
        x(value?: number): anychart.graphics.vector.Text;
        y(): number;
        y(value?: number): anychart.graphics.vector.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
}

declare namespace anychart.math {
    function cycledQueue(lengthLimit?: number): anychart.math.CycledQueue;
    function rect(x: number, y: number, w: number, h: number): anychart.math.Rect;
    interface CoordinateObject {
        x: string | number;
        y: string | number;
    }
    interface Coordinate {
        XYCoordinates: Array<number> | Object | anychart.math.CoordinateObject;
    }
    interface CycledQueue {
        clear(newLengthLimit?: number): void;
        dequeue(): any;
        enqueue(item: any): any;
        get(index: number): any;
        getLength(): number;
    }
    interface Rect {

    }
}

declare namespace anychart.math.adl {
    function calculate(context: anychart.math.adl.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.adl.Context): void;
    function createComputer(mapping: anychart.data.TableMapping): anychart.data.TableComputer;
    function initContext(): anychart.math.adl.Context;
    function startFunction(context: anychart.math.adl.Context): void;
    interface Context {
        closeQueue: anychart.math.CycledQueue;
        dispose: number;
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        period: number;
        prevResult: number;
        volumeQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.ama {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.ama.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, fastPeriod?: number, slowPeriod?: number): anychart.data.TableComputer;
    function initContext(period?: number, fastPeriod?: number, slowPeriod?: number): anychart.math.ama.Context;
    function startFunction(context: anychart.math.ama.Context): void;
    interface Context {
        dispose: (() => void);
        fastPeriod: number;
        period: number;
        prevNoise: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
        slowPeriod: number;
    }
}

declare namespace anychart.math.aroon {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.aroon.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.aroon.Context;
    function startFunction(context: anychart.math.aroon.Context): void;
    interface Context {
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        period: number;
    }
}

declare namespace anychart.math.atr {
    function calculate(context: anychart.math.atr.Context, close: number, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.atr.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.atr.Context;
    function startFunction(context: anychart.math.atr.Context): void;
    interface Context {
        dequeuedValue: number;
        dispose: (() => void);
        period: number;
        prevClose: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.bbands {
    function calculate(context: anychart.math.bbands.Context, value: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.bbands.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, deviation?: number): anychart.data.TableComputer;
    function initContext(period?: number, deviation?: number): anychart.math.bbands.Context;
    function startFunction(context: anychart.math.bbands.Context): void;
    interface Context {
        dequeuedValue: number;
        deviation: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        period: number;
        prevDeviation: number;
        prevResult: number;
    }
}

declare namespace anychart.math.bbandsB {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.bbandsB.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, deviation?: number): anychart.data.TableComputer;
    function initContext(period?: number, deviation?: number): anychart.math.bbandsB.Context;
    function startFunction(context: anychart.math.bbandsB.Context): void;
    interface Context {
        deviation: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        period: number;
        prevDeviation: number;
        prevResult: number;
    }
}

declare namespace anychart.math.bbandsWidth {
    function calculate(context: anychart.math.bbandsWidth.Context, value: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.bbandsWidth.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, deviation?: number): anychart.data.TableComputer;
    function initContext(period?: number, deviation?: number): anychart.math.bbandsWidth.Context;
    function startFunction(context: anychart.math.bbandsWidth.Context): void;
    interface Context {
        dequeuedValue: number;
        deviation: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        period: number;
        prevDeviation: number;
        prevResult: number;
    }
}

declare namespace anychart.math.cci {
    function calculate(context: anychart.math.cci.Context, close: number, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.cci.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.cci.Context;
    function startFunction(context: anychart.math.cci.Context): void;
    interface Context {
        dequeuedValue: number;
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.cho {
    function calculate(context: anychart.math.cho.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.cho.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string): anychart.data.TableComputer;
    function initContext(fastPeriod?: number, slowPeriod?: number, maType?: string): anychart.math.cho.Context;
    function startFunction(context: anychart.math.cho.Context): void;
    interface Context {
        adlContext: anychart.math.adl.Context;
        dispose: (() => void);
        fastMAContext: anychart.math.ema.Context | anychart.math.sma.Context;
        maCalculate: (() => void);
        maType: anychart.enums.MovingAverageType;
        slowMAContext: anychart.math.ema.Context | anychart.math.sma.Context;
    }
}

declare namespace anychart.math.cmf {
    function calculate(context: anychart.math.cmf.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.cmf.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.cmf.Context;
    function startFunction(context: anychart.math.cmf.Context): void;
    interface Context {
        dispose: (() => void);
        mfvQueue: anychart.math.CycledQueue;
        period: number;
        prevMFVSum: number;
        prevVolumeSum: number;
        volumeQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.dmi {
    function calculate(context: anychart.math.dmi.Context, close: number, high: number, low: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.dmi.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, adxPeriod?: number, useWildersSmoothing?: boolean): anychart.data.TableComputer;
    function initContext(period?: number, adxPeriod?: number, useWildersSmoothing?: boolean): anychart.math.dmi.Context;
    function startFunction(context: anychart.math.dmi.Context): void;
    interface Context {
        adxAlpha: number;
        adxPeriod: number;
        adxQueue: anychart.math.CycledQueue;
        adxValue: number;
        alpha: number;
        closeQueue: anychart.math.CycledQueue;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        ndiSumValue: number;
        ndiValue: number;
        pdiSumValue: number;
        pdiValue: number;
        period: number;
        trSumValue: number;
        useWildersSmoothing: boolean;
    }
}

declare namespace anychart.math.ema {
    function calculate(context: anychart.math.ema.Context, value: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.ema.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.ema.Context;
    function startFunction(context: anychart.math.ema.Context): void;
    interface Context {
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.kdj {
    function calculate(context: anychart.math.kdj.Context, close: number, high: number, low: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.kdj.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType, kMultiplier?: number, dMultiplier?: number): anychart.data.TableComputer;
    function initContext(kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType, kMultiplier?: number, dMultiplier?: number): anychart.math.kdj.Context;
    function startFunction(context: anychart.math.kdj.Context): void;
    interface Context {
        dMACalculate: (() => void);
        dMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        dMAType: anychart.enums.MovingAverageType;
        dMultiplier: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        kMACalculate: (() => void);
        kMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        kMAType: anychart.enums.MovingAverageType;
        kMultiplier: number;
        kPeriod: number;
        lowQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.macd {
    function calculate(context: anychart.math.macd.Context, value: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.macd.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number): anychart.data.TableComputer;
    function initContext(fastPeriod?: number, slowPeriod?: number, signalPeriod?: number): anychart.math.macd.Context;
    function startFunction(context: anychart.math.macd.Context): void;
    interface Context {
        dispose: (() => void);
        fastPeriod: number;
        fastQueue: anychart.math.CycledQueue;
        fastResult: number;
        signalPeriod: number;
        signalQueue: anychart.math.CycledQueue;
        signalResult: number;
        slowPeriod: number;
        slowQueue: anychart.math.CycledQueue;
        slowResult: number;
    }
}

declare namespace anychart.math.mma {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.mma.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.mma.Context;
    function startFunction(context: anychart.math.mma.Context): void;
    interface Context {
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.roc {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.roc.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.roc.Context;
    function startFunction(context: anychart.math.roc.Context): void;
    interface Context {
        dispose: (() => void);
        period: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.rsi {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.rsi.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.rsi.Context;
    function startFunction(context: anychart.math.rsi.Context): void;
    interface Context {
        dispose: (() => void);
        downwardChange: number;
        period: number;
        queue: anychart.math.CycledQueue;
        upwardChange: number;
    }
}

declare namespace anychart.math.sma {
    function calculate(context: anychart.math.sma.Context, value: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.sma.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.sma.Context;
    function startFunction(context: anychart.math.sma.Context): void;
    interface Context {
        dequeuedValue: number;
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.stochastic {
    function calculate(context: Object, closeValue: number, highValue: number, lowValue: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.stochastic.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType): anychart.data.TableComputer;
    function initContext(kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: anychart.enums.MovingAverageType, dMAType?: anychart.enums.MovingAverageType): anychart.math.stochastic.Context;
    function startFunction(context: anychart.math.stochastic.Context): void;
    interface Context {
        dMACalculate: (() => void);
        dMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        dMAType: anychart.enums.MovingAverageType;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        kMACalculate: (() => void);
        kMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        kMAType: anychart.enums.MovingAverageType;
        kPeriod: number;
        lowQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.palettes {
    const blue: Array<string>;
    const coffee: Array<string>;
    const defaultPalette: Array<string>;
    const earth: Array<string>;
    const glamour: Array<string>;
    const monochrome: Array<string>;
    const morning: Array<string>;
    const pastel: Array<string>;
    const provence: Array<string>;
    const sea: Array<string>;
    const turquoise: Array<string>;
    const v6: Array<string>;
    const wines: Array<string>;
    function distinctColors(): anychart.palettes.DistinctColors;
    function hatchFills(): anychart.palettes.HatchFills;
    function markers(): anychart.palettes.Markers;
    function rangeColors(): anychart.palettes.RangeColors;
    interface Markers extends anychart.core.Base {
        itemAt(index: number): anychart.enums.MarkerType | anychart.enums.BulletMarkerType;
        itemAt(index: number, type?: string): anychart.palettes.Markers;
        items(): Array<anychart.graphics.vector.Fill>;
        items(value?: Array<string> | string, ...var_args: (string)[]): anychart.palettes.Markers;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColors extends anychart.core.Base {
        count(): number;
        count(value?: number): anychart.palettes.RangeColors;
        itemAt(index: number): anychart.graphics.vector.SolidFill;
        itemAt(index: number, color?: anychart.graphics.vector.SolidFill): anychart.palettes.RangeColors;
        items(): Array<anychart.graphics.vector.SolidFill>;
        items(value?: Array<anychart.graphics.vector.SolidFill> | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<anychart.graphics.vector.GradientKey> | Array<string> | anychart.graphics.vector.SolidFill | string, ...var_args: (anychart.graphics.vector.SolidFill | string)[]): anychart.palettes.RangeColors;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DistinctColors extends anychart.core.Base {
        itemAt(index: number): anychart.graphics.vector.Fill;
        itemAt(index: number, color?: anychart.graphics.vector.Fill): anychart.palettes.DistinctColors;
        items(): Array<anychart.graphics.vector.Fill>;
        items(value?: Array<anychart.graphics.vector.Fill> | anychart.graphics.vector.Fill, ...var_args: (anychart.graphics.vector.Fill)[]): anychart.palettes.DistinctColors;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface HatchFills extends anychart.core.Base {
        itemAt(index: number): anychart.graphics.vector.HatchFill | anychart.graphics.vector.PatternFill;
        itemAt(index: number, type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.palettes.HatchFills;
        itemAt(index: number, patternFill?: anychart.graphics.vector.PatternFill): anychart.palettes.HatchFills;
        itemAt(index: number, instance?: anychart.graphics.vector.HatchFill): anychart.palettes.HatchFills;
        itemAt(index: number, state?: boolean): anychart.palettes.HatchFills;
        items(): Array<(anychart.graphics.vector.HatchFill|anychart.graphics.vector.HatchFill.HatchFillType|anychart.graphics.vector.PatternFill)>;
        items(value?: Array<(anychart.graphics.vector.HatchFill|anychart.graphics.vector.HatchFill.HatchFillType|anychart.graphics.vector.PatternFill)>, ...var_args: (anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | anychart.graphics.vector.PatternFill)[]): anychart.palettes.HatchFills;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.scales {
    function calendar(parentCalendar?: anychart.scales.Calendar): anychart.scales.Calendar;
    function dateTime(): anychart.scales.DateTime;
    function linear(): anychart.scales.Linear;
    function linearColor(...var_args: (string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<(string|anychart.graphics.vector.SolidFill|anychart.graphics.vector.LinearGradientFill|anychart.graphics.vector.RadialGradientFill)>)[]): anychart.scales.LinearColor;
    function log(): anychart.scales.Logarithmic;
    function ordinal(): anychart.scales.Ordinal;
    function ordinalColor(value?: Array<Object>): anychart.scales.OrdinalColor;
    interface DateTimeTicks extends anychart.core.Base {
        count(): number;
        count(value?: number): anychart.scales.DateTimeTicks;
        get(): Array<any>;
        interval(): string;
        interval(isodate?: string): anychart.scales.DateTimeTicks;
        interval(unit?: anychart.enums.Interval, count?: number): anychart.scales.DateTimeTicks;
        interval(years?: number, months?: number, days?: number, hours?: number, minutes?: number, seconds?: number): anychart.scales.DateTimeTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        set(ticks: Array<any>): anychart.scales.DateTimeTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Calendar extends anychart.core.Base {
        availabilities(): Array<anychart.scales.Calendar.Availability>;
        availabilities(value?: Array<anychart.scales.Calendar.Availability>): anychart.scales.Calendar;
        getWorkingSchedule(startDate: number, endDate: number, unit?: anychart.enums.Interval | string, count?: number): Array<anychart.scales.Calendar.ScheduleItem>;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        timezoneOffset(): Array<number>;
        timezoneOffset(var_value: number): anychart.scales.Calendar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        weekendRange(): Array<number>;
        weekendRange(var_value: Array<number>): anychart.scales.Calendar;
    }
    namespace Calendar {
    interface Availability {
        each: anychart.enums.AvailabilityPeriod;
        ends: Date | number | string;
        from: Date | number | string;
        isWorking: boolean;
        on: Date | number | string;
        starts: Date | number | string;
        to: Date | number | string;
    }
    interface ScheduleItem {
        end: number;
        start: number;
        workingTime: Array<Array<number>>;
    }
    }
    interface Linear extends anychart.scales.ScatterBase {
        compareWith(): anychart.enums.ScaleCompareWithMode | number;
        compareWith(value?: string | anychart.enums.ScaleCompareWithMode | number | Date): anychart.scales.Linear;
        comparisonMode(): anychart.enums.ScaleComparisonMode;
        comparisonMode(value?: string | anychart.enums.ScaleComparisonMode): anychart.scales.Linear;
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.Linear;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.Linear;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.Linear;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.Linear;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.Linear;
        stackDirection(): anychart.enums.ScaleStackDirection;
        stackDirection(value?: anychart.enums.ScaleStackDirection | string): anychart.scales.Linear;
        stackMode(): anychart.enums.ScaleStackMode;
        stackMode(value?: anychart.enums.ScaleStackMode | string): anychart.scales.Linear;
        startAutoCalc(): anychart.scales.Base;
        stickToZero(): boolean;
        stickToZero(value?: boolean): anychart.scales.Linear;
        ticks(): anychart.scales.ScatterTicks;
        ticks(value?: Object | Array<any>): anychart.scales.Linear;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Geo extends anychart.core.Base {
        extendDataRange(x: number, y: number, ...var_args: (any)[]): anychart.scales.Geo;
        gap(): number;
        gap(value?: number): anychart.scales.Geo;
        getType(): string;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxTicksCount(): number;
        maxTicksCount(value?: number): anychart.scales.Geo;
        maximumX(): number;
        maximumX(value?: number): anychart.scales.Geo;
        maximumY(): number;
        maximumY(value?: number): anychart.scales.Geo;
        minimumX(): number;
        minimumX(value?: number): anychart.scales.Geo;
        minimumY(): number;
        minimumY(value?: number): anychart.scales.Geo;
        precision(): Array<number>;
        precision(precision?: Array<number>): anychart.scales.Geo;
        precision(xPrecision?: number, yPrecision?: number): anychart.scales.Geo;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xMinorTicks(): anychart.scales.GeoTicks;
        xMinorTicks(value?: Object | Array<any>): anychart.scales.Geo;
        xTicks(): anychart.scales.GeoTicks;
        xTicks(value?: Object | Array<any>): anychart.scales.Geo;
        yMinorTicks(): anychart.scales.GeoTicks;
        yMinorTicks(value?: Object | Array<any>): anychart.scales.Geo;
        yTicks(): anychart.scales.GeoTicks;
        yTicks(value?: Object | Array<any>): anychart.scales.Geo;
    }
    interface ScatterTicks extends anychart.core.Base {
        base(): number;
        base(value?: number): anychart.scales.ScatterTicks;
        count(): number;
        count(value?: number): anychart.scales.ScatterTicks;
        count(minimumCount?: number, maximumCount?: number): anychart.scales.ScatterTicks;
        get(): Array<any>;
        interval(): number;
        interval(value?: number): anychart.scales.ScatterTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mode(): anychart.enums.ScatterTicksMode;
        mode(value?: anychart.enums.ScatterTicksMode | string): anychart.scales.ScatterTicks;
        removeAllListeners(type?: string): number;
        set(ticks: Array<any>): anychart.scales.ScatterTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.Base {
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Ordinal extends anychart.scales.Base {
        extendDataRange(...var_args: (any)[]): anychart.scales.Ordinal;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        names(): Array<any>;
        names(value?: Array<any> | string): anychart.scales.Ordinal;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.OrdinalTicks;
        ticks(value?: Object | Array<any>): anychart.scales.Ordinal;
        transform(value: any, subRangeRatio?: number): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        values(): Array<(number|string)>;
        values(values?: Array<any> | any, ...var_args: (any)[]): anychart.scales.Ordinal;
        weights(): Array<number>;
        weights(value?: Array<number>): anychart.scales.Ordinal;
    }
    interface OrdinalColor extends anychart.scales.Base {
        colorToValue(value: string): number;
        colors(): Array<string>;
        colors(value?: Array<string>): anychart.scales.OrdinalColor;
        finishAutoCalc(silently?: boolean): boolean;
        getIndexByValue(value: number): number;
        getProcessedRanges(): Array<Object>;
        getRangeByValue(value: number): Object;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.OrdinalColor;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        names(): Array<any>;
        names(value?: Array<any> | string): anychart.scales.OrdinalColor;
        ranges(): Array<Object>;
        ranges(value?: Array<Object>): anychart.scales.OrdinalColor;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.OrdinalTicks;
        ticks(value?: Object | Array<any>): anychart.scales.OrdinalColor;
        transform(value: any, subRangeRatio?: number): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valueToColor(value: number): string;
    }
    interface StockScatterDateTime extends anychart.core.Base {
        getFullMaximum(): number;
        getFullMinimum(): number;
        getMaximum(): number;
        getMinimum(): number;
        inverseTransform(ratio: number): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        transform(value: number | string | Date): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DateTime extends anychart.scales.ScatterBase {
        extendDataRange(...var_args: (any)[]): anychart.scales.DateTime;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.DateTime;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.DateTime;
        minorTicks(): anychart.scales.DateTimeTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.DateTime;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.DateTime;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.DateTime;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.DateTimeTicks;
        ticks(value?: Object | Array<any>): anychart.scales.DateTime;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ScatterBase extends anychart.scales.Base {
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxTicksCount(): number;
        maxTicksCount(value?: number): anychart.scales.ScatterBase;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OrdinalTicks extends anychart.core.Base {
        get(): Array<any>;
        interval(): number;
        interval(value?: number): anychart.scales.OrdinalTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        names(): Array<any>;
        names(values?: Array<any>): anychart.scales.OrdinalTicks;
        removeAllListeners(type?: string): number;
        set(ticks: Array<any>): anychart.scales.OrdinalTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StockOrdinalDateTime extends anychart.scales.StockScatterDateTime {
        getFullMaximum(): number;
        getFullMinimum(): number;
        getMaximum(): number;
        getMinimum(): number;
        inverseTransform(ratio: number): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        transform(value: number | string | Date): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface LinearColor extends anychart.scales.ScatterBase {
        colorToValue(value: string): number;
        colors(): Array<Object>;
        colors(...var_args: (string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<(string|anychart.graphics.vector.SolidFill|anychart.graphics.vector.LinearGradientFill|anychart.graphics.vector.RadialGradientFill)>)[]): anychart.scales.LinearColor;
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.LinearColor;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.ScatterTicks;
        ticks(value?: Object | Array<any>): anychart.scales.LinearColor;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valueToColor(value: number): string;
    }
    interface Logarithmic extends anychart.scales.Linear {
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        logBase(): number;
        logBase(value?: number): anychart.scales.Logarithmic;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.Linear;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.Linear;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.Linear;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.Linear;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.Linear;
        stackDirection(): anychart.enums.ScaleStackDirection;
        stackDirection(value?: anychart.enums.ScaleStackDirection | string): anychart.scales.Linear;
        stackMode(): anychart.enums.ScaleStackMode;
        stackMode(value?: anychart.enums.ScaleStackMode | string): anychart.scales.Linear;
        startAutoCalc(): anychart.scales.Base;
        stickToZero(): boolean;
        stickToZero(value?: boolean): anychart.scales.Linear;
        ticks(): anychart.scales.ScatterTicks;
        ticks(value?: Object | Array<any>): anychart.scales.Linear;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface GanttDateTime extends anychart.core.Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.GanttDateTime;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.GanttDateTime;
        minimum(): number;
        minimum(value?: number): anychart.scales.GanttDateTime;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.GanttDateTime;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.GanttDateTime;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.GanttDateTime;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DateTimeWithCalendar extends anychart.scales.ScatterBase {
        calendar(): anychart.scales.Calendar;
        count(): number;
        count(value?: number): anychart.scales.DateTimeWithCalendar;
        dateToPix(date: number | Date): number;
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        getTicks(fromPix: number, toPix: number, unit?: anychart.enums.Interval | string, count?: number): Array<anychart.scales.DateTimeWithCalendar.Tick>;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.DateTime;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.DateTime;
        pixToDate(pix: number): number;
        removeAllListeners(type?: string): number;
        skipHolidays(): boolean;
        skipHolidays(value?: boolean): anychart.scales.DateTimeWithCalendar;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.DateTime;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.DateTime;
        startAutoCalc(): anychart.scales.Base;
        startDate(): number;
        transform(value: any): number;
        unit(): anychart.enums.Interval;
        unit(value?: anychart.enums.Interval | string): anychart.scales.DateTimeWithCalendar;
        unitPixSize(): number | string;
        unitPixSize(value?: number | string): anychart.scales.DateTimeWithCalendar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace DateTimeWithCalendar {
    interface Tick {
        end: number;
        holiday: boolean;
        start: number;
    }
    }
    interface GeoTicks extends anychart.core.Base {
        count(): number;
        count(value?: number): anychart.scales.GeoTicks;
        count(minimumCount?: number, maximumCount?: number): anychart.scales.GeoTicks;
        get(): Array<any>;
        interval(): number;
        interval(value?: number): anychart.scales.GeoTicks;
        set(ticks: Array<any>): anychart.scales.GeoTicks;
    }
}

declare namespace anychart.standalones {
    function background(): anychart.standalones.Background;
    function colorRange(): anychart.standalones.ColorRange;
    function dataGrid(): anychart.standalones.DataGrid;
    function label(): anychart.standalones.Label;
    function labelsFactory(): anychart.standalones.LabelsFactory;
    function legend(): anychart.standalones.Legend;
    function markersFactory(): anychart.standalones.MarkersFactory;
    function projectTimeline(): anychart.standalones.ProjectTimeline;
    function resourceList(data?: Array<Object>): anychart.standalones.ResourceList;
    function resourceTimeline(): anychart.standalones.ResourceTimeline;
    function scroller(): anychart.standalones.Scroller;
    function table(rowsCount?: number, colsCount?: number): anychart.standalones.Table;
    function title(): anychart.standalones.Title;
    interface ProjectTimeline extends anychart.core.ui.Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(): anychart.graphics.vector.Fill | string;
        baseFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baseFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseStroke(): anychart.graphics.vector.Stroke | string;
        baseStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        baselineAbove(): boolean;
        baselineAbove(value?: boolean): anychart.core.ui.Timeline;
        baselineFill(): anychart.graphics.vector.Fill | string;
        baselineFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baselineFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineStroke(): anychart.graphics.vector.Stroke | string;
        baselineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.Timeline;
        connectorFill(): anychart.graphics.vector.Fill | string;
        connectorFill(value?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        connectorPreviewStroke(): anychart.graphics.vector.Stroke | string;
        connectorPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        connectorStroke(): anychart.graphics.vector.Stroke | string;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        defaultRowHeight(): number;
        defaultRowHeight(value?: number): anychart.standalones.ProjectTimeline;
        editConnectorThumbFill(): anychart.graphics.vector.Fill | string;
        editConnectorThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbStroke(): anychart.graphics.vector.Stroke | string;
        editConnectorThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editIntervalThumbFill(): anychart.graphics.vector.Fill | string;
        editIntervalThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbStroke(): anychart.graphics.vector.Stroke | string;
        editIntervalThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editPreviewFill(): anychart.graphics.vector.Fill | string;
        editPreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editPreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewStroke(): anychart.graphics.vector.Stroke | string;
        editPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editProgressFill(): anychart.graphics.vector.Fill | string;
        editProgressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editProgressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressStroke(): anychart.graphics.vector.Stroke | string;
        editProgressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewDashStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editing(): boolean;
        editing(value?: boolean): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        milestoneFill(): anychart.graphics.vector.Fill | string;
        milestoneFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        milestoneFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneStroke(): anychart.graphics.vector.Stroke | string;
        milestoneStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        parentFill(): anychart.graphics.vector.Fill | string;
        parentFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        parentFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentStroke(): anychart.graphics.vector.Stroke | string;
        parentStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        progressFill(): anychart.graphics.vector.Fill | string;
        progressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        progressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressStroke(): anychart.graphics.vector.Stroke | string;
        progressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(): anychart.graphics.vector.Fill | string;
        selectedElementFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        selectedElementFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementStroke(): anychart.graphics.vector.Stroke | string;
        selectedElementStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
    }
    interface ResourceTimeline extends anychart.core.ui.Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(): anychart.graphics.vector.Fill | string;
        baseFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baseFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseLabels(): anychart.core.ui.LabelsFactory;
        baseLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        baseStroke(): anychart.graphics.vector.Stroke | string;
        baseStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        baselineAbove(): boolean;
        baselineAbove(value?: boolean): anychart.core.ui.Timeline;
        baselineFill(): anychart.graphics.vector.Fill | string;
        baselineFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baselineFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineLabels(): anychart.core.ui.LabelsFactory;
        baselineLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        baselineStroke(): anychart.graphics.vector.Stroke | string;
        baselineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.Timeline;
        connectorFill(): anychart.graphics.vector.Fill | string;
        connectorFill(value?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        connectorPreviewStroke(): anychart.graphics.vector.Stroke | string;
        connectorPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        connectorStroke(): anychart.graphics.vector.Stroke | string;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        defaultRowHeight(): number;
        defaultRowHeight(value?: number): anychart.standalones.ResourceTimeline;
        editConnectorThumbFill(): anychart.graphics.vector.Fill | string;
        editConnectorThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbStroke(): anychart.graphics.vector.Stroke | string;
        editConnectorThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editIntervalThumbFill(): anychart.graphics.vector.Fill | string;
        editIntervalThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbStroke(): anychart.graphics.vector.Stroke | string;
        editIntervalThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editPreviewFill(): anychart.graphics.vector.Fill | string;
        editPreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editPreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewStroke(): anychart.graphics.vector.Stroke | string;
        editPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editProgressFill(): anychart.graphics.vector.Fill | string;
        editProgressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editProgressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressStroke(): anychart.graphics.vector.Stroke | string;
        editProgressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewDashStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editing(): boolean;
        editing(value?: boolean): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        milestoneFill(): anychart.graphics.vector.Fill | string;
        milestoneFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        milestoneFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneLabels(): anychart.core.ui.LabelsFactory;
        milestoneLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        milestoneStroke(): anychart.graphics.vector.Stroke | string;
        milestoneStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        parentFill(): anychart.graphics.vector.Fill | string;
        parentFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        parentFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentLabels(): anychart.core.ui.LabelsFactory;
        parentLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        parentStroke(): anychart.graphics.vector.Stroke | string;
        parentStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        progressFill(): anychart.graphics.vector.Fill | string;
        progressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        progressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressLabels(): anychart.core.ui.LabelsFactory;
        progressLabels(value?: Object | boolean): anychart.core.ui.Timeline;
        progressStroke(): anychart.graphics.vector.Stroke | string;
        progressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(): anychart.graphics.vector.Fill | string;
        selectedElementFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        selectedElementFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementStroke(): anychart.graphics.vector.Stroke | string;
        selectedElementStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
    }
    interface DataGrid extends anychart.core.ui.DataGrid {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        backgroundFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        column(index?: number): anychart.core.ui.DataGrid.Column;
        column(value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        column(index?: number, value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.DataGrid;
        data(): anychart.data.Tree;
        data(value?: anychart.data.Tree): anychart.core.ui.DataGrid;
        defaultRowHeight(): number;
        defaultRowHeight(value?: number): anychart.standalones.DataGrid;
        draw(): anychart.standalones.DataGrid;
        editStructurePreviewDashStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editing(): boolean;
        editing(value?: boolean): anychart.standalones.DataGrid;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endIndex(): number;
        endIndex(value?: number): anychart.core.ui.DataGrid;
        getPixelBounds(): anychart.math.Rect;
        headerHeight(): number;
        headerHeight(value?: number): anychart.standalones.DataGrid;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalOffset(): number;
        horizontalOffset(value?: number): anychart.core.ui.DataGrid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.DataGrid;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.DataGrid;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowHoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(value?: anychart.graphics.vector.Stroke | string): anychart.standalones.DataGrid;
        startIndex(): number;
        startIndex(value?: number): anychart.core.ui.DataGrid;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.DataGrid;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalOffset(): number;
        verticalOffset(value?: number): anychart.core.ui.DataGrid;
        verticalScrollBar(): anychart.core.ui.ScrollBar;
        verticalScrollBar(value?: Object): anychart.standalones.DataGrid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface MarkersFactory extends anychart.core.ui.MarkersFactory {
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.MarkersFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory;
        position(): string;
        position(value?: string): anychart.core.ui.MarkersFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.MarkersFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module MarkersFactory {
    interface Marker extends anychart.core.ui.MarkersFactory.Marker {
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory.Marker;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory.Marker;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory.Marker;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        position(): anychart.enums.Position | string;
        position(value?: anychart.enums.Position | string): anychart.core.ui.MarkersFactory.Marker;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory.Marker;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory.Marker;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory.Marker;
        type(): anychart.enums.MarkerType | (() => void);
        type(value?: anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface Scroller extends anychart.core.ui.Scroller {
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.Scroller;
        draw(): anychart.standalones.Scroller;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endRatio(): number;
        endRatio(value?: number): anychart.standalones.Scroller;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        getRemainingBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.Scroller;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Scroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        setRange(startRatio: number, endRatio: number): anychart.standalones.Scroller;
        startRatio(): number;
        startRatio(value?: number): anychart.standalones.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ColorRange extends anychart.core.ui.ColorRange {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.ColorRange;
        colorLineSize(): number;
        colorLineSize(value?: number): anychart.standalones.ColorRange;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.ColorRange;
        draw(): anychart.standalones.ColorRange;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        length(): number | string;
        length(value?: string | number): anychart.core.ui.ColorRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        marker(): anychart.core.ui.MarkersFactory.Marker;
        marker(value?: anychart.core.ui.MarkersFactory.Marker | Object): anychart.core.ui.ColorRange;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        padding(): anychart.core.ui.table.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.standalones.ColorRange;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.ColorRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.ColorRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.ColorRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Label extends anychart.core.ui.Label {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.Label;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Label;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.standalones.Label;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Label;
        position(): anychart.enums.Position;
        position(value?: anychart.enums.Position | string): anychart.core.ui.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Label;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Background extends anychart.core.ui.Background {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.Background;
        cornerType(): anychart.enums.BackgroundCornersType;
        cornerType(value?: anychart.enums.BackgroundCornersType): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(value?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        draw(): anychart.standalones.Background;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.Background;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Background;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        stroke(value: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Legend extends anychart.core.ui.Legend {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Legend;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Legend;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.Legend;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.standalones.Legend;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Legend;
        hoverCursor(): anychart.enums.Cursor | string;
        hoverCursor(value?: anychart.enums.Cursor | string): anychart.core.ui.Legend;
        iconSize(): number;
        iconSize(value?: number | string): anychart.core.ui.Legend;
        iconTextSpacing(): number;
        iconTextSpacing(value?: string | number): anychart.core.ui.Legend;
        inverted(): boolean;
        inverted(value?: boolean): anychart.core.ui.Legend;
        items(): Array<anychart.core.ui.Legend.LegendItemProvider>;
        items(value?: Array<anychart.core.ui.Legend.LegendItemProvider>): anychart.core.ui.Legend;
        itemsFormat(): (() => void);
        itemsFormat(value?: (() => void)): anychart.core.ui.Legend;
        itemsFormatter(): (() => void);
        itemsFormatter(value?: (() => void)): anychart.core.ui.Legend;
        itemsLayout(): anychart.enums.LegendLayout | string;
        itemsLayout(value?: string | anychart.enums.LegendLayout): anychart.core.ui.Legend;
        itemsSource(): anychart.core.SeparateChart | Array<anychart.core.SeparateChart>;
        itemsSource(value?: anychart.core.SeparateChart | Array<anychart.core.SeparateChart>): anychart.standalones.Legend;
        itemsSourceMode(): string | anychart.enums.LegendItemsSourceMode;
        itemsSourceMode(value?: string | anychart.enums.LegendItemsSourceMode): anychart.core.ui.Legend;
        itemsSpacing(): string | number;
        itemsSpacing(value?: string | number): anychart.core.ui.Legend;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        paginator(): anychart.core.ui.Paginator;
        paginator(value?: Object | boolean): anychart.core.ui.Legend;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.Legend;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Legend;
        position(): anychart.enums.Orientation | string;
        position(value?: anychart.enums.Orientation | string): anychart.core.ui.Legend;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.Legend;
        titleFormat(): string | (() => void);
        titleFormat(value?: string | (() => void)): anychart.core.ui.Legend;
        titleSeparator(): anychart.core.ui.Separator;
        titleSeparator(value?: Object | boolean): anychart.core.ui.Legend;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Legend;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Legend;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Title extends anychart.core.ui.Title {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Title;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Title;
        container(): string | Element;
        container(value?: string | Element): anychart.standalones.Title;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.standalones.Title;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Title;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(allValues?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        orientation(): anychart.enums.Orientation;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Title;
        padding(): anychart.core.utils.Padding;
        padding(value?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.Title;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Title;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.Title;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Title;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Title;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Table extends anychart.core.ui.Table {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cellBorder(): anychart.graphics.vector.Stroke;
        cellBorder(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellFill(color: string, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.Table;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Table;
        colsCount(): number;
        colsCount(value?: number): anychart.core.ui.Table;
        colsMaxWidth(): string | number;
        colsMaxWidth(value?: string | number): anychart.core.ui.Table;
        colsMinWidth(): string | number;
        colsMinWidth(value?: string | number): anychart.core.ui.Table;
        colsWidth(): string | number;
        colsWidth(value?: string | number): anychart.core.ui.Table;
        contents(): Array<Array<(anychart.core.VisualBase)>>;
        contents(tableValues?: Array<Array<(anychart.core.VisualBase|string|number)>>, demergeCells?: boolean): anychart.core.ui.Table;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.Table;
        draw(): anychart.core.ui.Table;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.Table;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Table;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.Table;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.Table;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.Table;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Table;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Table;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.Table;
        getCell(row: number, col: number): anychart.core.ui.table.Cell;
        getCol(col: number): anychart.core.ui.table.Column;
        getPixelBounds(): anychart.math.Rect;
        getRow(row: number): anychart.core.ui.table.Row;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Table;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.Table;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.Table;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(): anychart.graphics.vector.Fill;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowsCount(): number;
        rowsCount(value?: number): anychart.core.ui.Table;
        rowsHeight(): string | number;
        rowsHeight(value?: string | number): anychart.core.ui.Table;
        rowsMaxHeight(): string | number;
        rowsMaxHeight(value?: string | number): anychart.core.ui.Table;
        rowsMinHeight(): string | number;
        rowsMinHeight(value?: string | number): anychart.core.ui.Table;
        saveAsCsv(csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(filename?: string): void;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.Table;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Table;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.Table;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Table;
        toCsv(csvSettings?: {[prop: string]: (string|boolean)}): string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.Table;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Table;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.ui.Table;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.ui.Table;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LabelsFactory extends anychart.core.ui.LabelsFactory {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.LabelsFactory;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ResourceList extends anychart.core.resource.ResourceList {
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.resource.ResourceList;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.ResourceList;
        descriptions(): anychart.core.resource.resourceList.TextSettings;
        descriptions(value?: Object): anychart.core.resource.ResourceList;
        draw(): anychart.standalones.ResourceList;
        drawBottomLine(): boolean;
        drawBottomLine(value?: boolean): anychart.core.resource.ResourceList;
        drawLeftLine(): boolean;
        drawLeftLine(value?: boolean): anychart.core.resource.ResourceList;
        drawRightLine(): boolean;
        drawRightLine(value?: boolean): anychart.core.resource.ResourceList;
        drawTopLine(): boolean;
        drawTopLine(value?: boolean): anychart.core.resource.ResourceList;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): anychart.graphics.vector.Fill;
        evenFill(value: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        evenFill(color: string, opacity?: number): anychart.core.resource.ResourceList;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.ResourceList;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.ResourceList;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        images(): anychart.core.resource.resourceList.ImageSettings;
        images(value?: Object): anychart.core.resource.ResourceList;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        names(): anychart.core.resource.resourceList.TextSettings;
        names(value?: Object): anychart.core.resource.ResourceList;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(value: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        oddFill(color: string, opacity?: number): anychart.core.resource.ResourceList;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.ResourceList;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.ResourceList;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        overlay(): anychart.core.ui.Overlay;
        overlay(value?: string | Object | boolean): anychart.core.resource.ResourceList;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.ResourceList;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.ResourceList;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.resource.ResourceList;
        tags(): anychart.core.resource.resourceList.TagsSettings;
        tags(value?: Object): anychart.core.resource.ResourceList;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        types(): anychart.core.resource.resourceList.TextSettings;
        types(value?: Object): anychart.core.resource.ResourceList;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.standalones.axes {
    function linear(): anychart.standalones.axes.Linear;
    function polar(): anychart.standalones.axes.Polar;
    function radar(): anychart.standalones.axes.Radar;
    function radial(): anychart.standalones.axes.Radial;
    interface Polar extends anychart.core.axes.Polar {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Polar;
        draw(): anychart.standalones.axes.Polar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Polar;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Polar;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Polar;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axes.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Polar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.ScatterBase;
        scale(value?: anychart.scales.ScatterBase | anychart.enums.ScaleTypes | string | Object): anychart.core.axes.Polar;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.standalones.axes.Polar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Polar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.axes.Linear {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Linear;
        draw(): anychart.standalones.axes.Linear;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.standalones.axes.Linear;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.axes.Linear;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axes.Linear;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radial extends anychart.core.axes.Radial {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Radial;
        draw(): anychart.core.axes.Radial;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Radial;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Radial;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        innerRadius(): string | number;
        innerRadius(value?: string | number): anychart.standalones.axes.Radial;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radial;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Radial;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Radial;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Radial;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axes.Radial;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Radial;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axes.Radial;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.standalones.axes.Radial;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radial;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radial;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.axes.Radar {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Radar;
        draw(): anychart.standalones.axes.Radar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axes.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Radar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | anychart.enums.ScaleTypes | Object): anychart.core.axes.Radar;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.standalones.axes.Radar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.standalones.axisMarkers {
    function line(): anychart.standalones.axisMarkers.Line;
    function range(): anychart.standalones.axisMarkers.Range;
    function text(): anychart.standalones.axisMarkers.Text;
    interface Text extends anychart.core.axisMarkers.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.axisMarkers.Text;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.axisMarkers.Text;
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axisMarkers.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.standalones.axisMarkers.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.axisMarkers.Text;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Text;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.axisMarkers.Text;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.axisMarkers.Text;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axisMarkers.Text;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axisMarkers.Text;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.axisMarkers.Text;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axisMarkers.Text;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.axisMarkers.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean | (() => void)): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        value(): number;
        value(value?: number): anychart.core.axisMarkers.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.axisMarkers.Text;
        wordBreak(): string | anychart.enums.WordBreak;
        wordBreak(value?: string | anychart.enums.WordBreak): anychart.core.Text;
        wordWrap(): string | anychart.enums.WordWrap;
        wordWrap(value?: string | anychart.enums.WordWrap): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.axisMarkers.Line {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axisMarkers.Line;
        draw(): anychart.standalones.axisMarkers.Line;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axisMarkers.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axisMarkers.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axisMarkers.Line;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.Line;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): number;
        value(newValue?: number): anychart.core.axisMarkers.Line;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Range extends anychart.core.axisMarkers.Range {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axisMarkers.Range;
        draw(): anychart.standalones.axisMarkers.Range;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.Range;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        from(): number;
        from(value?: number): anychart.core.axisMarkers.Range;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Range;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axisMarkers.Range;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axisMarkers.Range;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | Object | anychart.enums.ScaleTypes | string): anychart.core.axisMarkers.Range;
        to(): number;
        to(value?: number): anychart.core.axisMarkers.Range;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.standalones.grids {
    function linear(): anychart.core.grids.Linear;
    function polar(): anychart.standalones.grids.Polar;
    function radar(): anychart.standalones.grids.Radar;
    interface Polar extends anychart.core.grids.Polar {
        axis(): anychart.core.axes.Polar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Polar | anychart.core.axes.Radial): anychart.core.grids.Polar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Polar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Polar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        innerRadius(): string | number;
        innerRadius(value?: string | number): anychart.core.grids.Polar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Polar;
        isRadial(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.standalones.grids.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xScale(): anychart.scales.Base;
        xScale(value?: (anychart.scales.Base|anychart.enums.ScaleTypes|string|Object) ): anychart.core.grids.Polar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.grids.Linear {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.grids.Linear;
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Linear;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        fill(fillFunction?: (() => void)): anychart.core.grids.Linear;
        fill(color: string, opacity?: number): anychart.core.grids.Linear;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Linear;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.standalones.grids.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: Object | string | anychart.enums.ScaleTypes | anychart.scales.Base): anychart.core.grids.Linear;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.grids.Radar {
        axis(): anychart.core.axes.Radar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Radar | anychart.core.axes.Radial): anychart.core.grids.Radar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Radar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): string | anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        fill(fillFunction?: (() => void)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Radar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        innerRadius(): string | number;
        innerRadius(value?: string | number): anychart.core.grids.Radar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Radar;
        isRadial(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.standalones.grids.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.ui {
    function contextMenu(): anychart.ui.ContextMenu;
    function ganttToolbar(): anychart.ui.GanttToolbar;
    function preloader(): anychart.ui.Preloader;
    function rangePicker(): anychart.ui.RangePicker;
    function rangeSelector(): anychart.ui.RangeSelector;
    function zoom(): anychart.ui.Zoom;
    interface RangePicker {
        decorate(value: Element): void;
        dispose(): void;
        format(): string;
        format(format?: string): string;
        fromLabelText(): string;
        fromLabelText(value?: string): anychart.ui.RangePicker;
        getElement(): Element;
        render(parentElement?: anychart.charts.Stock | Element): void;
        target(chart: anychart.charts.Stock): void;
        toLabelText(): string;
        toLabelText(value?: string): anychart.ui.RangePicker;
    }
    interface Zoom {
        decorate(value: Element): void;
        dispose(): void;
        render(parentElement?: anychart.charts.Map | Element): void;
        target(chart: anychart.charts.Map): void;
    }
    interface RangeSelector {
        decorate(value: Element): void;
        dispose(): void;
        getElement(): Element;
        ranges(): Array<anychart.ui.RangeSelector.Range>;
        ranges(ranges?: Array<anychart.ui.RangeSelector.Range>): Array<anychart.ui.RangeSelector.Range>;
        render(parentElement?: anychart.charts.Stock | Element): void;
        target(chart: anychart.charts.Stock): void;
        zoomLabelText(): string;
        zoomLabelText(value?: string): anychart.ui.RangeSelector;
    }
    namespace RangeSelector {
    interface Range {
        anchor: anychart.enums.StockRangeAnchor;
        count: number;
        endDate: string;
        startDate: string;
        text: string;
        type: anychart.enums.StockRangeType;
        unit: anychart.enums.Interval;
    }
    }
    interface GanttToolbar {
        container(): Element;
        container(element?: string | Element): anychart.ui.GanttToolbar;
        draw(): anychart.ui.GanttToolbar;
        printPaperSizes(): Array<anychart.graphics.vector.PaperSize>;
        printPaperSizes(value?: Array<anychart.graphics.vector.PaperSize>): anychart.ui.GanttToolbar;
        target(): anychart.core.Chart;
        target(value?: anychart.core.Chart): anychart.ui.GanttToolbar;
    }
    interface Preloader {
        decorate(element: Element): void;
        render(parentElement?: Element): void;
        visible(): boolean;
        visible(value?: boolean): anychart.ui.Preloader;
    }
    interface ContextMenu {
        addClassName(className: string): void;
        attach(target: Element | anychart.core.Chart, capture?: boolean): anychart.ui.ContextMenu;
        detach(target?: Element, capture?: boolean): anychart.ui.ContextMenu;
        enabled(): boolean;
        enabled(value?: boolean): anychart.ui.ContextMenu;
        hide(): void;
        items(): Array<anychart.ui.ContextMenu.Item>;
        items(value?: Array<anychart.ui.ContextMenu.Item>): anychart.ui.ContextMenu;
        itemsFormatter(): (() => void);
        itemsFormatter(value?: (() => void)): anychart.ui.ContextMenu;
        itemsProvider(): (() => void);
        itemsProvider(value?: (() => void)): anychart.ui.ContextMenu;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeClassName(className: string): void;
        serialize(): Object;
        setup(...var_args: (Object | Array<any> | number | string | boolean)[]): anychart.ui.ContextMenu;
        show(x: number, y: number): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
    }
    namespace ContextMenu {
    interface Item {
        action: (() => void);
        classNames: string | Array<string>;
        enabled: boolean;
        eventType: string;
        href: string;
        iconClass: string;
        index: number;
        meta: any;
        scrollable: boolean;
        subMenu: Array<anychart.ui.ContextMenu.Item>;
        target: string;
        text: string;
    }
    interface ActionContext {
        chart: anychart.core.Chart;
        event: Object;
        item: anychart.ui.ContextMenu.Item;
        selectedPoints: Array<anychart.core.Point>;
        target: Element | anychart.core.VisualBase;
        type: string;
    }
    interface PrepareItemsContext {
        chart: anychart.core.Chart;
        event: anychart.core.MouseEvent;
        menu: anychart.ui.ContextMenu;
        selectedPoints: Array<anychart.core.Point>;
        target: Element | anychart.core.VisualBase;
    }
    }
}

declare namespace anychart.utils {
    function hideTooltips(force?: boolean): void;
    function htmlTableFromCsv(csv: string, title?: string, asString?: boolean, csvSettings?: Object): Element;
    function json2xml(json: Object | string, rootNodeName?: string, returnAsXmlNode?: boolean): string | Node;
    function xml2json(xml: string | Node): Object | string;
    interface RectObj {
        bottom: number | string;
        height: number | string;
        left: number | string;
        right: number | string;
        top: number | string;
        width: number | string;
    }
}