// Type definitions for AnyChart JavaScript Charting Library, v8.11.0
// Project: https://www.anychart.com/
// Definitions by: AnyChart <https://www.anychart.com>
declare namespace anychart {
    const DEFAULT_THEME: string;
    const DEVELOP: boolean;
    const PERFORMANCE_MONITORING: boolean;
    const VERSION: string;
    function appendTheme(value: string | Object): void;
    function area(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function area3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function bar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function bar3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function barmekko(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Mekko;
    function box(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function bubble(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function bubbleMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function bullet(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Bullet;
    function calendar(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Calendar;
    function candlestick(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function cartesian(): anychart.charts.Cartesian;
    function cartesian3d(): anychart.charts.Cartesian3d;
    function choropleth(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function circlePacking(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.CirclePacking;
    function circularGauge(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.CircularGauge;
    function column(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function column3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function connector(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function editor(): anychart.editor.Editor;
    function financial(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function fromJson(jsonConfig: Object | string): any;
    function fromJsonFile(url: string, onSuccessOrContainer?: string | (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function fromXml(xmlConfig: string | Node): any;
    function fromXmlFile(url: string, onSuccessOrContainer?: string | (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function funnel(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Funnel;
    function ganttProject(): anychart.charts.Gantt;
    function ganttResource(): anychart.charts.Gantt;
    function getChartById(id: string): anychart.core.Chart;
    function graph(data?: Object): anychart.charts.Graph;
    function heatMap(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.HeatMap;
    function hilo(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function jumpLine(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function licenseKey(key?: string): string;
    function line(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function line3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function map(): anychart.charts.Map;
    function marker(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function markerMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function mekko(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Mekko;
    function mosaic(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Mekko;
    function ohlc(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function onDocumentLoad(func: (() => void), scope?: any): void;
    function onDocumentReady(func: (() => void), scope?: any): void;
    function pareto(data?: anychart.data.View | anychart.data.Set | Array<any>): anychart.charts.Pareto;
    function pert(): anychart.charts.Pert;
    function pie(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Pie;
    function pie3d(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Pie;
    function polar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Polar;
    function pyramid(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Pyramid;
    function quadrant(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function radar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Radar;
    function resource(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Resource;
    function sankey(): anychart.charts.Sankey;
    function scatter(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function seatMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function server(): string;
    function server(address?: string): void;
    function sparkline(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Sparkline;
    function stepLine(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function stick(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function stock(allowPointSettings?: boolean): anychart.charts.Stock;
    function sunburst(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.Sunburst;
    function surface(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Surface;
    function tagCloud(data?: anychart.data.View | anychart.data.Set | Array<any> | string, settings?: string | anychart.data.TextParsingSettings): anychart.charts.TagCloud;
    function theme(settings?: string | Object | Array<string|Object>): string | Object | Array<string|Object>;
    function timeline(data?: anychart.data.View | anychart.data.Set | Array<any>): anychart.charts.Timeline;
    function treeMap(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.TreeMap;
    function venn(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop:string]:string|boolean}): anychart.charts.Venn;
    function vertical(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function verticalArea(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function verticalLine(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function waterfall(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Waterfall;
    function wordtree(data?: anychart.data.Tree | string | Array<Object> | Array<Array<string>> | Array<string>, fillMethod?: string): anychart.charts.Wordtree;
    interface SignalEvent {
        targetBoundsChanged(): boolean;
        targetDataChanged(): boolean;
        targetMetaChanged(): boolean;
        targetNeedsReapplication(): boolean;
        targetNeedsRecalculation(): boolean;
        targetNeedsRedraw(): boolean;
    }
}

declare namespace anychart.charts {
    interface Sunburst extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Sunburst;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Sunburst;
        animation(enabled: boolean, duration: number): anychart.charts.Sunburst;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Sunburst;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Sunburst;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Sunburst;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Sunburst;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Sunburst;
        calculationMode(): string;
        calculationMode(mode?: string): anychart.charts.Sunburst;
        cancelMarquee(): anychart.charts.Sunburst;
        center(): anychart.core.ui.Center;
        center(centerSettings?: Object): anychart.charts.Sunburst;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Sunburst;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Sunburst;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Sunburst;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.Sunburst;
        draw(async?: boolean): anychart.charts.Sunburst;
        drillTo(target: anychart.data.Tree.DataItem | Array<any> | string): void;
        drillUp(): void;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Sunburst;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Sunburst;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sunburst;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.Sunburst;
        fill(color: string, opacity?: number): anychart.charts.Sunburst;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sunburst;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sunburst;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sunburst;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Sunburst;
        fullScreen(): boolean;
        getDrilldownPath(): Array<any>;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (()=>anychart.graphics.vector.HatchFill);
        hatchFill(enabled?: boolean): anychart.charts.Sunburst;
        hatchFill(hatchFillFunction?: (()=>anychart.graphics.vector.HatchFill)): anychart.charts.Sunburst;
        hatchFill(patternHatchFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sunburst;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sunburst;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sunburst;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Sunburst;
        height(): number | string;
        height(height?: number | string): anychart.charts.Sunburst;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Sunburst;
        id(): string;
        id(id?: string): anychart.charts.Sunburst;
        inMarquee(): boolean;
        innerRadius(): string | number | (() => void);
        innerRadius(innerRadius?: string | number | ((outerRadius:number)=>number)): anychart.charts.Sunburst;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Sunburst;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Sunburst;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Sunburst;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Sunburst;
        leaves(): anychart.core.sunburst.Level;
        leaves(settings?: Object | boolean): anychart.charts.Sunburst;
        left(): number | string;
        left(value?: number | string): anychart.charts.Sunburst;
        level(index: number): anychart.core.sunburst.Level;
        level(index: number, settings?: Object | boolean): anychart.charts.Sunburst;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Sunburst;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Sunburst;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Sunburst;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Sunburst;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Sunburst;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Sunburst;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Sunburst;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Sunburst;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Sunburst;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Sunburst;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Sunburst;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string | number;
        radius(radius?: string | number): anychart.charts.Sunburst;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Sunburst;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sunburst;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Sunburst;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sunburst;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sunburst;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sunburst;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Sunburst;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Sunburst;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        sort(): string | ((dataItem_1:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem,dataItem_2:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)=>number);
        sort(mode?: string): anychart.charts.Sunburst;
        sort(sortFunction?: ((dataItem_1:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem,dataItem_2:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)=>number)): anychart.charts.Sunburst;
        startAngle(): string | number;
        startAngle(startAngle?: string | number): anychart.charts.Sunburst;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Sunburst;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.Sunburst;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Sunburst;
        stroke(settings?: Object): anychart.charts.Sunburst;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Sunburst;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Sunburst;
        top(): number | string;
        top(top?: number | string): anychart.charts.Sunburst;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Sunburst;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Sunburst;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Sunburst;
        dispose(): void;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Sunburst;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Sunburst;
    }
    namespace Sunburst {
    type StatsFieldsName = {
        depth: number;
        level: {sum:number,nodesCount:number,leavesCount:number,branchesCount:number,display:boolean,attendingRoots:Array<number>,statsByRoot:{[prop:string]:{sum:number,nodesCount:number,leavesSum:number,leavesCount:number,branchesCount:number,childSum:number,nodes:Array<anychart.core.TreeChartPoint>}}};
    }
    }
    interface Surface extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Surface;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Surface;
        animation(enabled: boolean, duration: number): anychart.charts.Surface;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Surface;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Surface;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Surface;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Surface;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Surface;
        box(): anychart.graphics.vector.Stroke;
        box(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Surface;
        box(settings?: Object): anychart.charts.Surface;
        cancelMarquee(): anychart.charts.Surface;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(settings?: Object): anychart.charts.Surface;
        colorScale(): anychart.scales.LinearColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.charts.Surface;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Surface;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Surface;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Surface;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | Array<Array<number>> | string): anychart.charts.Surface;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Surface;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Surface;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Surface;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Surface;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Surface;
        id(): string;
        id(id?: string): anychart.charts.Surface;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Surface;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Surface;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Surface;
        left(): number | string;
        left(value?: number | string): anychart.charts.Surface;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Surface;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Surface;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Surface;
        markers(): anychart.core.surface.markers.Controller;
        markers(config: anychart.core.surface.markers.Config): anychart.charts.Surface;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Surface;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Surface;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Surface;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Surface;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Surface;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Surface;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Surface;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Surface;
        rotationY(): number;
        rotationY(angle?: number): anychart.charts.Surface;
        rotationZ(): number;
        rotationZ(angle?: number): anychart.charts.Surface;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Surface;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Surface;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Surface;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Surface;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Surface;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Surface;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Surface;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Surface;
        stroke(settings?: Object): anychart.charts.Surface;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Surface;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Surface;
        top(): number | string;
        top(top?: number | string): anychart.charts.Surface;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Surface;
        xAxis(): anychart.core.axes.Surface;
        xAxis(settings?: Object | boolean): anychart.charts.Surface;
        xGrid(): anychart.core.grids.Surface;
        xGrid(settings?: Object | boolean): anychart.charts.Surface;
        xScale(): anychart.scales.Base;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.charts.Surface;
        yAxis(): anychart.core.axes.Surface;
        yAxis(settings?: Object | boolean): anychart.charts.Surface;
        yGrid(): anychart.core.grids.Surface;
        yGrid(settings?: Object | boolean): anychart.charts.Surface;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.charts.Surface;
        zAxis(): anychart.core.axes.Surface;
        zAxis(settings?: Object | boolean): anychart.charts.Surface;
        zGrid(): anychart.core.grids.Surface;
        zGrid(settings?: Object | boolean): anychart.charts.Surface;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Surface;
        zScale(): anychart.scales.Base;
        zScale(settings?: anychart.scales.Base | Object | string): anychart.charts.Surface;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Surface;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Surface;
    }
    interface TreeMap extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.TreeMap;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.TreeMap;
        animation(enabled: boolean, duration: number): anychart.charts.TreeMap;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.TreeMap;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.TreeMap;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.TreeMap;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.TreeMap;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.TreeMap;
        cancelMarquee(): anychart.charts.TreeMap;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(settings?: Object): anychart.charts.TreeMap;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(settings?: anychart.scales.OrdinalColor | anychart.scales.LinearColor | Object | string): anychart.scales.LinearColor;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.TreeMap;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.TreeMap;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.TreeMap;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.TreeMap;
        dispose(): void;
        draw(async?: boolean): anychart.charts.TreeMap;
        drillTo(target: anychart.data.Tree.DataItem | Array<any> | string): void;
        drillUp(): void;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.TreeMap;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.TreeMap;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.TreeMap;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.TreeMap;
        fill(color: string, opacity?: number): anychart.charts.TreeMap;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TreeMap;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TreeMap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.TreeMap;
        getDrilldownPath(): Array<any>;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.TreeMap;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.TreeMap;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.TreeMap;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.TreeMap;
        hatchFill(enabled?: boolean): anychart.charts.TreeMap;
        headers(): anychart.core.ui.LabelsFactory;
        headers(settings?: Object | boolean): anychart.charts.TreeMap;
        headersDisplayMode(): string;
        headersDisplayMode(mode?: string): anychart.charts.TreeMap;
        height(): number | string;
        height(height?: number | string): anychart.charts.TreeMap;
        hintDepth(): number;
        hintDepth(hintDepth?: number): anychart.charts.TreeMap;
        hintOpacity(): number;
        hintOpacity(hintOpacity?: number): anychart.charts.TreeMap;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.TreeMap;
        id(): string;
        id(id?: string): anychart.charts.TreeMap;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.TreeMap;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.TreeMap;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.TreeMap;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.TreeMap;
        labelsDisplayMode(): string;
        labelsDisplayMode(mode?: string): anychart.charts.TreeMap;
        left(): number | string;
        left(value?: number | string): anychart.charts.TreeMap;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.TreeMap;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.TreeMap;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.TreeMap;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.charts.TreeMap;
        maxDepth(): number;
        maxDepth(maxDepth?: number): anychart.charts.TreeMap;
        maxHeadersHeight(): number | string;
        maxHeadersHeight(height?: number | string): anychart.charts.TreeMap;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.TreeMap;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.TreeMap;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.TreeMap;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.TreeMap;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.TreeMap;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.TreeMap;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.TreeMap;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.TreeMap;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.TreeMap;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.TreeMap;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.TreeMap;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TreeMap;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TreeMap;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.TreeMap;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.TreeMap;
        selectionMode(): string;
        selectionMode(value?: string): anychart.charts.TreeMap;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        sort(): string;
        sort(type?: string): anychart.charts.TreeMap;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.TreeMap;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.TreeMap;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.TreeMap;
        stroke(settings?: Object): anychart.charts.TreeMap;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.TreeMap;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.TreeMap;
        top(): number | string;
        top(top?: number | string): anychart.charts.TreeMap;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.TreeMap;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.TreeMap;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.TreeMap;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.TreeMap;
    }
    interface Timeline extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.timeline.series.Base>;
        axis(): anychart.core.axes.Timeline;
        axis(value?: Object): anychart.charts.Timeline;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Timeline;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Timeline;
        fit(): anychart.charts.Timeline;
        getSeries(id: number | string): anychart.core.timeline.series.Base;
        getSeriesAt(index: number): anychart.core.timeline.series.Base;
        getSeriesCount(): number;
        getType(): string;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value: Object): anychart.charts.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Timeline;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Timeline;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        moment(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.timeline.series.Moment;
        range(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.timeline.series.Range;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Timeline;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Timeline;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Timeline;
        removeSeries(id: number | string): anychart.charts.Timeline;
        removeSeriesAt(index: number): anychart.charts.Timeline;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: Object): anychart.charts.Timeline;
        scroll(): number;
        scroll(value?: number): anychart.charts.Timeline;
        scroller(): anychart.core.ui.ChartScroller;
        scroller(value?: Object | boolean): anychart.charts.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Timeline;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Timeline;
        todayMarker(): anychart.core.axisMarkers.Line;
        todayMarker(value?: Object | boolean): anychart.charts.Timeline;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zoomTo(startDate: string | number | Date, endDate: string | number | Date): anychart.charts.Timeline;
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Timeline;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Timeline;
        animation(enabled: boolean, duration: number): anychart.charts.Timeline;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Timeline;
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.charts.Timeline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Timeline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Timeline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Timeline;
        cancelMarquee(): anychart.charts.Timeline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Timeline;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Timeline;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Timeline;
        draw(async?: boolean): anychart.charts.Timeline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Timeline;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Timeline;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Timeline;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Timeline;
        id(): string;
        id(id?: string): anychart.charts.Timeline;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Timeline;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Timeline;
        left(): number | string;
        left(left?: number | string): anychart.charts.Timeline;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Timeline;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Timeline;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Timeline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.charts.Timeline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.charts.Timeline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.charts.Timeline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.charts.Timeline;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Timeline;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Timeline;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Timeline;
        right(): number | string;
        right(right?: number | string): anychart.charts.Timeline;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Timeline;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Timeline;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Timeline;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Timeline;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Timeline;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Timeline;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Timeline;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Timeline;
        top(): number | string;
        top(top?: number | string): anychart.charts.Timeline;
        width(): number | string;
        width(width?: number | string): anychart.charts.Timeline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Timeline;
        dispose(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Timeline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Timeline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Timeline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
    }
    interface Cartesian extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Cartesian;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Cartesian;
        animation(enabled: boolean, duration: number): anychart.charts.Cartesian;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Cartesian;
        area(data?: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Area;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Cartesian;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Cartesian;
        bar(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bar;
        barGroupsPadding(): number;
        barGroupsPadding(padding?: number): anychart.charts.Cartesian;
        barsPadding(): number;
        barsPadding(padding?: number): anychart.charts.Cartesian;
        baseline(): number;
        baseline(value?: number): anychart.charts.Cartesian;
        bottom(): number | string;
        bottom(value?: number | string): anychart.charts.Cartesian;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Cartesian;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Cartesian;
        box(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Box;
        bubble(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bubble;
        cancelMarquee(): anychart.charts.Cartesian;
        candlestick(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Candlestick;
        categorizedBySeries(): boolean;
        categorizedBySeries(enabled?: boolean): anychart.charts.Cartesian;
        column(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Cartesian;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Cartesian;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Cartesian;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Cartesian;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Cartesian;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.charts.Cartesian;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Cartesian;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Cartesian;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Cartesian;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Cartesian;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Cartesian;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.cartesian.series.Base;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Cartesian;
        height(): number | string;
        height(value?: number | string): anychart.charts.Cartesian;
        hilo(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Hilo;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Cartesian;
        id(): string;
        id(id?: string): anychart.charts.Cartesian;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Cartesian;
        isFullScreenAvailable(): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.charts.Cartesian;
        jumpLine(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.JumpLine;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Cartesian;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Cartesian;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Cartesian;
        left(): number | string;
        left(value?: number | string): anychart.charts.Cartesian;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Cartesian;
        line(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Cartesian;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Cartesian;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian;
        marker(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Cartesian;
        maxBubbleSize(): number | string;
        maxBubbleSize(size?: number | string): anychart.charts.Cartesian;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.charts.Cartesian;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Cartesian;
        maxPointWidth(): string | number;
        maxPointWidth(maxWidth?: number | string): anychart.charts.Cartesian;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Cartesian;
        minBubbleSize(): number | string;
        minBubbleSize(size?: number | string): anychart.charts.Cartesian;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.charts.Cartesian;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Cartesian;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.charts.Cartesian;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.charts.Cartesian;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Cartesian;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Cartesian;
        ohlc(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.OHLC;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Cartesian;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Cartesian;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.charts.Cartesian;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeArea(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeArea;
        rangeBar(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeBar;
        rangeColumn(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeColumn;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Cartesian;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        rangeSplineArea(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeSplineArea;
        rangeStepArea(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Cartesian;
        removeSeries(id: number | string): anychart.charts.Cartesian;
        removeSeriesAt(index: number): anychart.charts.Cartesian;
        right(): number | string;
        right(value?: number | string): anychart.charts.Cartesian;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Cartesian;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Cartesian;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Cartesian;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Cartesian;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Cartesian;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Cartesian;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Cartesian;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        spline(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Spline;
        splineArea(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.SplineArea;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Cartesian;
        stepArea(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.StepArea;
        stepLine(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.StepLine;
        stick(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Stick;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Cartesian;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Cartesian;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Cartesian;
        top(): number | string;
        top(value?: number | string): anychart.charts.Cartesian;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.charts.Cartesian;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.Cartesian;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(settings?: Object | boolean): anychart.charts.Cartesian;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Cartesian;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        xScale(): anychart.scales.Base;
        xScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Cartesian;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(settings?: Object | boolean): anychart.charts.Cartesian;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(settings?: number | boolean | Object): anychart.charts.Cartesian;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.Cartesian;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(settings?: Object | boolean): anychart.charts.Cartesian;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Cartesian;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian;
        yScale(): anychart.scales.Linear;
        yScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Cartesian;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(settings?: Object | boolean): anychart.charts.Cartesian;
        yZoom(): anychart.core.utils.OrdinalZoom;
        yZoom(settings?: number | boolean | Object): anychart.charts.Cartesian;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Cartesian;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Cartesian;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Cartesian;
    }
    interface Bullet extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Bullet;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Bullet;
        axis(): anychart.core.axes.Linear;
        axis(settings?: Object | boolean): anychart.charts.Bullet;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Bullet;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Bullet;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Bullet;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Bullet;
        cancelMarquee(): anychart.charts.Bullet;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Bullet;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Bullet;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Bullet;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Bullet;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Bullet;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Bullet;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Bullet;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Bullet;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Bullet;
        id(): string;
        id(id?: string): anychart.charts.Bullet;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        isHorizontal(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Bullet;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Bullet;
        layout(): string;
        layout(layout?: string): anychart.charts.Bullet;
        left(): number | string;
        left(left?: number | string): anychart.charts.Bullet;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Bullet;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Bullet;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: Array<string|string> | Object | anychart.palettes.Markers): anychart.charts.Bullet;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Bullet;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Bullet;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Bullet;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Bullet;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Bullet;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Bullet;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Bullet;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        range(index?: number): anychart.core.axisMarkers.Range;
        range(settings?: Object | boolean): anychart.charts.Bullet;
        range(index?: number, settings?: Object | boolean): anychart.charts.Bullet;
        rangePalette(): anychart.palettes.DistinctColors;
        rangePalette(settings?: anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Bullet;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Bullet;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.charts.Bullet;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Bullet;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Bullet;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Bullet;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Bullet;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Bullet;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Bullet;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Bullet;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Bullet;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Bullet;
        top(): number | string;
        top(top?: number | string): anychart.charts.Bullet;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Bullet;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Bullet;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Bullet;
        animation(enabled: boolean, duration: number): anychart.charts.Bullet;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Bullet;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Bullet;
    }
    interface CirclePacking extends anychart.core.SeparateChart {
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.CirclePacking;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.CirclePacking;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.CirclePacking;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.CirclePacking;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.CirclePacking;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.CirclePacking;
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.CirclePacking;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.CirclePacking;
        animation(enabled: boolean, duration: number): anychart.charts.CirclePacking;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.CirclePacking;
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.charts.CirclePacking;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.CirclePacking;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.CirclePacking;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.CirclePacking;
        cancelMarquee(): anychart.charts.CirclePacking;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.CirclePacking;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.CirclePacking;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.CirclePacking;
        draw(async?: boolean): anychart.charts.CirclePacking;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.CirclePacking;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.CirclePacking;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.CirclePacking;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.CirclePacking;
        id(): string;
        id(id?: string): anychart.charts.CirclePacking;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.CirclePacking;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.CirclePacking;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.CirclePacking;
        left(): number | string;
        left(left?: number | string): anychart.charts.CirclePacking;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.CirclePacking;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.CirclePacking;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.CirclePacking;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.charts.CirclePacking;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.charts.CirclePacking;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.charts.CirclePacking;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.charts.CirclePacking;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.CirclePacking;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.CirclePacking;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.CirclePacking;
        right(): number | string;
        right(right?: number | string): anychart.charts.CirclePacking;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.CirclePacking;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.CirclePacking;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.CirclePacking;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.CirclePacking;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.CirclePacking;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.CirclePacking;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.CirclePacking;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        top(): number | string;
        top(top?: number | string): anychart.charts.CirclePacking;
        width(): number | string;
        width(width?: number | string): anychart.charts.CirclePacking;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.CirclePacking;
        dispose(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.CirclePacking;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.CirclePacking;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.CirclePacking;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Calendar extends anychart.core.SeparateChart {
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(settings?: Object): anychart.charts.Calendar;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(settings?: anychart.scales.OrdinalColor | anychart.scales.LinearColor | Object | string): anychart.charts.Calendar;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Calendar;
        days(): anychart.core.calendar.settings.Days;
        days(settings?: Object): anychart.charts.Calendar;
        months(): anychart.core.calendar.settings.Months;
        months(settings?: Object): anychart.charts.Calendar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Calendar;
        weeks(): anychart.core.calendar.settings.Weeks;
        weeks(settings?: Object): anychart.charts.Calendar;
        years(): anychart.core.calendar.settings.Years;
        years(settings?: Object): anychart.charts.Calendar;
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Calendar;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Calendar;
        animation(enabled: boolean, duration: number): anychart.charts.Calendar;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Calendar;
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.charts.Calendar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Calendar;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Calendar;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Calendar;
        cancelMarquee(): anychart.charts.Calendar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Calendar;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Calendar;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Calendar;
        draw(async?: boolean): anychart.charts.Calendar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Calendar;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Calendar;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Calendar;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Calendar;
        id(): string;
        id(id?: string): anychart.charts.Calendar;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Calendar;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Calendar;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Calendar;
        left(): number | string;
        left(left?: number | string): anychart.charts.Calendar;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Calendar;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Calendar;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Calendar;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.charts.Calendar;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.charts.Calendar;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.charts.Calendar;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.charts.Calendar;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Calendar;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Calendar;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Calendar;
        right(): number | string;
        right(right?: number | string): anychart.charts.Calendar;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Calendar;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Calendar;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Calendar;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Calendar;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Calendar;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Calendar;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Calendar;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        top(): number | string;
        top(top?: number | string): anychart.charts.Calendar;
        width(): number | string;
        width(width?: number | string): anychart.charts.Calendar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Calendar;
        dispose(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Calendar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Calendar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Calendar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Polar extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Polar;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.polar.series.Base>;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Area;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Polar;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Polar;
        barGroupsPadding(): number;
        barGroupsPadding(padding?: number): anychart.charts.Polar;
        barsPadding(): number;
        barsPadding(padding?: number): anychart.charts.Polar;
        baseline(): number;
        baseline(value?: number): anychart.charts.Polar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Polar;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Polar;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Polar;
        cancelMarquee(): anychart.charts.Polar;
        column(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Polar;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Polar;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Polar;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Polar;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Polar;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Polar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Polar;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Polar;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Polar;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.polar.series.Base;
        getSeriesAt(index: number): anychart.core.polar.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXScales(): Array<any>;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Polar;
        height(): number | string;
        height(height?: number | string): anychart.charts.Polar;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Polar;
        id(): string;
        id(id?: string): anychart.charts.Polar;
        inMarquee(): boolean;
        innerRadius(): number | string;
        innerRadius(radius?: number | string): anychart.charts.Polar;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Polar;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Polar;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Polar;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Polar;
        left(): number | string;
        left(value?: number | string): anychart.charts.Polar;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Polar;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Line;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Polar;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Polar;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Polar;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Polar;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Polar;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.charts.Polar;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Polar;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Polar;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Polar;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.charts.Polar;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Polar;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Polar;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Polar;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Polar;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Polar;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Polar;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.charts.Polar;
        polygon(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Polygon;
        polyline(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Polyline;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeColumn(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.RangeColumn;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Polar;
        removeSeries(id: number | string): anychart.charts.Polar;
        removeSeriesAt(index: number): anychart.charts.Polar;
        right(): number | string;
        right(right?: number | string): anychart.charts.Polar;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Polar;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Polar;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Polar;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Polar;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Polar;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Polar;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Polar;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        sortPointsByX(): boolean;
        sortPointsByX(enabled?: boolean): anychart.charts.Polar;
        spreadValues(): string;
        spreadValues(spreadType?: string): anychart.charts.Polar;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.charts.Polar;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Polar;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Polar;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Polar;
        top(): number | string;
        top(top?: number | string): anychart.charts.Polar;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Polar;
        xAxis(): anychart.core.axes.Polar;
        xAxis(settings?: Object | boolean): anychart.charts.Polar;
        xGrid(index?: number): anychart.core.grids.Polar;
        xGrid(settings?: Object | boolean): anychart.charts.Polar;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Polar;
        xMinorGrid(index?: number): anychart.core.grids.Polar;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Polar;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Polar;
        xScale(): anychart.scales.ScatterBase;
        xScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Polar;
        yAxis(): anychart.core.axes.Radial;
        yAxis(settings?: Object | boolean): anychart.charts.Polar;
        yGrid(index?: number): anychart.core.grids.Polar;
        yGrid(settings?: Object | boolean): anychart.charts.Polar;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Polar;
        yMinorGrid(index?: number): anychart.core.grids.Polar;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Polar;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Polar;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: Object | string | anychart.scales.ScatterBase): anychart.charts.Polar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Polar;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Polar;
        animation(enabled: boolean, duration: number): anychart.charts.Polar;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Polar;
    }
    interface Pert extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Pert;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Pert;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Pert;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Pert;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Pert;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Pert;
        cancelMarquee(): anychart.charts.Pert;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Pert;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Pert;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Pert;
        criticalPath(): anychart.core.pert.CriticalPath;
        criticalPath(settings?: Object): anychart.charts.Pert;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string, deps?: Array<anychart.data.Tree.Dependency>): anychart.charts.Pert;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Pert;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Pert;
        expectedTimeCalculator(): (()=>number);
        expectedTimeCalculator(durationFunction?: (()=>number)): anychart.charts.Pert;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Pert;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Pert;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Pert;
        horizontalSpacing(): string | number;
        horizontalSpacing(spacing?: number | string): anychart.charts.Pert;
        id(): string;
        id(id?: string): anychart.charts.Pert;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Pert;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Pert;
        left(): number | string;
        left(value?: number | string): anychart.charts.Pert;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Pert;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pert;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Pert;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Pert;
        milestones(): anychart.core.pert.Milestones;
        milestones(settings?: Object): anychart.charts.Pert;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Pert;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Pert;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Pert;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Pert;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pert;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Pert;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Pert;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Pert;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pert;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pert;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pert;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pert;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Pert;
        tasks(): anychart.core.pert.Tasks;
        tasks(settings?: Object): anychart.charts.Pert;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Pert;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        top(): number | string;
        top(top?: number | string): anychart.charts.Pert;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalSpacing(): string | number;
        verticalSpacing(settings?: number | string): anychart.charts.Pert;
        width(): number | string;
        width(width?: number | string): anychart.charts.Pert;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Pert;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Pert;
        animation(enabled: boolean, duration: number): anychart.charts.Pert;
        getSelectedPoints(): Array<anychart.core.Point>;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Pert;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Pert;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Pert;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Pert;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Pert;
    }
    interface Scatter extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Scatter;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.scatter.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Scatter;
        animation(enabled: boolean, duration: number): anychart.charts.Scatter;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Scatter;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Scatter;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Scatter;
        baseline(): number;
        baseline(value?: number): anychart.charts.Scatter;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Scatter;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Scatter;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Scatter;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Bubble;
        cancelMarquee(): anychart.charts.Scatter;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Scatter;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Scatter;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Scatter;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Scatter;
        crossing(): anychart.core.utils.Crossing;
        crossing(settings?: Object): anychart.charts.Scatter;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.charts.Scatter;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Scatter;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Scatter;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Scatter;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Scatter;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Scatter;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.scatter.series.Base;
        getSeriesAt(index: number): anychart.core.scatter.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXScales(): Array<any>;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Scatter;
        height(): number | string;
        height(height?: number | string): anychart.charts.Scatter;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Scatter;
        id(): string;
        id(id?: string): anychart.charts.Scatter;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Scatter;
        isFullScreenAvailable(): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.charts.Scatter;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Scatter;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Scatter;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Scatter;
        left(): number | string;
        left(value?: number | string): anychart.charts.Scatter;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Scatter;
        line(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Scatter;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Scatter;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Scatter;
        marker(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Scatter;
        maxBubbleSize(): number | string;
        maxBubbleSize(size?: number | string): anychart.charts.Scatter;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Scatter;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Scatter;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Scatter;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Scatter;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Scatter;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Scatter;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Scatter;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Scatter;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Scatter;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Scatter;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Scatter;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Scatter;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        quarters(): anychart.core.utils.QuarterSettings;
        quarters(settings?: Object): anychart.charts.Scatter;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Scatter;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Scatter;
        removeSeries(id: number | string): anychart.charts.Scatter;
        removeSeriesAt(index: number): anychart.charts.Scatter;
        right(): number | string;
        right(value?: number | string): anychart.charts.Scatter;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Scatter;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Scatter;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Scatter;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Scatter;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Scatter;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Scatter;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Scatter;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Scatter;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Scatter;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Scatter;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Scatter;
        top(): number | string;
        top(top?: number | string): anychart.charts.Scatter;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Scatter;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.Scatter;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(settings?: Object | boolean): anychart.charts.Scatter;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Scatter;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        xScale(): anychart.scales.ScatterBase;
        xScale(settings?: Object | string | anychart.scales.ScatterBase): anychart.charts.Scatter;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.Scatter;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(settings?: Object | boolean): anychart.charts.Scatter;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Scatter;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Scatter;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: Object | string | anychart.scales.ScatterBase): anychart.charts.Scatter;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Scatter;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Scatter;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Scatter;
    }
    interface Pareto extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Pareto;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Pareto;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Pareto;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Pareto;
        barGroupsPadding(): number;
        barGroupsPadding(padding?: number): anychart.charts.Pareto;
        barsPadding(): number;
        barsPadding(padding?: number): anychart.charts.Pareto;
        baseline(): number;
        baseline(value?: number): anychart.charts.Pareto;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Pareto;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Pareto;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Pareto;
        cancelMarquee(): anychart.charts.Pareto;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Pareto;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Pareto;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Pareto;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | anychart.data.DataSettings | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Pareto;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.charts.Pareto;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Pareto;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Pareto;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Pareto;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Pareto;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Pareto;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSeries(id: number | string): anychart.core.cartesian.series.Base;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pareto;
        height(): number | string;
        height(height?: number | string): anychart.charts.Pareto;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Pareto;
        id(): string;
        id(id?: string): anychart.charts.Pareto;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.charts.Pareto;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Pareto;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Pareto;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Pareto;
        left(): number | string;
        left(value?: number | string): anychart.charts.Pareto;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Pareto;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Pareto;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Pareto;
        maxBubbleSize(): number | string;
        maxBubbleSize(size?: number | string): anychart.charts.Pareto;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Pareto;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.charts.Pareto;
        minBubbleSize(): number | string;
        minBubbleSize(size?: number | string): anychart.charts.Pareto;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Pareto;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.charts.Pareto;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Pareto;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Pareto;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pareto;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.charts.Pareto;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Pareto;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        removeAllSeries(): anychart.charts.Pareto;
        removeSeries(id: number | string): anychart.charts.Pareto;
        removeSeriesAt(index: number): anychart.charts.Pareto;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Pareto;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Pareto;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pareto;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pareto;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pareto;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pareto;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Pareto;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Pareto;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Pareto;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Pareto;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Pareto;
        top(): number | string;
        top(top?: number | string): anychart.charts.Pareto;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Pareto;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.Pareto;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(settings?: Object | boolean): anychart.charts.Pareto;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Pareto;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        xScale(): anychart.scales.Base;
        xScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Pareto;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(settings?: Object | boolean): anychart.charts.Pareto;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(settings?: number | boolean | Object): anychart.charts.Pareto;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.Pareto;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(settings?: Object | boolean): anychart.charts.Pareto;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Pareto;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Pareto;
        yScale(): anychart.scales.Base;
        yScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Pareto;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(settings?: Object | boolean): anychart.charts.Pareto;
        yZoom(): anychart.core.utils.OrdinalZoom;
        yZoom(settings?: number | boolean | Object): anychart.charts.Pareto;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Pareto;
        animation(enabled: boolean, duration: number): anychart.charts.Pareto;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Pareto;
        getSelectedPoints(): Array<anychart.core.Point>;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Pareto;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Pareto;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pareto;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.charts.Pareto;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.charts.Pareto;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.charts.Pareto;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.charts.Pareto;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Pareto;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pareto;
        right(): number | string;
        right(right?: number | string): anychart.charts.Pareto;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Pareto;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Pareto;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Pareto;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
    }
    interface Venn extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Venn;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Venn;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Venn;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Venn;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Venn;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Venn;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Venn;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Venn;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Venn;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: {[prop:string]:string|boolean}): anychart.charts.Venn;
        dataSeparator(): string;
        dataSeparator(separator?: string): anychart.charts.Venn;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Venn;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Venn;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Venn;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Venn;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.Venn;
        fill(color: string, opacity?: number): anychart.charts.Venn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Venn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Venn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Venn;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Venn;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Venn;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.Venn;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Venn;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Venn;
        hatchFill(enabled?: boolean): anychart.charts.Venn;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Venn;
        height(): number | string;
        height(height?: number | string): anychart.charts.Venn;
        hover(): anychart.charts.Venn;
        hover(index?: number): anychart.charts.Venn;
        hover(indexes?: Array<number>): anychart.charts.Venn;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.charts.Venn;
        id(): string;
        id(id?: string): anychart.charts.Venn;
        intersections(): anychart.core.venn.Intersections;
        intersections(settings?: Object): anychart.charts.Venn;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Venn;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Venn;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Venn;
        left(): number | string;
        left(value?: number | string): anychart.charts.Venn;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Venn;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Venn;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Venn;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Venn;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.charts.Venn;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Venn;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Venn;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Venn;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Venn;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Venn;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Venn;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Venn;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Venn;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Venn;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Venn;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        select(index?: number): anychart.charts.Venn;
        select(indexes?: number | Array<number>): anychart.charts.Venn;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Venn;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.Venn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Venn;
        stroke(settings?: Object): anychart.charts.Venn;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Venn;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Venn;
        top(): number | string;
        top(top?: number | string): anychart.charts.Venn;
        unhover(indexOrIndexes?: number | Array<number>): anychart.charts.Venn;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Venn;
        unselect(index?: number): anychart.charts.Venn;
        unselect(indexes?: Array<number>): anychart.charts.Venn;
        width(): number | string;
        width(width?: number | string): anychart.charts.Venn;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Venn;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Venn;
        animation(enabled: boolean, duration: number): anychart.charts.Venn;
        cancelMarquee(): anychart.charts.Venn;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Venn;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Venn;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Venn;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Venn;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Venn;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Venn;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Venn;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Venn;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Venn;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Venn;
    }
    interface Waterfall extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Waterfall;
        addArrow(settings?: Object): anychart.core.waterfall.Arrow;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        addTotal(config: anychart.core.waterfall.TotalConfig): anychart.core.waterfall.Total;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Waterfall;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Waterfall;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Waterfall;
        barGroupsPadding(): number;
        barGroupsPadding(padding?: number): anychart.charts.Waterfall;
        baseline(): number;
        baseline(value?: number): anychart.charts.Waterfall;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Waterfall;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Waterfall;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Waterfall;
        cancelMarquee(): anychart.charts.Waterfall;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Waterfall;
        connectorStroke(settings?: Object): anychart.charts.Waterfall;
        connectors(): anychart.core.waterfall.Connectors;
        connectors(settings?: Object): anychart.charts.Waterfall;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Waterfall;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Waterfall;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Waterfall;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Waterfall;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Waterfall;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.charts.Waterfall;
        dataMode(): string;
        dataMode(mode?: string): anychart.charts.Waterfall;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Waterfall;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Waterfall;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Waterfall;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Waterfall;
        getAllArrows(): Array<anychart.core.waterfall.Arrow>;
        getAllTotals(): Array<anychart.core.waterfall.Total>;
        getArrow(settings?: number): anychart.core.waterfall.Arrow;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSeries(id: number | string): anychart.core.waterfall.series.Waterfall;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getTotalAt(index: number): anychart.charts.Waterfall;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Waterfall;
        height(): number | string;
        height(height?: number | string): anychart.charts.Waterfall;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Waterfall;
        id(): string;
        id(id?: string): anychart.charts.Waterfall;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Waterfall;
        isFullScreenAvailable(): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.charts.Waterfall;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Waterfall;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Waterfall;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Waterfall;
        left(): number | string;
        left(value?: number | string): anychart.charts.Waterfall;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Waterfall;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Waterfall;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Waterfall;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Waterfall;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Waterfall;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Waterfall;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Waterfall;
        maxPointWidth(): string | number;
        maxPointWidth(settings?: number | string): anychart.charts.Waterfall;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Waterfall;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Waterfall;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Waterfall;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.charts.Waterfall;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Waterfall;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Waterfall;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Waterfall;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Waterfall;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Waterfall;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Waterfall;
        pointWidth(): string | number;
        pointWidth(settings?: number | string): anychart.charts.Waterfall;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Waterfall;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Waterfall;
        removeArrow(Arrow: anychart.core.waterfall.Arrow): boolean;
        removeArrowAt(Arrow: number): boolean;
        removeSeries(id: number | string): anychart.charts.Waterfall;
        removeSeriesAt(index: number): anychart.charts.Waterfall;
        removeTotal(total: anychart.core.waterfall.Total): anychart.charts.Waterfall;
        removeTotalAt(index: number): anychart.charts.Waterfall;
        right(): number | string;
        right(right?: number | string): anychart.charts.Waterfall;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Waterfall;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Waterfall;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Waterfall;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Waterfall;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Waterfall;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Waterfall;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Waterfall;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        splitTotal(splits: Array<anychart.core.waterfall.SplitConfig>): anychart.charts.Waterfall;
        splitTotal(): Array<anychart.core.waterfall.SplitConfig>;
        stackLabels(): anychart.core.ui.LabelsFactory;
        stackLabels(settings?: Object | boolean): anychart.charts.Waterfall;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Waterfall;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Waterfall;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Waterfall;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Waterfall;
        top(): number | string;
        top(top?: number | string): anychart.charts.Waterfall;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        waterfall(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.waterfall.series.Waterfall;
        width(): number | string;
        width(width?: number | string): anychart.charts.Waterfall;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.Waterfall;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(settings?: Object | boolean): anychart.charts.Waterfall;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Waterfall;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Waterfall;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(settings?: Object | boolean): anychart.charts.Waterfall;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(settings?: number | boolean | Object): anychart.charts.Waterfall;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.Waterfall;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(settings?: Object | boolean): anychart.charts.Waterfall;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Waterfall;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Waterfall;
        yScale(): anychart.scales.Linear;
        yScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Waterfall;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(settings?: Object | boolean): anychart.charts.Waterfall;
        yZoom(): anychart.core.utils.OrdinalZoom;
        yZoom(settings?: number | boolean | Object): anychart.charts.Waterfall;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Waterfall;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Waterfall;
        animation(enabled: boolean, duration: number): anychart.charts.Waterfall;
        getSelectedPoints(): Array<anychart.core.Point>;
        inMarquee(): boolean;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Waterfall;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Waterfall;
    }
    interface TagCloud extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.TagCloud;
        angles(): Array<number>;
        angles(anglesList?: Array<number>): anychart.charts.TagCloud;
        anglesCount(): number;
        anglesCount(count?: number): anychart.charts.TagCloud;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.TagCloud;
        animation(enabled: boolean, duration: number): anychart.charts.TagCloud;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.TagCloud;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.TagCloud;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.TagCloud;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.TagCloud;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.TagCloud;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(settings?: Object | boolean): anychart.charts.TagCloud;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.charts.TagCloud;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.TagCloud;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.TagCloud;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.TagCloud;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | anychart.data.DataSettings | string, settings?: string | anychart.data.TextParsingSettings): anychart.charts.TagCloud;
        dispose(): void;
        draw(async?: boolean): anychart.charts.TagCloud;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.TagCloud;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.TagCloud;
        fromAngle(): number;
        fromAngle(angle?: number): anychart.charts.TagCloud;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.TagCloud;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getPoint(index: number): anychart.core.Point;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.TagCloud;
        hover(index: number | Array<number>): anychart.charts.TagCloud;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.TagCloud;
        id(): string;
        id(id?: string): anychart.charts.TagCloud;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.TagCloud;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.TagCloud;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.TagCloud;
        left(): number | string;
        left(value?: number | string): anychart.charts.TagCloud;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.TagCloud;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.TagCloud;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.TagCloud;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.TagCloud;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.TagCloud;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.TagCloud;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.TagCloud;
        mode(): string;
        mode(mode?: string): anychart.charts.TagCloud;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.TagCloud;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.TagCloud;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.TagCloud;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.TagCloud;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.TagCloud;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.TagCloud;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        scale(): anychart.scales.Base;
        scale(settings?: string | anychart.scales.Base | Object): anychart.charts.TagCloud;
        select(index?: number): anychart.charts.TagCloud;
        select(indexes?: Array<number>): anychart.charts.TagCloud;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.TagCloud;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        textSpacing(): number;
        textSpacing(spacing?: number): anychart.charts.TagCloud;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.TagCloud;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toAngle(): number;
        toAngle(angle?: number): anychart.charts.TagCloud;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.TagCloud;
        top(): number | string;
        top(top?: number | string): anychart.charts.TagCloud;
        unhover(): anychart.charts.TagCloud;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(indexOrIndexes?: number | Array<number>): void;
        width(): number | string;
        width(width?: number | string): anychart.charts.TagCloud;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.TagCloud;
        cancelMarquee(): anychart.charts.TagCloud;
        inMarquee(): boolean;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.TagCloud;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.TagCloud;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TagCloud;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TagCloud;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TagCloud;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.TagCloud;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.TagCloud;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.TagCloud;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.TagCloud;
    }
    interface Cartesian3d extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Cartesian3d;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Cartesian3d;
        animation(enabled: boolean, duration: number): anychart.charts.Cartesian3d;
        area(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Area3d;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Cartesian3d;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Cartesian3d;
        bar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bar3d;
        barGroupsPadding(): number;
        barGroupsPadding(padding?: number): anychart.charts.Cartesian3d;
        barsPadding(): number;
        barsPadding(padding?: number): anychart.charts.Cartesian3d;
        baseline(): number;
        baseline(value?: number): anychart.charts.Cartesian3d;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Cartesian3d;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Cartesian3d;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Cartesian3d;
        cancelMarquee(): anychart.charts.Cartesian3d;
        column(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Column3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Cartesian3d;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Cartesian3d;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Cartesian3d;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Cartesian3d;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | Array<any> | anychart.data.DataSettings | Object): anychart.charts.Cartesian3d;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Cartesian3d;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Cartesian3d;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Cartesian3d;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Cartesian3d;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Cartesian3d;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.cartesian.series.Base;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXAxesCount(): number;
        getXScales(): Array<any>;
        getYAxesCount(): number;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Cartesian3d;
        height(): number | string;
        height(height?: number | string): anychart.charts.Cartesian3d;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Cartesian3d;
        id(): string;
        id(id?: string): anychart.charts.Cartesian3d;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Cartesian3d;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Cartesian3d;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Cartesian3d;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Cartesian3d;
        left(): number | string;
        left(value?: number | string): anychart.charts.Cartesian3d;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Cartesian3d;
        line(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line3d;
        line2d(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Cartesian3d;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Cartesian3d;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian3d;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Cartesian3d;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Cartesian3d;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.charts.Cartesian3d;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Cartesian3d;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Cartesian3d;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Cartesian3d;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.charts.Cartesian3d;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Cartesian3d;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Cartesian3d;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Cartesian3d;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Cartesian3d;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian3d;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Cartesian3d;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.charts.Cartesian3d;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Cartesian3d;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Cartesian3d;
        removeSeries(id: number | string): anychart.charts.Cartesian3d;
        removeSeriesAt(index: number): anychart.charts.Cartesian3d;
        right(): number | string;
        right(right?: number | string): anychart.charts.Cartesian3d;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Cartesian3d;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Cartesian3d;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Cartesian3d;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Cartesian3d;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Cartesian3d;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Cartesian3d;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Cartesian3d;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Cartesian3d;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Cartesian3d;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Cartesian3d;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Cartesian3d;
        top(): number | string;
        top(top?: number | string): anychart.charts.Cartesian3d;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Cartesian3d;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.Cartesian3d;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(settings?: Object | boolean): anychart.charts.Cartesian3d;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        xMinorGrid(index?: number): anychart.core.grids.Linear;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Cartesian3d;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Cartesian3d;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(settings?: Object | boolean): anychart.charts.Cartesian3d;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(settings?: number | boolean | Object): anychart.charts.Cartesian3d;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.Cartesian3d;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(settings?: Object | boolean): anychart.charts.Cartesian3d;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        yMinorGrid(index?: number): anychart.core.grids.Linear;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Cartesian3d;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Cartesian3d;
        yScale(): anychart.scales.Linear;
        yScale(value?: Object | string | anychart.scales.Base): anychart.charts.Cartesian3d;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(settings?: Object | boolean): anychart.charts.Cartesian3d;
        yZoom(): anychart.core.utils.OrdinalZoom;
        yZoom(settings?: number | boolean | Object): anychart.charts.Cartesian3d;
        zAngle(): number;
        zAngle(angle?: number): anychart.charts.Cartesian3d;
        zAspect(): number | string;
        zAspect(value?: number | string): anychart.charts.Cartesian3d;
        zDepth(): number;
        zDepth(value?: number): anychart.charts.Cartesian3d;
        zDistribution(): boolean;
        zDistribution(enabled?: boolean): anychart.charts.Cartesian3d;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Cartesian3d;
        zPadding(): number;
        zPadding(padding?: number): anychart.charts.Cartesian3d;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Cartesian3d;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Cartesian3d;
    }
    interface Stock extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Stock;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Stock;
        animation(enabled: boolean, duration: number): anychart.charts.Stock;
        annotations(): anychart.core.annotations.ChartController;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Stock;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Stock;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Stock;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Stock;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Stock;
        cancelMarquee(): anychart.charts.Stock;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Stock;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Stock;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Stock;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Stock;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Stock;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Stock;
        eventMarkers(): anychart.core.stock.eventMarkers.Controller;
        eventMarkers(settings?: Object | boolean): anychart.charts.Stock;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Stock;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Stock;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotsCount(): number;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSelectedRange(): anychart.charts.Stock.SelectedRange;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        grouping(): anychart.core.stock.Grouping;
        grouping(settings?: boolean | Array<string|anychart.core.stock.Grouping.Level> | Object): anychart.charts.Stock;
        height(): number | string;
        height(height?: number | string): anychart.charts.Stock;
        id(): string;
        id(id?: string): anychart.charts.Stock;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.StockInteractivity;
        interactivity(settings?: Object | string): anychart.core.SeparateChart;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Stock;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Stock;
        left(): number | string;
        left(value?: number | string): anychart.charts.Stock;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Stock;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Stock;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Stock;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Stock;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Stock;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Stock;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Stock;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Stock;
        plot(index?: number): anychart.core.stock.Plot;
        plot(settings?: Object | boolean): anychart.charts.Stock;
        plot(index?: number, settings?: Object | boolean): anychart.charts.Stock;
        plotsManualBounds(): boolean;
        plotsManualBounds(value: boolean): anychart.charts.Stock;
        preserveSelectedRangeOnDataUpdate(): boolean;
        preserveSelectedRangeOnDataUpdate(enabled?: boolean): anychart.charts.Stock;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.charts.Stock;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        scroller(): anychart.core.stock.Scroller;
        scroller(settings?: Object | boolean): anychart.charts.Stock;
        scrollerGrouping(): anychart.core.stock.Grouping;
        scrollerGrouping(value?: boolean | Array<string|anychart.core.stock.Grouping.Level> | Object): anychart.charts.Stock;
        selectRange(start: number | string | Date, end?: number | string | Date): anychart.charts.Stock;
        selectRange(start: number | string | Date, end?: number | string | Date, dispatchEvent?: boolean): anychart.charts.Stock;
        selectRange(type: string, count?: number, dispatchEvent?: boolean): anychart.charts.Stock;
        selectRange(unit: string, count?: number, anchor?: string, dispatchEvent?: boolean): anychart.charts.Stock;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Stock;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Stock;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Stock;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Stock;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Stock;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Stock;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        splitters(): anychart.core.stock.splitters.Settings;
        splitters(settings?: boolean | Object): anychart.charts.Stock;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Stock;
        startZoomMarquee(repeat?: boolean, asRect?: boolean): anychart.charts.Stock;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Stock;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Stock;
        top(): number | string;
        top(top?: number | string): anychart.charts.Stock;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Stock;
        xScale(): anychart.scales.StockScatterDateTime;
        xScale(settings?: string | Object): anychart.charts.Stock;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Stock;
        zoomMarqueeFill(): anychart.graphics.vector.Fill;
        zoomMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Stock;
        zoomMarqueeFill(color: string, opacity?: number): anychart.charts.Stock;
        zoomMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Stock;
        zoomMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Stock;
        zoomMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Stock;
        zoomMarqueeStroke(): anychart.graphics.vector.Stroke;
        zoomMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Stock;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Stock;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Stock;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Stock;
    }
    namespace Stock {
    type SelectedRange = {
        firstSelected: number;
        firstVisible: number;
        lastSelected: number;
        lastVisible: number;
    }
    }
    interface Resource extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Resource;
        activities(): anychart.core.resource.Activities;
        activities(settings?: Object): anychart.charts.Resource;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Resource;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Resource;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Resource;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Resource;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Resource;
        calendar(): anychart.scales.Calendar;
        calendar(settings?: Object): anychart.charts.Resource;
        cancelMarquee(): anychart.charts.Resource;
        cellPadding(): anychart.core.utils.Padding;
        cellPadding(padding?: Array<number|string> | Object): anychart.charts.Resource;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Resource;
        conflicts(): anychart.core.resource.Conflicts;
        conflicts(settings?: Object): anychart.charts.Resource;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Resource;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Resource;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Resource;
        currentStartDate(): Date | number | string;
        currentStartDate(date: Date | number | string): anychart.charts.Resource;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Resource;
        defaultMinutesPerDay(): number;
        defaultMinutesPerDay(minutes?: number): anychart.charts.Resource;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Resource;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Resource;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Resource;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Resource;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        grid(): anychart.core.resource.Grid;
        grid(settings?: Object | boolean): anychart.charts.Resource;
        height(): number | string;
        height(height?: number | string): anychart.charts.Resource;
        horizontalScrollBar(): anychart.core.ui.Scroller;
        horizontalScrollBar(settings?: Object | boolean): anychart.charts.Resource;
        hover(resourceIndex: number, activityIndex: number): anychart.charts.Resource;
        hoverPoint(globalIndex: number): anychart.charts.Resource;
        id(): string;
        id(id?: string): anychart.charts.Resource;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Resource;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Resource;
        left(): number | string;
        left(value?: number | string): anychart.charts.Resource;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        logo(): anychart.core.resource.Logo;
        logo(settings?: Object): anychart.charts.Resource;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Resource;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): void;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Resource;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Resource;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Resource;
        minRowHeight(): number;
        minRowHeight(height?: number): anychart.charts.Resource;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Resource;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Resource;
        overlay(): anychart.core.gantt.Overlay;
        overlay(settings?: Object | boolean): anychart.charts.Resource;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Resource;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Resource;
        pixPerHour(): number;
        pixPerHour(height?: number): anychart.charts.Resource;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        resourceList(): anychart.core.resource.ResourceList;
        resourceList(settings?: Object | boolean): anychart.charts.Resource;
        resourceListWidth(): number | string;
        resourceListWidth(width?: number | string): anychart.charts.Resource;
        right(): number | string;
        right(right?: number | string): anychart.charts.Resource;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        select(resourceIndex: number, activityIndex: number): anychart.charts.Resource;
        selectPoint(globalIndex: number, event?: anychart.core.MouseEvent): anychart.charts.Resource;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Resource;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Resource;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Resource;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Resource;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Resource;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Resource;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        splitterStroke(): anychart.graphics.vector.Stroke;
        splitterStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Resource;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Resource;
        timeLine(): anychart.core.gantt.TimeLineHeader;
        timeLine(settings?: Object | boolean): anychart.charts.Resource;
        timeLineHeight(): number | string;
        timeLineHeight(height?: number | string): anychart.charts.Resource;
        timeTrackingMode(): string;
        timeTrackingMode(mode?: string): anychart.charts.Resource;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Resource;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Resource;
        top(): number | string;
        top(top?: number | string): anychart.charts.Resource;
        unhover(resourceIndex?: number | Array<number>, activityIndex?: number): anychart.charts.Resource;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(resourceIndex?: number | Array<number>, activityIndex?: number): void;
        verticalScrollBar(): anychart.core.ui.Scroller;
        verticalScrollBar(settings?: Object | boolean): anychart.charts.Resource;
        width(): number | string;
        width(width?: number | string): anychart.charts.Resource;
        xScale(): anychart.scales.DateTimeWithCalendar;
        xScale(settings?: Object): anychart.charts.Resource;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Resource;
        zoomLevel(): number | string;
        zoomLevel(indexOrId?: number | string): anychart.charts.Resource;
        zoomLevels(): Array<anychart.charts.Resource.ZoomLevel>;
        zoomLevels(levelsSettings?: Array<anychart.charts.Resource.ZoomLevel>): anychart.charts.Resource;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Resource;
        animation(enabled: boolean, duration: number): anychart.charts.Resource;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Resource;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Resource;
    }
    namespace Resource {
    type ZoomLevel = {
        count: number;
        id: string;
        levels: Array<anychart.core.gantt.TimeLineHeader.LevelWrapper>;
        unit: string;
        unitPixSize: number;
    }
    }
    interface Wordtree extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Wordtree;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Wordtree;
        animation(enabled: boolean, duration: number): anychart.charts.Wordtree;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Wordtree;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Wordtree;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Wordtree;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Wordtree;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Wordtree;
        cancelMarquee(): anychart.charts.Wordtree;
        connectors(): anychart.core.wordtree.Connectors;
        connectors(settings?: Object): anychart.charts.Wordtree;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Wordtree;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Wordtree;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Wordtree;
        data(): anychart.data.Tree;
        data(data?: string | Array<Array<string>|string|anychart.data.Tree>): anychart.charts.Wordtree;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Wordtree;
        drillTo(Target: anychart.data.Tree.DataItem | string): void;
        drillUp(): anychart.charts.Wordtree;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Wordtree;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Wordtree;
        fontColor(): string;
        fontColor(color?: string): anychart.charts.Wordtree;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.charts.Wordtree;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.charts.Wordtree;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.charts.Wordtree;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(style?: string | anychart.graphics.vector.Text.FontStyle): anychart.charts.Wordtree;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.charts.Wordtree;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Wordtree;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Wordtree;
        id(): string;
        id(id?: string): anychart.charts.Wordtree;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Wordtree;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Wordtree;
        left(): number | string;
        left(value?: number | string): anychart.charts.Wordtree;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Wordtree;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Wordtree;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.charts.Wordtree;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Wordtree;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Wordtree;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.charts.Wordtree;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Wordtree;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Wordtree;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Wordtree;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Wordtree;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Wordtree;
        postfix(): string;
        postfix(text?: string): anychart.charts.Wordtree;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Wordtree;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Wordtree;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Wordtree;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Wordtree;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Wordtree;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Wordtree;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Wordtree;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Wordtree;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Wordtree;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Wordtree;
        top(): number | string;
        top(top?: number | string): anychart.charts.Wordtree;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Wordtree;
        word(): string;
        word(word?: string): anychart.charts.Wordtree;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Wordtree;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Wordtree;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Wordtree;
    }
    interface Sparkline extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Sparkline;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Sparkline;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Sparkline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Sparkline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Sparkline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Sparkline;
        clip(): boolean | anychart.math.Rect;
        clip(value?: anychart.math.Rect): anychart.charts.Sparkline;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.charts.Sparkline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Sparkline;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Sparkline;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Sparkline;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Sparkline;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Sparkline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Sparkline;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Sparkline;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sparkline;
        fill(color: string, opacity?: number): anychart.charts.Sparkline;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstFill(): anychart.graphics.vector.Fill;
        firstFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sparkline;
        firstFill(color: string, opacity?: number): anychart.charts.Sparkline;
        firstFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        firstFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        firstFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        firstHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        firstHatchFill(hatchFillFunction?: (() => void)): anychart.charts.Sparkline;
        firstHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sparkline;
        firstHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sparkline;
        firstHatchFill(enabled?: boolean): anychart.charts.Sparkline;
        firstLabels(): anychart.core.ui.LabelsFactory.Label;
        firstLabels(settings?: Object | boolean): anychart.charts.Sparkline;
        firstMarkers(): anychart.core.ui.MarkersFactory.Marker;
        firstMarkers(settings?: Object | boolean): anychart.charts.Sparkline;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Sparkline;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.Sparkline;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sparkline;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sparkline;
        hatchFill(enabled?: boolean): anychart.charts.Sparkline;
        height(): number | string;
        height(height?: number | string): anychart.charts.Sparkline;
        id(): string;
        id(id?: string): anychart.charts.Sparkline;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Sparkline;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Sparkline;
        labels(): anychart.core.ui.LabelsFactory.Label;
        labels(settings?: Object | boolean): anychart.charts.Sparkline;
        lastFill(): anychart.graphics.vector.Fill;
        lastFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sparkline;
        lastFill(color: string, opacity?: number): anychart.charts.Sparkline;
        lastFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        lastFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        lastFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        lastHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        lastHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        lastHatchFill(hatchFillFunction?: (() => void)): anychart.charts.Sparkline;
        lastHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sparkline;
        lastHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sparkline;
        lastHatchFill(enabled?: boolean): anychart.charts.Sparkline;
        lastLabels(): anychart.core.ui.LabelsFactory.Label;
        lastLabels(settings?: Object | boolean): anychart.charts.Sparkline;
        lastMarkers(): anychart.core.ui.MarkersFactory.Marker;
        lastMarkers(settings?: Object | boolean): anychart.charts.Sparkline;
        left(): number | string;
        left(value?: number | string): anychart.charts.Sparkline;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Sparkline;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Sparkline;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Sparkline;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Sparkline;
        markers(): anychart.core.ui.MarkersFactory.Marker;
        markers(settings?: Object | boolean): anychart.charts.Sparkline;
        maxFill(): anychart.graphics.vector.Fill;
        maxFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sparkline;
        maxFill(color: string, opacity?: number): anychart.charts.Sparkline;
        maxFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        maxFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        maxFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        maxHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        maxHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        maxHatchFill(hatchFillFunction?: (() => void)): anychart.charts.Sparkline;
        maxHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sparkline;
        maxHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sparkline;
        maxHatchFill(enabled?: boolean): anychart.charts.Sparkline;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Sparkline;
        maxLabels(): anychart.core.ui.LabelsFactory.Label;
        maxLabels(settings?: Object | boolean): anychart.charts.Sparkline;
        maxMarkers(): anychart.core.ui.MarkersFactory.Marker;
        maxMarkers(settings?: Object | boolean): anychart.charts.Sparkline;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Sparkline;
        minFill(): anychart.graphics.vector.Fill;
        minFill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.charts.Sparkline;
        minFill(color: string, opacity?: number): anychart.charts.Sparkline;
        minFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        minFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        minFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        minHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        minHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        minHatchFill(hatchFillFunction?: (() => void)): anychart.charts.Sparkline;
        minHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sparkline;
        minHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sparkline;
        minHatchFill(enabled?: boolean): anychart.charts.Sparkline;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Sparkline;
        minLabels(): anychart.core.ui.LabelsFactory.Label;
        minLabels(settings?: Object | boolean): anychart.charts.Sparkline;
        minMarkers(): anychart.core.ui.MarkersFactory.Marker;
        minMarkers(settings?: Object | boolean): anychart.charts.Sparkline;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Sparkline;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sparkline;
        negativeFill(color: string, opacity?: number): anychart.charts.Sparkline;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        negativeHatchFill(hatchFillFunction?: (() => void)): anychart.charts.Sparkline;
        negativeHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Sparkline;
        negativeHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Sparkline;
        negativeHatchFill(enabled?: boolean): anychart.charts.Sparkline;
        negativeLabels(): anychart.core.ui.LabelsFactory.Label;
        negativeLabels(settings?: Object | boolean): anychart.charts.Sparkline;
        negativeMarkers(): anychart.core.ui.MarkersFactory.Marker;
        negativeMarkers(settings?: Object | boolean): anychart.charts.Sparkline;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Sparkline;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Sparkline;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Sparkline;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.charts.Sparkline;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Sparkline;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Sparkline;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.charts.Sparkline;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        seriesType(): string;
        seriesType(type?: string): anychart.charts.Sparkline;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.Sparkline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Sparkline;
        stroke(settings?: Object): anychart.charts.Sparkline;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Sparkline;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Sparkline;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Sparkline;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Sparkline;
        top(): number | string;
        top(top?: number | string): anychart.charts.Sparkline;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Sparkline;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: string | anychart.scales.Base | Object): anychart.charts.Sparkline;
        yScale(): anychart.scales.Base;
        yScale(settings?: string | anychart.scales.Base | Object): anychart.charts.Sparkline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Sparkline;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Sparkline;
        animation(enabled: boolean, duration: number): anychart.charts.Sparkline;
        cancelMarquee(): anychart.charts.Sparkline;
        getSelectedPoints(): Array<anychart.core.Point>;
        inMarquee(): boolean;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sparkline;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Sparkline;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Sparkline;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Sparkline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Sparkline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Sparkline;
    }
    interface Radar extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Radar;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.radar.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Radar;
        animation(enabled: boolean, duration: number): anychart.charts.Radar;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Area;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Radar;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Radar;
        baseline(): number;
        baseline(value?: number): anychart.charts.Radar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Radar;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Radar;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Radar;
        cancelMarquee(): anychart.charts.Radar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Radar;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Radar;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Radar;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Radar;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Radar;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Radar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Radar;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Radar;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Radar;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.radar.series.Base;
        getSeriesAt(index: number): anychart.core.radar.series.Base;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXScales(): Array<any>;
        getYScales(): Array<any>;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Radar;
        height(): number | string;
        height(height?: number | string): anychart.charts.Radar;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Radar;
        id(): string;
        id(id?: string): anychart.charts.Radar;
        inMarquee(): boolean;
        innerRadius(): number | string;
        innerRadius(radius?: number | string): anychart.charts.Radar;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Radar;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Radar;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Radar;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Radar;
        left(): number | string;
        left(value?: number | string): anychart.charts.Radar;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Radar;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Line;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Radar;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): void;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Radar;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Radar;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Radar;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Radar;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Radar;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Radar;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Radar;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Radar;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Radar;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Radar;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Radar;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Radar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Radar;
        removeSeries(id: number | string): anychart.charts.Radar;
        removeSeriesAt(index: number): anychart.charts.Radar;
        right(): number | string;
        right(right?: number | string): anychart.charts.Radar;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Radar;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Radar;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Radar;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Radar;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Radar;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Radar;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Radar;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.charts.Radar;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Radar;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Radar;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Radar;
        top(): number | string;
        top(top?: number | string): anychart.charts.Radar;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Radar;
        xAxis(): anychart.core.axes.Radar;
        xAxis(settings?: Object | boolean): anychart.charts.Radar;
        xGrid(index?: number): anychart.core.grids.Radar;
        xGrid(settings?: Object | boolean): anychart.charts.Radar;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.Radar;
        xMinorGrid(index?: number): anychart.core.grids.Radar;
        xMinorGrid(settings?: Object | boolean): anychart.charts.Radar;
        xMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Radar;
        xScale(): anychart.scales.Ordinal;
        xScale(scale?: anychart.scales.Ordinal): anychart.charts.Radar;
        yAxis(): anychart.core.axes.Radar;
        yAxis(settings?: Object | boolean): anychart.charts.Radar;
        yGrid(index?: number): anychart.core.grids.Radar;
        yGrid(settings?: Object | boolean): anychart.charts.Radar;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.Radar;
        yMinorGrid(index?: number): anychart.core.grids.Radar;
        yMinorGrid(settings?: Object | boolean): anychart.charts.Radar;
        yMinorGrid(index?: number, settings?: Object | boolean): anychart.charts.Radar;
        yScale(): anychart.scales.Linear;
        yScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Radar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Radar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Radar;
    }
    interface LinearGauge extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.LinearGauge;
        addPointer(...var_args: (number | Array<any> | anychart.data.Set | anychart.data.View)[]): Array<anychart.core.linearGauge.pointers.Base>;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.LinearGauge;
        axis(index?: number): anychart.core.axes.LinearGauge;
        axis(settings?: Object | boolean): anychart.charts.LinearGauge;
        axis(index?: number, settings?: Object | boolean): anychart.charts.LinearGauge;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.LinearGauge;
        bar(dataIndex: number): anychart.core.linearGauge.pointers.Bar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.LinearGauge;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.LinearGauge;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.LinearGauge;
        cancelMarquee(): anychart.charts.LinearGauge;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.LinearGauge;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.LinearGauge;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.LinearGauge;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
        defaultPointerType(): string;
        defaultPointerType(type?: string): anychart.charts.LinearGauge;
        dispose(): void;
        draw(async?: boolean): anychart.charts.LinearGauge;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.LinearGauge;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.LinearGauge;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.LinearGauge;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getPointer(id: number | string): anychart.core.linearGauge.pointers.Base;
        getPointerAt(index: number): anychart.core.linearGauge.pointers.Base;
        getPointersCount(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalOffset(): string | number;
        globalOffset(offset?: string | number): anychart.charts.LinearGauge;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.LinearGauge;
        height(): number | string;
        height(height?: number | string): anychart.charts.LinearGauge;
        id(): string;
        id(id?: string): anychart.charts.LinearGauge;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        isVertical(): boolean;
        isVertical(value?: boolean): anychart.charts.LinearGauge;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.LinearGauge;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.LinearGauge;
        layout(): string;
        layout(layout?: string): anychart.charts.LinearGauge;
        led(dataIndex: number): anychart.core.linearGauge.pointers.Led;
        left(): number | string;
        left(value?: number | string): anychart.charts.LinearGauge;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.LinearGauge;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.LinearGauge;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.LinearGauge;
        marker(dataIndex: number): anychart.core.linearGauge.pointers.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.LinearGauge;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.LinearGauge;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.LinearGauge;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.LinearGauge;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.LinearGauge;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.LinearGauge;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.LinearGauge;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.LinearGauge;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.LinearGauge;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeBar(dataIndex: number): anychart.core.linearGauge.pointers.RangeBar;
        removeAllListeners(type?: string): number;
        removeAllPointers(): anychart.charts.LinearGauge;
        removePointer(id: number | string): anychart.charts.LinearGauge;
        removePointerAt(index: number): anychart.charts.LinearGauge;
        right(): number | string;
        right(right?: number | string): anychart.charts.LinearGauge;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        scale(): anychart.scales.ScatterBase;
        scale(settings?: string | anychart.scales.ScatterBase | Object): anychart.charts.LinearGauge;
        scaleBar(index?: number): anychart.core.linearGauge.ScaleBar;
        scaleBar(settings?: Object | boolean): anychart.charts.LinearGauge;
        scaleBar(index?: number, settings?: Object | boolean): anychart.charts.LinearGauge;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.LinearGauge;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.LinearGauge;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.LinearGauge;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.LinearGauge;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.LinearGauge;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.LinearGauge;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.LinearGauge;
        tank(dataIndex: number): anychart.core.linearGauge.pointers.Tank;
        thermometer(dataIndex: number): anychart.core.linearGauge.pointers.Thermometer;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.LinearGauge;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.LinearGauge;
        top(): number | string;
        top(top?: number | string): anychart.charts.LinearGauge;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.LinearGauge;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.LinearGauge;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.LinearGauge;
        animation(enabled: boolean, duration: number): anychart.charts.LinearGauge;
        getStat(key?: string): any;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.LinearGauge;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.LinearGauge;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.LinearGauge;
    }
    interface HeatMap extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.HeatMap;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.HeatMap;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.HeatMap;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.HeatMap;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.HeatMap;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.HeatMap;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.HeatMap;
        cancelMarquee(): anychart.charts.HeatMap;
        colorScale(): anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.OrdinalColor | Object | string): anychart.charts.HeatMap;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.HeatMap;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.HeatMap;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.HeatMap;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.HeatMap;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.charts.HeatMap;
        dispose(): void;
        draw(async?: boolean): anychart.charts.HeatMap;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.HeatMap;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.HeatMap;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.HeatMap;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.HeatMap;
        fill(color: string, opacity?: number): anychart.charts.HeatMap;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.HeatMap;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.HeatMap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.HeatMap;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.HeatMap;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.HeatMap;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.HeatMap;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.HeatMap;
        hatchFill(enabled?: boolean): anychart.charts.HeatMap;
        height(): number | string;
        height(height?: number | string): anychart.charts.HeatMap;
        hover(indexOrIndexes?: number | Array<number>): anychart.charts.HeatMap;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.HeatMap;
        id(): string;
        id(id?: string): anychart.charts.HeatMap;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.HeatMap;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.HeatMap;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.HeatMap;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.HeatMap;
        labelsDisplayMode(): string;
        labelsDisplayMode(mode?: string): anychart.charts.HeatMap;
        left(): number | string;
        left(value?: number | string): anychart.charts.HeatMap;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.HeatMap;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.HeatMap;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.HeatMap;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.charts.HeatMap;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.HeatMap;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.HeatMap;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.HeatMap;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.HeatMap;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.HeatMap;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.HeatMap;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.HeatMap;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.HeatMap;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.HeatMap;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        select(index?: number): anychart.charts.HeatMap;
        select(indexes?: Array<number>): anychart.charts.Funnel;
        select(): anychart.charts.Funnel;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.HeatMap;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.HeatMap;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.HeatMap;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.HeatMap;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.HeatMap;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.HeatMap;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.HeatMap;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(value?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.HeatMap;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.HeatMap;
        stroke(settings?: Object): anychart.charts.HeatMap;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.HeatMap;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.HeatMap;
        top(): number | string;
        top(top?: number | string): anychart.charts.HeatMap;
        unhover(): anychart.charts.HeatMap;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(indexOrIndexes?: number | Array<number>): void;
        width(): number | string;
        width(width?: number | string): anychart.charts.HeatMap;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.HeatMap;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.HeatMap;
        xGrid(index?: number): anychart.core.grids.Linear;
        xGrid(settings?: Object | boolean): anychart.charts.HeatMap;
        xGrid(index?: number, settings?: Object | boolean): anychart.charts.HeatMap;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: string | anychart.scales.Ordinal): anychart.charts.HeatMap;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(settings?: Object | boolean): anychart.charts.HeatMap;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(settings?: number | boolean | Object): anychart.charts.HeatMap;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.HeatMap;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.HeatMap;
        yGrid(index?: number): anychart.core.grids.Linear;
        yGrid(settings?: Object | boolean): anychart.charts.HeatMap;
        yGrid(index?: number, settings?: Object | boolean): anychart.charts.HeatMap;
        yScale(): anychart.scales.Ordinal;
        yScale(settings?: string | anychart.scales.Ordinal): anychart.charts.HeatMap;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(settings?: Object | boolean): anychart.charts.HeatMap;
        yZoom(): anychart.core.utils.OrdinalZoom;
        yZoom(settings?: number | boolean | Object): anychart.charts.HeatMap;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.HeatMap;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.HeatMap;
        animation(enabled: boolean, duration: number): anychart.charts.HeatMap;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.HeatMap;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.HeatMap;
    }
    interface Gantt extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Gantt;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Gantt;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Gantt;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Gantt;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Gantt;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Gantt;
        collapseAll(): anychart.charts.Gantt;
        collapseTask(taskId: string): anychart.charts.Gantt;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(color?: anychart.graphics.vector.Stroke | string): anychart.charts.Gantt;
        columnStroke(settings?: Object): anychart.charts.Gantt;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Gantt;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Gantt;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Gantt;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView | Array<Object>, fillMethod?: string): anychart.charts.Gantt;
        dataGrid(): anychart.core.ui.DataGrid;
        dataGrid(enabled?: boolean): anychart.charts.Gantt;
        defaultRowHeight(): number;
        defaultRowHeight(height?: number): anychart.charts.Gantt;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Gantt;
        edit(): anychart.core.gantt.edit.StructureEdit;
        edit(settings?: Object | boolean): anychart.charts.Gantt;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Gantt;
        expandAll(): anychart.charts.Gantt;
        expandTask(taskId: string): anychart.charts.Gantt;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Gantt;
        fitAll(): anychart.charts.Gantt;
        fitToTask(taskId: string): anychart.charts.Gantt;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Gantt;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getTimeline(): anychart.core.ui.Timeline;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        headerHeight(): number | string;
        headerHeight(height?: number | string): anychart.charts.Gantt;
        height(): number | string;
        height(height?: number | string): anychart.charts.Gantt;
        id(): string;
        id(id?: string): anychart.charts.Gantt;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Gantt;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Gantt;
        left(): number | string;
        left(left?: number | string): anychart.charts.Gantt;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Gantt;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Gantt;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Gantt;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Gantt;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Gantt;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Gantt;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Gantt;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Gantt;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Gantt;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(paletteSettings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Gantt;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Gantt;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Gantt;
        rowHoverFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.Gantt;
        rowHoverFill(color: string, opacity?: number): anychart.charts.Gantt;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Gantt;
        rowSelectedFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.Gantt;
        rowSelectedFill(color: string, opacity?: number): anychart.charts.Gantt;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(color?: anychart.graphics.vector.Stroke | string): anychart.charts.Gantt;
        rowStroke(settings?: Object): anychart.charts.Gantt;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        scrollTo(): number;
        scrollTo(pxValue: number): anychart.charts.Gantt;
        scrollToEnd(index?: number): anychart.charts.Gantt;
        scrollToRow(rowIndex: number): anychart.charts.Gantt;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        splitterPosition(): number | string;
        splitterPosition(position?: string | number): anychart.charts.Gantt;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Gantt;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        top(): number | string;
        top(top?: number | string): anychart.charts.Gantt;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Gantt;
        xScale(): anychart.scales.GanttDateTime;
        xScale(settings?: Object): anychart.charts.Gantt;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Gantt;
        zoomIn(zoomFactor?: number): anychart.charts.Gantt;
        zoomOut(zoomFactor?: number): anychart.charts.Gantt;
        zoomTo(startDate: number, endDate?: number): anychart.charts.Gantt;
        zoomTo(unit: string, count?: number, anchor?: string): anychart.charts.Gantt;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Gantt;
        animation(enabled: boolean, duration: number): anychart.charts.Gantt;
        cancelMarquee(): anychart.charts.Gantt;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Gantt;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Gantt;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Gantt;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Gantt;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Gantt;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Gantt;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Gantt;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Gantt;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Gantt;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Gantt;
    }
    interface Graph extends anychart.core.Chart {
        data(): Object;
        data(data?: Object): anychart.charts.Graph;
        edges(): anychart.core.graph.elements.Edge;
        edges(value?: Object): anychart.charts.Graph;
        fit(): anychart.charts.Graph;
        group(id: string): anychart.core.graph.elements.Group;
        group(id: string, value: Object): anychart.charts.Graph;
        interactivity(): anychart.core.graph.elements.Interactivity;
        interactivity(value: Object): anychart.charts.Graph;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value: Object | string): anychart.charts.Graph;
        layout(): anychart.core.graph.elements.Layout;
        layout(value: Object | string): anychart.charts.Graph;
        move(): Array<number>;
        move(dx?: number, dy?: number): anychart.charts.Graph;
        nodes(): anychart.core.graph.elements.Node;
        nodes(value?: Object): anychart.charts.Graph;
        rotation(): number;
        rotation(degree: number): anychart.charts.Graph;
        select(): anychart.charts.Graph;
        select(node_id?: string): anychart.charts.Graph;
        select(nodes_ids: Array<string>): anychart.charts.Graph;
        unselect(): anychart.charts.Graph;
        unselect(id?: string): anychart.charts.Graph;
        unselect(ids?: Array<string>): anychart.charts.Graph;
        zoom(): number;
        zoom(value: number, cx?: number, cy?: number): anychart.charts.Graph;
        zoomIn(): anychart.charts.Graph;
        zoomOut(): anychart.charts.Graph;
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Graph;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Graph;
        animation(enabled: boolean, duration: number): anychart.charts.Graph;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Graph;
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.charts.Graph;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Graph;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Graph;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Graph;
        cancelMarquee(): anychart.charts.Graph;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Graph;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Graph;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Graph;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Graph;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Graph;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Graph;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Graph;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Graph;
        id(): string;
        id(id?: string): anychart.charts.Graph;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Graph;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Graph;
        left(): number | string;
        left(left?: number | string): anychart.charts.Graph;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Graph;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Graph;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.charts.Graph;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.charts.Graph;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.charts.Graph;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.charts.Graph;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Graph;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Graph;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Graph;
        right(): number | string;
        right(right?: number | string): anychart.charts.Graph;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Graph;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Graph;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Graph;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Graph;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Graph;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Graph;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Graph;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Graph;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Graph;
        top(): number | string;
        top(top?: number | string): anychart.charts.Graph;
        width(): number | string;
        width(width?: number | string): anychart.charts.Graph;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Graph;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Graph;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Graph;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Sankey extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Sankey;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Sankey;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Sankey;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Sankey;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Sankey;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Sankey;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Sankey;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Sankey;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Sankey;
        curveFactor(): number;
        curveFactor(padding?: number): anychart.charts.Sankey;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any>): anychart.charts.Sankey;
        data(csvString?: string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Sankey;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Sankey;
        dropoff(): anychart.core.sankey.elements.Dropoff;
        dropoff(settings?: Object): anychart.charts.Sankey;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Sankey;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Sankey;
        flow(): anychart.core.sankey.elements.Flow;
        flow(settings?: Object): anychart.charts.Sankey;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Sankey;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.charts.Sankey;
        id(): string;
        id(id?: string): anychart.charts.Sankey;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Sankey;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Sankey;
        left(): number | string;
        left(value?: number | string): anychart.charts.Sankey;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Sankey;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): void;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Sankey;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Sankey;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Sankey;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Sankey;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Sankey;
        node(): anychart.core.sankey.elements.Node;
        node(settings?: Object): anychart.charts.Sankey;
        nodePadding(): number;
        nodePadding(padding?: number): anychart.charts.Sankey;
        nodeWidth(): number;
        nodeWidth(width?: number | string): anychart.charts.Sankey;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Sankey;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Sankey;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Sankey;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Sankey;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Sankey;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Sankey;
        top(): number | string;
        top(top?: number | string): anychart.charts.Sankey;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Sankey;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Sankey;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Sankey;
        animation(enabled: boolean, duration: number): anychart.charts.Sankey;
        cancelMarquee(): anychart.charts.Sankey;
        getStat(key?: string): any;
        inMarquee(): boolean;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Sankey;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Sankey;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sankey;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sankey;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sankey;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Sankey;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Sankey;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Sankey;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Sankey;
    }
    interface CircularGauge extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.CircularGauge;
        addPointer(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.gauge.pointers.Base>;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.CircularGauge;
        animation(enabled: boolean, duration: number): anychart.charts.CircularGauge;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.CircularGauge;
        axis(index?: number): anychart.core.axes.Circular;
        axis(settings?: Object | boolean): anychart.charts.CircularGauge;
        axis(index?: number, settings?: Object | boolean): anychart.charts.CircularGauge;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.CircularGauge;
        bar(index?: number): anychart.core.gauge.pointers.Bar;
        bar(settings?: Object | boolean): anychart.charts.CircularGauge;
        bar(index?: number, settings?: Object | boolean): anychart.charts.CircularGauge;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.CircularGauge;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.CircularGauge;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.CircularGauge;
        cancelMarquee(): anychart.charts.CircularGauge;
        cap(): anychart.core.gauge.Cap;
        cap(value?: Object | boolean): anychart.charts.CircularGauge;
        circularPadding(): string;
        circularPadding(padding?: number | string): anychart.charts.CircularGauge;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.CircularGauge;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.CircularGauge;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.CircularGauge;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.CircularGauge;
        defaultPointerType(): string;
        defaultPointerType(type?: string): anychart.charts.CircularGauge;
        dispose(): void;
        draw(async?: boolean): anychart.charts.CircularGauge;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.CircularGauge;
        encloseWithStraightLine(): boolean;
        encloseWithStraightLine(enabled?: boolean): anychart.charts.CircularGauge;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.CircularGauge;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.CircularGauge;
        fill(color: string, opacity?: number): anychart.charts.CircularGauge;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.CircularGauge;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.CircularGauge;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.CircularGauge;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.CircularGauge;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getPointer(id: number | string): anychart.core.gauge.pointers.Base;
        getPointerAt(index: number): anychart.core.gauge.pointers.Base;
        getPointersCount(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(value?: number | string): anychart.charts.CircularGauge;
        id(): string;
        id(id?: string): anychart.charts.CircularGauge;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        knob(index?: number): anychart.core.gauge.pointers.Knob;
        knob(settings?: Object | boolean): anychart.charts.CircularGauge;
        knob(index?: number, settings?: Object | boolean): anychart.charts.CircularGauge;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.CircularGauge;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.CircularGauge;
        left(): number | string;
        left(left?: number | string): anychart.charts.CircularGauge;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.CircularGauge;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.CircularGauge;
        marker(index?: number): anychart.core.gauge.pointers.Marker;
        marker(settings?: Object | boolean): anychart.charts.CircularGauge;
        marker(index?: number, settings?: Object | boolean): anychart.charts.CircularGauge;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.charts.CircularGauge;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.CircularGauge;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.charts.CircularGauge;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.charts.CircularGauge;
        needle(index?: number): anychart.core.gauge.pointers.Needle;
        needle(settings?: Object | boolean): anychart.charts.CircularGauge;
        needle(index?: number, settings?: Object | boolean): anychart.charts.CircularGauge;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.CircularGauge;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.CircularGauge;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.CircularGauge;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        range(index?: number): anychart.core.axisMarkers.CircularRange;
        range(settings?: Object | boolean): anychart.charts.CircularGauge;
        range(index?: number, settings?: Object | boolean): anychart.charts.CircularGauge;
        removeAllListeners(type?: string): number;
        removeAllPointers(): anychart.charts.CircularGauge;
        removePointer(id: number | string): anychart.charts.CircularGauge;
        removePointerAt(index: number): anychart.charts.CircularGauge;
        right(): number | string;
        right(right?: number | string): anychart.charts.CircularGauge;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.CircularGauge;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.CircularGauge;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.CircularGauge;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.CircularGauge;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.CircularGauge;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.CircularGauge;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startAngle(): number;
        startAngle(angle?: string | number): anychart.charts.CircularGauge;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.CircularGauge;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.CircularGauge;
        stroke(settings?: Object): anychart.charts.CircularGauge;
        sweepAngle(): number;
        sweepAngle(angle?: string | number): anychart.charts.CircularGauge;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.CircularGauge;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.CircularGauge;
        top(): number | string;
        top(top?: number | string): anychart.charts.CircularGauge;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.charts.CircularGauge;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.CircularGauge;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.CircularGauge;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.CircularGauge;
    }
    interface Mekko extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Mekko;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.mekko.series.Mekko>;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Mekko;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Mekko;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Mekko;
        baseline(): number;
        baseline(value?: number): anychart.charts.Mekko;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Mekko;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Mekko;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Mekko;
        cancelMarquee(): anychart.charts.Mekko;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Mekko;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Mekko;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Mekko;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Mekko;
        data(): anychart.data.View;
        data(data?: anychart.data.Set | anychart.data.DataSettings | Array<any>): anychart.charts.Mekko;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.charts.Mekko;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Mekko;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Mekko;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Mekko;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Mekko;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Mekko;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSeries(id: number | string): anychart.core.mekko.series.Mekko;
        getSeriesAt(index: number): anychart.core.mekko.series.Mekko;
        getSeriesCount(): number;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getXAxesCount(): number;
        getYAxesCount(): number;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Mekko;
        height(): number | string;
        height(height?: number | string): anychart.charts.Mekko;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Mekko;
        id(): string;
        id(id?: string): anychart.charts.Mekko;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string): anychart.charts.Mekko;
        isFullScreenAvailable(): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.charts.Mekko;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Mekko;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Mekko;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Mekko;
        left(): number | string;
        left(value?: number | string): anychart.charts.Mekko;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Mekko;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.charts.Mekko;
        lineMarker(index?: number, settings?: Object | boolean): anychart.charts.Mekko;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Mekko;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Mekko;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Mekko;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.charts.Mekko;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Mekko;
        mekko(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: {[prop:string]:string|boolean}): anychart.core.mekko.series.Mekko;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Mekko;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.charts.Mekko;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Mekko;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Mekko;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Mekko;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Mekko;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Mekko;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Mekko;
        pointsPadding(): number;
        pointsPadding(padding?: number): anychart.charts.Mekko;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.charts.Mekko;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.charts.Mekko;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Mekko;
        removeSeries(id: number | string): anychart.charts.Mekko;
        removeSeriesAt(index: number): anychart.charts.Mekko;
        right(): number | string;
        right(right?: number | string): anychart.charts.Mekko;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Mekko;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Mekko;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Mekko;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Mekko;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Mekko;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Mekko;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Mekko;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Mekko;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.charts.Mekko;
        textMarker(index?: number, settings?: Object | boolean): anychart.charts.Mekko;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Mekko;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Mekko;
        top(): number | string;
        top(top?: number | string): anychart.charts.Mekko;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Mekko;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(settings?: Object | boolean): anychart.charts.Mekko;
        xAxis(index?: number, settings?: Object | boolean): anychart.charts.Mekko;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: Object | string | anychart.scales.Ordinal): anychart.charts.Mekko;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.charts.Mekko;
        yAxis(index?: number, settings?: Object | boolean): anychart.charts.Mekko;
        yScale(): anychart.scales.Base;
        yScale(settings?: Object | string | anychart.scales.Base): anychart.charts.Mekko;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Mekko;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Mekko;
        animation(enabled: boolean, duration: number): anychart.charts.Mekko;
        getSelectedPoints(): Array<anychart.core.Point>;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Mekko;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Mekko;
    }
    interface Pie extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Pie;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Pie;
        animation(enabled: boolean, duration: number): anychart.charts.Pie;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Pie;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Pie;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Pie;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Pie;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Pie;
        cancelMarquee(): anychart.charts.Pie;
        center(): anychart.core.ui.Center;
        center(centerSettings?: Object): anychart.charts.Pie;
        connectorLength(): number | string;
        connectorLength(length?: number | string): anychart.charts.Pie;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        connectorStroke(settings?: Object): anychart.charts.Pie;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Pie;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Pie;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Pie;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | anychart.data.DataSettings | Array<any>, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Pie;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Pie;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Pie;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Pie;
        fill(): anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Pie;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.Pie;
        fill(color: string, opacity?: number): anychart.charts.Pie;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pie;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pie;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pie;
        forceHoverLabels(): boolean;
        forceHoverLabels(enabled?: boolean): anychart.charts.Pie;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Pie;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPixelExplode(): number;
        getPixelInnerRadius(): number;
        getPixelRadius(): number;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getPoint(index: number): anychart.core.PiePoint;
        getSelectedPoints(): Array<anychart.core.PiePoint>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        group(): ((value:any)=>boolean);
        group(settings?: string | ((value:any)=>boolean), name?: string): anychart.charts.Pie;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Pie;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.Pie;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Pie;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Pie;
        hatchFill(enabled?: boolean): anychart.charts.Pie;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pie;
        height(): number | string;
        height(height?: number | string): anychart.charts.Pie;
        hover(index?: number): anychart.charts.Pie;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Pie;
        id(): string;
        id(id?: string): anychart.charts.Pie;
        inMarquee(): boolean;
        innerRadius(): string | number | ((outerRadius:number)=>number);
        innerRadius(radius?: string | number | ((outerRadius:number)=>number)): anychart.charts.Pie;
        insideLabelsOffset(): number | string;
        insideLabelsOffset(offset?: number | string): anychart.charts.Pie;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Pie;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Pie;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Pie;
        left(): number | string;
        left(value?: number | string): anychart.charts.Pie;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Pie;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Pie;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pie;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Pie;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Pie;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Pie;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Pie;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Pie;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Pie;
        outline(): anychart.core.ui.Outline;
        outline(settings?: Object | boolean | string): anychart.charts.Pie;
        outsideLabelsCriticalAngle(): number | string;
        outsideLabelsCriticalAngle(angle?: number | string): anychart.charts.Pie;
        outsideLabelsSpace(): number | string;
        outsideLabelsSpace(value?: number | string): anychart.charts.Pie;
        overlapMode(): string;
        overlapMode(value?: string | boolean): anychart.charts.Pie;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Pie;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pie;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pie;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string | number;
        radius(radius?: string | number): anychart.charts.Pie;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Pie;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        select(): anychart.charts.Pie;
        select(index?: number): anychart.charts.Pie;
        select(indexes?: Array<number>): anychart.charts.Pie;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Pie;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Pie;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pie;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pie;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pie;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Pie;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        sort(): string;
        sort(value?: string): anychart.charts.Pie;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.charts.Pie;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Pie;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(fillFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.Pie;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        stroke(settings?: Object): anychart.charts.Pie;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Pie;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Pie;
        top(): number | string;
        top(top?: number | string): anychart.charts.Pie;
        unhover(): anychart.charts.Pie;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Pie;
        width(): number | string;
        width(width?: number | string): anychart.charts.Pie;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Pie;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Pie;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Pie;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Pie;
    }
    interface Funnel extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Funnel;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Funnel;
        animation(enabled: boolean, duration: number): anychart.charts.Funnel;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Funnel;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Funnel;
        baseWidth(): string | number;
        baseWidth(width?: string | number): anychart.charts.Funnel;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Funnel;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Funnel;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Funnel;
        cancelMarquee(): anychart.charts.Funnel;
        connectorLength(): number | string;
        connectorLength(length?: number | string): anychart.charts.Funnel;
        connectorStroke(): anychart.graphics.vector.Stroke | (() => void);
        connectorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        connectorStroke(settings?: Object): anychart.charts.Funnel;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Funnel;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Funnel;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Funnel;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Funnel;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Funnel;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Funnel;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Funnel;
        fill(): anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Funnel;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.charts.Funnel;
        fill(color: string, opacity?: number): anychart.charts.Funnel;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Funnel;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Funnel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Funnel;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getPoint(index: number): anychart.core.Point;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Funnel;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.Funnel;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Funnel;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Funnel;
        hatchFill(enabled?: boolean): anychart.charts.Funnel;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Funnel;
        height(): number | string;
        height(height?: number | string): anychart.charts.Funnel;
        hover(index?: number): anychart.charts.Funnel;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Funnel;
        id(): string;
        id(id?: string): anychart.charts.Funnel;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Funnel;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Funnel;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Funnel;
        left(): number | string;
        left(value?: number | string): anychart.charts.Funnel;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Funnel;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Funnel;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Funnel;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Funnel;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.charts.Funnel;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Funnel;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Funnel;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Funnel;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Funnel;
        neckHeight(): string | number;
        neckHeight(height?: string | number): anychart.charts.Funnel;
        neckWidth(): string | number;
        neckWidth(width?: string | number): anychart.charts.Funnel;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Funnel;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Funnel;
        overlapMode(): string;
        overlapMode(settings?: string | boolean): anychart.charts.Funnel;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Funnel;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Funnel;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Funnel;
        pointsPadding(): string | number;
        pointsPadding(padding?: string | number): anychart.charts.Funnel;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.charts.Funnel;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        select(index?: number): anychart.charts.Funnel;
        select(indexes?: Array<number>): anychart.charts.Funnel;
        select(): anychart.charts.Funnel;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Funnel;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Funnel;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Funnel;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Funnel;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Funnel;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Funnel;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.Funnel;
        stroke(settings?: Object): anychart.charts.Funnel;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Funnel;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Funnel;
        top(): number | string;
        top(top?: number | string): anychart.charts.Funnel;
        unhover(): anychart.charts.Funnel;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Funnel;
        width(): number | string;
        width(width?: number | string): anychart.charts.Funnel;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Funnel;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Funnel;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Funnel;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Funnel;
    }
    interface Map extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Map;
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.map.series.Base>;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Map;
        axes(): anychart.core.axes.MapSettings;
        axes(settings?: Object | boolean): anychart.charts.Map;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Map;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Map;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Map;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Map;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Bubble;
        callout(index?: number): anychart.core.ui.Callout;
        callout(settings?: Object | boolean): anychart.charts.Map;
        callout(index?: number, settings?: Object | boolean): anychart.charts.Map;
        cancelMarquee(): anychart.charts.Map;
        cancelPolygon(): anychart.charts.Map;
        choropleth(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Choropleth;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(settings?: Object): anychart.charts.Map;
        connector(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Connector;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Map;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Map;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Map;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.charts.Map;
        crs(): Object | (() => void) | string;
        crs(settings: Object | (() => void) | string): anychart.charts.Map;
        crsAnimation(): anychart.core.utils.Animation;
        crsAnimation(settings?: boolean | Object, duration?: number): anychart.charts.Map;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.charts.Map;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Map;
        drillDownMap(value?: {[prop:string]:Object|anychart.charts.Map}): Object;
        drillTo(id: string, map?: anychart.charts.Map): anychart.charts.Map;
        drillUp(): anychart.charts.Map;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Map;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Map;
        featureCrs(id: string): string;
        featureCrs(id: string, crs?: string): anychart.charts.Map;
        featureScaleFactor(id: string): number;
        featureScaleFactor(id: string, ratio?: number): anychart.charts.Map;
        featureTranslation(id: string): Array<number>;
        featureTranslation(id: string, dx?: number, dy?: number): anychart.charts.Map;
        fitAll(): anychart.charts.Map;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Map;
        geoData(): Node | string | Object;
        geoData(data?: Node | string | Object): anychart.charts.Map;
        geoIdField(): string;
        geoIdField(id?: string): anychart.charts.Map;
        getCurrentScene(): anychart.charts.Map;
        getDrilldownPath(): Array<anychart.core.MapPoint>;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.MapPoint>;
        getSeries(id: number | string): anychart.core.map.series.Base;
        getSeriesAt(index: number): anychart.core.map.series.Base;
        getSeriesCount(): number;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        getZoomLevel(): number;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        grids(): anychart.core.grids.MapSettings;
        grids(settings?: Object | boolean): anychart.charts.Map;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Map;
        height(): number | string;
        height(height?: number | string): anychart.charts.Map;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Map;
        id(): string;
        id(id?: string): anychart.charts.Map;
        inMarquee(): boolean;
        inPolygon(): boolean;
        interactivity(): anychart.core.utils.MapInteractivity;
        interactivity(settings?: Object | string): anychart.charts.Map;
        inverseTransform(x: number, y: number): {[prop:string]:number};
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Map;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Map;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Map;
        left(): number | string;
        left(value?: number | string): anychart.charts.Map;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Map;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Map;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Map;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Map;
        maxBubbleSize(): number | string;
        maxBubbleSize(size?: number | string): anychart.charts.Map;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Map;
        maxWidth(): number | string;
        maxWidth(maxWidth?: number | string): anychart.charts.Map;
        maxZoomLevel(): number;
        maxZoomLevel(value?: number): anychart.charts.Map;
        minBubbleSize(): number | string;
        minBubbleSize(size?: number | string): anychart.charts.Map;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Map;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Map;
        move(dx: number, dy: number): anychart.charts.Map;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Map;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Map;
        overlapMode(): string;
        overlapMode(value?: string | boolean): anychart.charts.Map;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Map;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Map;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Map;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Map;
        removeSeries(id: number | string): anychart.charts.Map;
        removeSeriesAt(index: number): anychart.charts.Map;
        right(): number | string;
        right(right?: number | string): anychart.charts.Map;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        scale(): anychart.scales.Geo;
        scale(settings?: anychart.scales.Geo | Object): anychart.scales.Geo;
        selectPolygonMarqueeFill(): anychart.graphics.vector.Fill;
        selectPolygonMarqueeFill(color: anychart.graphics.vector.Fill): anychart.charts.Map;
        selectPolygonMarqueeMarker(config?: Object): anychart.charts.Map;
        selectPolygonMarqueeStroke(color?: anychart.graphics.vector.Stroke): anychart.charts.Map;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Map;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Map;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Map;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Map;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Map;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Map;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Map;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectPolygonMarquee(repeat?: boolean): anychart.charts.Map;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Map;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Map;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toGeoJSON(): Object;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Map;
        top(): number | string;
        top(top?: number | string): anychart.charts.Map;
        transform(xLong: number, yLat: number): {[prop:string]:number};
        translateFeature(id: string, dx: number, dy: number): anychart.charts.Map;
        unboundRegions(): anychart.core.utils.UnboundRegionsSettings | string;
        unboundRegions(settings?: Object | string | boolean): anychart.charts.Map;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(width?: number | string): anychart.charts.Map;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Map;
        zoom(value: number, cx?: number, cy?: number, duration?: number): anychart.charts.Map;
        zoomIn(duration?: number): anychart.charts.Map;
        zoomOut(duration?: number): anychart.charts.Map;
        zoomTo(value: number, cx?: number, cy?: number): anychart.charts.Map;
        zoomToFeature(id: string): void;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Map;
        animation(enabled: boolean, duration: number): anychart.charts.Map;
        getStat(key?: string): any;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Map;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Map;
    }
    interface Pyramid extends anychart.core.SeparateChart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.charts.Pyramid;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.charts.Pyramid;
        animation(enabled: boolean, duration: number): anychart.charts.Pyramid;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.charts.Pyramid;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.charts.Pyramid;
        baseWidth(): string | number;
        baseWidth(width?: string | number): anychart.charts.Pyramid;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.charts.Pyramid;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.charts.Pyramid;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.charts.Pyramid;
        cancelMarquee(): anychart.charts.Pyramid;
        connectorLength(): number | string;
        connectorLength(length?: number | string): anychart.charts.Pyramid;
        connectorStroke(): anychart.graphics.vector.Stroke | (() => void);
        connectorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.charts.Pyramid;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.charts.Pyramid;
        credits(): anychart.core.ui.ChartCredits;
        credits(settings?: Object | boolean): anychart.charts.Pyramid;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.DataSettings, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.Pyramid;
        dispose(): void;
        draw(async?: boolean): anychart.charts.Pyramid;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.charts.Pyramid;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.charts.Pyramid;
        fill(): anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill);
        fill(fillFunction?: anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill)): anychart.charts.Pyramid;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Pyramid;
        fill(color: string, opacity?: number): anychart.charts.Pyramid;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pyramid;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pyramid;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.charts.Pyramid;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getPoint(index: number): anychart.core.Point;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Pyramid;
        hatchFill(hatchFillFunction?: (() => void)): anychart.charts.Pyramid;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.charts.Pyramid;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.charts.Pyramid;
        hatchFill(enabled?: boolean): anychart.charts.Pyramid;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(settings?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pyramid;
        height(): number | string;
        height(height?: number | string): anychart.charts.Pyramid;
        hover(index?: number): anychart.charts.Pyramid;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.charts.Pyramid;
        id(): string;
        id(id?: string): anychart.charts.Pyramid;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.charts.Pyramid;
        label(index?: string | number, settings?: boolean | Object | string): anychart.charts.Pyramid;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.charts.Pyramid;
        left(): number | string;
        left(value?: number | string): anychart.charts.Pyramid;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.charts.Pyramid;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.charts.Pyramid;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pyramid;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(settings?: anychart.palettes.Markers | Object | Array<string|string>): anychart.charts.Pyramid;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.charts.Pyramid;
        maxHeight(): number | string;
        maxHeight(maxHeight?: number | string): anychart.charts.Pyramid;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Pyramid;
        minHeight(): number | string;
        minHeight(minHeight?: number | string): anychart.charts.Pyramid;
        minWidth(): number | string;
        minWidth(minWidth?: number | string): anychart.charts.Pyramid;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.charts.Pyramid;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.charts.Pyramid;
        overlapMode(): string;
        overlapMode(settings?: string | boolean): anychart.charts.Pyramid;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.charts.Pyramid;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Pyramid;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pyramid;
        pointsPadding(): string | number;
        pointsPadding(padding?: string | number): anychart.charts.Pyramid;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        reversed(): boolean;
        reversed(value?: boolean): anychart.charts.Pyramid;
        right(): number | string;
        right(right?: number | string): anychart.charts.Pyramid;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        select(): anychart.charts.Pyramid;
        select(index?: number): anychart.charts.Pyramid;
        select(indexes?: Array<number>): anychart.charts.Pyramid;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.charts.Pyramid;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.charts.Pyramid;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pyramid;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pyramid;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.charts.Pyramid;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.charts.Pyramid;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(value?: anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.charts.Pyramid;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        stroke(settings?: Object): anychart.charts.Pyramid;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.charts.Pyramid;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.charts.Pyramid;
        top(): number | string;
        top(top?: number | string): anychart.charts.Pyramid;
        unhover(): anychart.charts.Pyramid;
        unlisten(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Pyramid;
        width(): number | string;
        width(width?: number | string): anychart.charts.Pyramid;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.charts.Pyramid;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.charts.Pyramid;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.charts.Pyramid;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.charts.Pyramid;
    }
}

declare namespace anychart.color {
    function bipolarHueProgression(color1?: string, color2?: string, count?: number): Array<string>;
    function blend(rgb1: Array<number>, rgb2: Array<number>, factor: number): anychart.graphics.vector.SolidFill;
    function blendedHueProgression(color1?: string, color2?: string, count?: number): Array<string>;
    function darken(fillOrStroke: anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke, factor?: number): string | anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke;
    function lighten(fillOrStroke: anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke, factor?: number): string | anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke;
    function setOpacity(strokeOrFill: anychart.graphics.vector.Stroke | anychart.graphics.vector.Fill, value: number, isFill?: boolean): anychart.graphics.vector.Stroke | anychart.graphics.vector.Fill;
    function setThickness(stroke: anychart.graphics.vector.Stroke, thickness: number, opacity?: number): anychart.graphics.vector.Stroke;
    function singleHueProgression(color?: string, count?: number, startOrTargetLightness?: number, endLightness?: number): Array<string>;
}

declare namespace anychart.core {
    type MouseEvent = {
        altKey: boolean;
        button: number;
        charCode: number;
        clientX: number;
        clientY: number;
        ctrlKey: boolean;
        currentTarget: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        domTarget: anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        keyCode: number;
        metaKey: boolean;
        offsetX: number;
        offsetY: number;
        platformModifierKey: boolean;
        relatedDomTarget: anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        relatedTarget: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        screenX: number;
        screenY: number;
        shiftKey: boolean;
        target: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        type: anychart.graphics.events.EventType;
    }
    interface VisualBase extends anychart.core.Base {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.VisualBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.VisualBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.VisualBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.VisualBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.VisualBase;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(enabled?: boolean): anychart.core.Point;
        set(field: string, value: any): anychart.core.Point;
    }
    interface StateSettings extends anychart.core.Base {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.StateSettings;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.StateSettings;
        connector(): anychart.core.utils.Connector;
        connector(settings?: Object): anychart.core.StateSettings;
        content(): string | number;
        content(content?: string | number): anychart.core.StateSettings;
        content(func?: ((path:anychart.graphics.vector.Path)=>void)): anychart.core.StateSettings;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.StateSettings;
        dummyFill(): anychart.graphics.vector.Fill;
        dummyFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        dummyFill(color: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        dummyFill(color: string, opacity?: number): anychart.core.StateSettings;
        dummyFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        dummyFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        dummyFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        dummyStroke(): anychart.graphics.vector.Stroke;
        dummyStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        dummyStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        dummyStroke(settings?: Object): anychart.core.StateSettings;
        emptyFill(): anychart.graphics.vector.Fill | (() => void);
        emptyFill(color: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        emptyFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        emptyFill(color: string, opacity?: number): anychart.core.StateSettings;
        emptyHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        emptyHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        emptyHatchFill(hatchFillFunction?: (() => void)): anychart.core.StateSettings;
        emptyHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        emptyHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        emptyHatchFill(enabled?: boolean): anychart.core.StateSettings;
        explode(): number | string;
        explode(explode: number | string): anychart.core.StateSettings;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Base;
        fallingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        fallingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        fallingHatchFill(hatchFillFunction?: (() => void)): anychart.core.StateSettings;
        fallingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        fallingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        fallingHatchFill(enabled?: boolean): anychart.core.StateSettings;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        fallingStroke(settings?: Object): anychart.core.StateSettings;
        fill(): anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill);
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.StateSettings;
        fill(color: string, opacity?: number): anychart.core.StateSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        fontColor(): string;
        fontColor(color?: string): anychart.core.StateSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.StateSettings;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.StateSettings;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.StateSettings;
        fontPadding(): number | string;
        fontPadding(padding?: number | string): anychart.core.StateSettings;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.StateSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.StateSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.StateSettings;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.StateSettings;
        grid(): anychart.graphics.vector.Stroke;
        grid(gridFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        grid(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.StateSettings;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.StateSettings;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        hatchFill(enabled?: boolean): anychart.core.StateSettings;
        headers(): anychart.core.ui.LabelsFactory;
        headers(settings?: Object | boolean): anychart.core.StateSettings;
        height(): string | number;
        height(height?: string | number): anychart.core.StateSettings;
        highFill(): anychart.graphics.vector.Fill;
        highFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Base;
        highFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        highFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        highFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        highFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        highFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        highHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        highHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        highHatchFill(func?: (() => void)): anychart.core.StateSettings;
        highHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        highHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        highHatchFill(enabled?: boolean): anychart.core.StateSettings;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): Object;
        labels(): anychart.core.ui.LabelsFactory | anychart.core.ui.CircularLabelsFactory;
        labels(settings?: Object | boolean): anychart.core.StateSettings;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.StateSettings;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.StateSettings;
        lowFill(): anychart.graphics.vector.Fill;
        lowFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Base;
        lowFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        lowFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        lowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        lowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        lowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        lowHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        lowHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        lowHatchFill(func?: (() => void)): anychart.core.StateSettings;
        lowHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        lowHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        lowHatchFill(enabled?: boolean): anychart.core.StateSettings;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        lowStroke(settings?: Object): anychart.core.StateSettings;
        lowerLabels(): anychart.core.ui.LabelsFactory;
        lowerLabels(settings?: Object | boolean): anychart.core.StateSettings;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.StateSettings;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.StateSettings;
        medianStroke(): anychart.graphics.vector.Stroke | (() => void);
        medianStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        medianStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        medianStroke(settings?: Object): anychart.core.StateSettings;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.StateSettings;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.StateSettings;
        negativeFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        negativeFill(color: string, opacity?: number): anychart.core.StateSettings;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.StateSettings;
        negativeHatchFill(hatchFillFunction?: (() => void)): anychart.core.StateSettings;
        negativeHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        negativeHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        negativeHatchFill(enabled?: boolean): anychart.core.StateSettings;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        negativeStroke(settings?: Object): anychart.core.StateSettings;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): Object;
        outlierMarkers(): anychart.core.ui.MarkersFactory;
        outlierMarkers(settings?: Object | boolean | string): anychart.core.StateSettings;
        outline(): anychart.core.ui.Outline;
        outline(settings?: Object): anychart.core.StateSettings;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.StateSettings;
        risingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.StateSettings;
        risingFill(color: string, opacity?: number): anychart.core.StateSettings;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.StateSettings;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.StateSettings;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.StateSettings;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Base;
        risingHatchFill(hatchFillFunction?: (() => void)): anychart.core.StateSettings;
        risingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.StateSettings;
        risingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.StateSettings;
        risingHatchFill(enabled?: boolean): anychart.core.StateSettings;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        risingStroke(settings?: Object): anychart.core.StateSettings;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.StateSettings;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): Object;
        size(): number;
        size(size?: number): anychart.core.StateSettings;
        stemStroke(): anychart.graphics.vector.Stroke | (() => void);
        stemStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        stemStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        stemStroke(settings?: Object): anychart.core.StateSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        stroke(settings?: Object): anychart.core.StateSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.StateSettings;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.StateSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.StateSettings;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.StateSettings;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        trend(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.StateSettings;
        upperLabels(): anychart.core.ui.LabelsFactory;
        upperLabels(settings?: Object | boolean): anychart.core.StateSettings;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.StateSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.StateSettings;
        whiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        whiskerStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.StateSettings;
        whiskerStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.StateSettings;
        whiskerStroke(settings?: Object): anychart.core.StateSettings;
        whiskerWidth(): number | string;
        whiskerWidth(width?: number | string): anychart.core.StateSettings;
        width(): string | number;
        width(width?: string | number): anychart.core.StateSettings;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.StateSettings;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.StateSettings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base {
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeparateChart extends anychart.core.Chart {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.core.SeparateChart;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.core.SeparateChart;
        animation(enabled: boolean, duration: number): anychart.core.SeparateChart;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.core.SeparateChart;
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.core.SeparateChart;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.SeparateChart;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.SeparateChart;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.SeparateChart;
        cancelMarquee(): anychart.core.SeparateChart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.SeparateChart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.core.SeparateChart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.SeparateChart;
        draw(async?: boolean): anychart.core.SeparateChart;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.SeparateChart;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.core.SeparateChart;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.core.SeparateChart;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.core.SeparateChart;
        id(): string;
        id(id?: string): anychart.core.SeparateChart;
        inMarquee(): boolean;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(settings?: Object | string | boolean): anychart.core.SeparateChart;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.core.SeparateChart;
        label(index?: string | number, settings?: boolean | Object | string): anychart.core.SeparateChart;
        left(): number | string;
        left(left?: number | string): anychart.core.SeparateChart;
        legend(): anychart.core.ui.Legend;
        legend(settings?: Object | boolean): anychart.core.SeparateChart;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.SeparateChart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.SeparateChart;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.SeparateChart;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.SeparateChart;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.SeparateChart;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.SeparateChart;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.core.SeparateChart;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.SeparateChart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.SeparateChart;
        right(): number | string;
        right(right?: number | string): anychart.core.SeparateChart;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.SeparateChart;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.core.SeparateChart;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeparateChart;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeparateChart;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.SeparateChart;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.SeparateChart;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.SeparateChart;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.SeparateChart;
        top(): number | string;
        top(top?: number | string): anychart.core.SeparateChart;
        width(): number | string;
        width(width?: number | string): anychart.core.SeparateChart;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.SeparateChart;
        dispose(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.core.SeparateChart;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.SeparateChart;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.SeparateChart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Chart extends anychart.core.VisualBaseWithBounds {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(settings?: boolean | Object): anychart.core.Chart;
        animation(): anychart.core.utils.Animation;
        animation(settings?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        autoRedraw(): boolean;
        autoRedraw(enabled?: boolean): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.Chart;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.Chart;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.Chart;
        cancelMarquee(): anychart.core.Chart;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        dispose(): void;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.Chart;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.core.Chart;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.core.Chart;
        getJpgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key?: string): any;
        getSvgBase64String(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop:string]:number};
        height(): number | string;
        height(height?: number | string): anychart.core.Chart;
        id(): string;
        id(id?: string): anychart.core.Chart;
        inMarquee(): boolean;
        isFullScreenAvailable(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, settings?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(left?: number | string): anychart.core.Chart;
        localToGlobal(xCoord: number, yCoord: number): {[prop:string]:number};
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.Chart;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.Chart;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.Chart;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.Chart;
        noData(): anychart.core.NoDataSettings;
        noData(settings?: Object): anychart.core.Chart;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        right(): number | string;
        right(right?: number | string): anychart.core.Chart;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number | Object, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(filename?: string): void;
        saveAsPdf(paperSizeOrWidthOrOptions?: number | string | Object, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number | Object, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string | Object, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string, filename?: string, exportOptions?: {[prop:string]:((name:any,value:any)=>void)}): void;
        saveAsXml(filename?: string): void;
        selectRectangleMarqueeFill(): anychart.graphics.vector.Fill;
        selectRectangleMarqueeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.Chart;
        selectRectangleMarqueeFill(color: string, opacity?: number): anychart.core.Chart;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.Chart;
        selectRectangleMarqueeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.Chart;
        selectRectangleMarqueeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.Chart;
        selectRectangleMarqueeStroke(): anychart.graphics.vector.Stroke;
        selectRectangleMarqueeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.Chart;
        shareAsJpg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccessOrOptions: ((response:string)=>void) | Object, onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        startSelectRectangleMarquee(repeat?: boolean): anychart.core.Chart;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.Chart;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)|Object}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean): Object | string;
        toSvg(paperSize?: string | Object, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(top?: number | string): anychart.core.Chart;
        width(): number | string;
        width(width?: number | string): anychart.core.Chart;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.Chart;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.Chart;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.Chart;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeriesPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.SeriesPoint;
        selected(): boolean;
        selected(enabled?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.SeriesPoint;
    }
    interface NoDataSettings extends anychart.core.Base {
        label(): anychart.core.ui.Label;
        label(settings?: Object | string | boolean): anychart.core.NoDataSettings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeriesBase extends anychart.core.VisualBaseWithBounds {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.SeriesBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.SeriesBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.SeriesBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.SeriesBase;
        color(): string;
        color(color: string): anychart.core.SeriesBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.SeriesBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.SeriesBase;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hovered(): anychart.core.StateSettings;
        hovered(value?: Object): anychart.core.SeriesBase;
        id(): string | number;
        id(id?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(left?: number | string): anychart.core.SeriesBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.SeriesBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.SeriesBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.SeriesBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.SeriesBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.SeriesBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.SeriesBase;
        name(): string;
        name(name?: string): anychart.core.SeriesBase;
        normal(): anychart.core.StateSettings;
        normal(value?: Object): anychart.core.SeriesBase;
        right(): number | string;
        right(right?: number | string): anychart.core.SeriesBase;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selected(): anychart.core.StateSettings;
        selected(value?: Object): anychart.core.SeriesBase;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(top?: number | string): anychart.core.SeriesBase;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(width?: number | string): anychart.core.SeriesBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.SeriesBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.SeriesBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.SeriesBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.SeriesBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Text extends anychart.core.VisualBase {
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.Text;
        fontColor(): string;
        fontColor(color?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.Text;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.Text;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.Text;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.Text;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.Text;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.Text;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Text;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.Text;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.Text;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TreeChartPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getNode(): anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.TreeChartPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.TreeChartPoint;
        set(field: string, value: any): anychart.core.TreeChartPoint;
    }
    interface VisualBaseWithBounds extends anychart.core.VisualBase {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBaseWithBounds;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBaseWithBounds;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.VisualBaseWithBounds;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(left?: number | string): anychart.core.VisualBaseWithBounds;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.VisualBaseWithBounds;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.VisualBaseWithBounds;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.VisualBaseWithBounds;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.VisualBaseWithBounds;
        right(): number | string;
        right(right?: number | string): anychart.core.VisualBaseWithBounds;
        top(): number | string;
        top(top?: number | string): anychart.core.VisualBaseWithBounds;
        width(): number | string;
        width(width?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.VisualBaseWithBounds;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.VisualBaseWithBounds;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.VisualBaseWithBounds;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.VisualBaseWithBounds;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ChoroplethPoint extends anychart.core.SeriesPoint {
        crs(): string;
        crs(crs?: string): anychart.core.ChoroplethPoint;
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getFeatureBounds(): anychart.math.Rect;
        getFeatureProp(): Object;
        getIndex(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.ChoroplethPoint;
        middleX(): number;
        middleX(xCoord?: number): anychart.core.ChoroplethPoint;
        middleY(): number;
        middleY(yCoord?: number): anychart.core.ChoroplethPoint;
        scaleFactor(): number;
        scaleFactor(scaleFactor?: number): anychart.core.ChoroplethPoint;
        selected(): boolean;
        selected(enabled?: boolean): anychart.core.ChoroplethPoint;
        set(field: string, value: any): anychart.core.ChoroplethPoint;
        translate(dx: number, dy: number): anychart.core.ChoroplethPoint;
        translation(): Array<number>;
        translation(dx?: number, dy?: number): anychart.core.ChoroplethPoint;
    }
    interface PiePoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getEndAngle(): number;
        getIndex(): number;
        getStartAngle(): number;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.PiePoint;
        selected(): boolean;
        selected(enabled?: boolean): anychart.core.PiePoint;
        set(field: string, value: any): anychart.core.PiePoint;
    }
    interface BubblePoint extends anychart.core.SeriesPoint {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getPixelRadius(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.BubblePoint;
        selected(): boolean;
        selected(enabled?: boolean): anychart.core.BubblePoint;
        set(field: string, value: any): anychart.core.BubblePoint;
    }
    interface MapPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getCurrentChart(): anychart.core.SeparateChart;
        getId(): string;
        getIndex(): number;
        getParentChart(): anychart.core.SeparateChart;
        getProperties(): Object;
        getStat(key: string): any;
        hovered(): boolean;
        hovered(enabled?: boolean): anychart.core.MapPoint;
        selected(): boolean;
        selected(enabled?: boolean): anychart.core.MapPoint;
        set(field: string, value: any): anychart.core.MapPoint;
    }
}

declare namespace anychart.core.annotations {
    type AnnotationJSONFormat = {
        allowEdit: boolean;
        anchor: string;
        color: anychart.graphics.vector.AnyColor;
        fill: anychart.graphics.vector.Fill | (() => void);
        grid: anychart.graphics.vector.Stroke | (() => void);
        hatchFill: anychart.graphics.vector.PatternFill | (() => void);
        hoverGap: number;
        hovered: anychart.core.StateSettings;
        markerType: string;
        offsetX: number;
        offsetY: number;
        secondValueAnchor: number;
        secondXAnchor: number;
        selected: anychart.core.StateSettings;
        size: number;
        stroke: anychart.graphics.vector.Stroke | (() => void);
        thirdValueAnchor: number;
        thirdXAnchor: number;
        trend: anychart.graphics.vector.Stroke | (() => void);
        type: string;
        valueAnchor: number;
        xAnchor: number;
    }
    interface Ray extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Ray;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Ray;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Ray;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Ray;
        color(): string;
        color(color: string): anychart.core.annotations.Ray;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Ray;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Ray;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Ray;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Ray;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Ray;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Ray;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Ray;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Ray;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Ray;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Ray;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Ray;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Ray;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.Ray;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Ray;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Ray;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.Ray;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ray;
        stroke(settings?: Object): anychart.core.annotations.Ray;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Ray;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Ray;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Ray;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Ray;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Ray;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Ray;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Ray;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Ray;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Ray;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Ray;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface InfiniteLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.InfiniteLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.InfiniteLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.InfiniteLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.InfiniteLine;
        color(): string;
        color(color: string): anychart.core.annotations.InfiniteLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.InfiniteLine;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.InfiniteLine;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.InfiniteLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.InfiniteLine;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.InfiniteLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.InfiniteLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.InfiniteLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.InfiniteLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.InfiniteLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.InfiniteLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.InfiniteLine;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.InfiniteLine;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.InfiniteLine;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.InfiniteLine;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.InfiniteLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.InfiniteLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.InfiniteLine;
        stroke(settings?: Object): anychart.core.annotations.InfiniteLine;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.InfiniteLine;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.InfiniteLine;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.InfiniteLine;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.InfiniteLine;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.InfiniteLine;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.InfiniteLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.InfiniteLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.InfiniteLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.InfiniteLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.InfiniteLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface VerticalRange extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.VerticalRange;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.VerticalRange;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.VerticalRange;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.VerticalRange;
        color(): string;
        color(color: string): anychart.core.annotations.VerticalRange;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.VerticalRange;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.annotations.VerticalRange;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.VerticalRange;
        fill(color: string, opacity?: number): anychart.core.annotations.VerticalRange;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.VerticalRange;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.VerticalRange;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.VerticalRange;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.VerticalRange;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.VerticalRange;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.VerticalRange;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.VerticalRange;
        hatchFill(enabled?: boolean): anychart.core.annotations.VerticalRange;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.VerticalRange;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.VerticalRange;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.VerticalRange;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.VerticalRange;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.VerticalRange;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.VerticalRange;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.VerticalRange;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.VerticalRange;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.VerticalRange;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.VerticalRange;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.VerticalRange;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.VerticalRange;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.VerticalRange;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.VerticalRange;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.VerticalRange;
        stroke(settings?: Object): anychart.core.annotations.VerticalRange;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.VerticalRange;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.VerticalRange;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.VerticalRange;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.VerticalRange;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.VerticalRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.VerticalRange;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.VerticalRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.VerticalRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.VerticalRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Label extends anychart.core.annotations.Base {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.annotations.Label;
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Label;
        anchor(): string;
        anchor(anchor?: string): anychart.core.annotations.Label;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.annotations.Label;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Label;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Label;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.annotations.Label;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Label;
        fontColor(): string;
        fontColor(color?: string): anychart.core.annotations.Label;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.annotations.Label;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.core.annotations.Label;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.annotations.Label;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.annotations.Label;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(type?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.annotations.Label;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(type?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.annotations.Label;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.annotations.Label;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(type?: string | anychart.graphics.vector.Text.HAlign): anychart.core.annotations.Label;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Label;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Label;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Label;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Label;
        letterSpacing(): number | string;
        letterSpacing(spacing?: number | string): anychart.core.annotations.Label;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.annotations.Label;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Label;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.annotations.Label;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Label;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Label;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.annotations.Label;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Label;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Label;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Label;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.annotations.Label;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.annotations.Label;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.annotations.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.annotations.Label;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Label;
        select(): void;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.annotations.Label;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Label;
        text(): string;
        text(text?: string): anychart.core.annotations.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.annotations.Label;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.annotations.Label;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.annotations.Label;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.annotations.Label;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Label;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.annotations.Label;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(type?: anychart.graphics.vector.Text.VAlign | string): anychart.core.annotations.Label;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Label;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Label;
        wordBreak(): string;
        wordBreak(type?: string): anychart.core.annotations.Label;
        wordWrap(): string;
        wordWrap(type?: string): anychart.core.annotations.Label;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Line;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Label;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Label;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Label;
        color(): string;
        color(color: string): anychart.core.annotations.Label;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface FibonacciFan extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.FibonacciFan;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.FibonacciFan;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.FibonacciFan;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.FibonacciFan;
        color(): string;
        color(color: string): anychart.core.annotations.FibonacciFan;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.FibonacciFan;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        grid(): anychart.graphics.vector.Stroke;
        grid(gridFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciFan;
        grid(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.FibonacciFan;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FibonacciFan;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.FibonacciFan;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciFan;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.FibonacciFan;
        levels(): Array<number>;
        levels(levelsList?: Array<any>): anychart.core.annotations.FibonacciFan;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.FibonacciFan;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.FibonacciFan;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.FibonacciFan;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.FibonacciFan;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.FibonacciFan;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.FibonacciFan;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.FibonacciFan;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.FibonacciFan;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.FibonacciFan;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.FibonacciFan;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciFan;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        stroke(settings?: Object): anychart.core.annotations.FibonacciFan;
        timeLevels(): Array<number>;
        timeLevels(timeLevelsList?: Array<any>): anychart.core.annotations.FibonacciFan;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.FibonacciFan;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciFan;
        trend(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciFan;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.FibonacciFan;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciFan;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.FibonacciFan;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.FibonacciFan;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.FibonacciFan;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.FibonacciFan;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.FibonacciFan;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.FibonacciFan;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Rectangle extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Rectangle;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Rectangle;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Rectangle;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Rectangle;
        color(): string;
        color(color: string): anychart.core.annotations.Rectangle;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Rectangle;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.annotations.Rectangle;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.Rectangle;
        fill(color: string, opacity?: number): anychart.core.annotations.Rectangle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Rectangle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Rectangle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.Rectangle;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.Rectangle;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.Rectangle;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.Rectangle;
        hatchFill(enabled?: boolean): anychart.core.annotations.Rectangle;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Rectangle;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Rectangle;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Rectangle;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Rectangle;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Rectangle;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Rectangle;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Rectangle;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Rectangle;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Rectangle;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Rectangle;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Rectangle;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.Rectangle;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.Rectangle;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Rectangle;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.Rectangle;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Rectangle;
        stroke(settings?: Object): anychart.core.annotations.Rectangle;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Rectangle;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Rectangle;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Rectangle;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Rectangle;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Rectangle;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Rectangle;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Rectangle;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Rectangle;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Rectangle;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Rectangle;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface AndrewsPitchfork extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.AndrewsPitchfork;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.AndrewsPitchfork;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.AndrewsPitchfork;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.AndrewsPitchfork;
        color(): string;
        color(color: string): anychart.core.annotations.AndrewsPitchfork;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.AndrewsPitchfork;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.AndrewsPitchfork;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.AndrewsPitchfork;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.AndrewsPitchfork;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.AndrewsPitchfork;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.AndrewsPitchfork;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.AndrewsPitchfork;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.AndrewsPitchfork;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.AndrewsPitchfork;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.AndrewsPitchfork;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.AndrewsPitchfork;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.AndrewsPitchfork;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.AndrewsPitchfork;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.AndrewsPitchfork;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.AndrewsPitchfork;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.AndrewsPitchfork;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.AndrewsPitchfork;
        stroke(settings?: Object): anychart.core.annotations.AndrewsPitchfork;
        thirdValueAnchor(): any;
        thirdValueAnchor(Third: any): anychart.core.annotations.AndrewsPitchfork;
        thirdXAnchor(): any;
        thirdXAnchor(Third: any): anychart.core.annotations.AndrewsPitchfork;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.AndrewsPitchfork;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.AndrewsPitchfork;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.AndrewsPitchfork;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.AndrewsPitchfork;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.AndrewsPitchfork;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.AndrewsPitchfork;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.AndrewsPitchfork;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.AndrewsPitchfork;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.AndrewsPitchfork;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.AndrewsPitchfork;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Base;
        color(): string;
        color(color: string): anychart.core.annotations.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Base;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Base;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Base;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface PlotController extends anychart.core.VisualBase {
        add(annotationTypeOrConfig: string | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        andrewsPitchfork(settings?: Object): anychart.core.annotations.AndrewsPitchfork;
        cancelDrawing(): void;
        ellipse(settings?: Object): anychart.core.annotations.Ellipse;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.PlotController;
        fibonacciArc(settings?: Object): anychart.core.annotations.FibonacciArc;
        fibonacciFan(settings?: Object): anychart.core.annotations.FibonacciFan;
        fibonacciRetracement(settings?: Object): anychart.core.annotations.FibonacciRetracement;
        fibonacciTimezones(settings?: Object): anychart.core.annotations.FibonacciTimezones;
        finiteTrendChannel(settings?: Object): anychart.core.annotations.FiniteTrendChannel;
        fromJson(config: Object | string): anychart.core.annotations.PlotController;
        fromXml(config: string | Node): anychart.core.annotations.PlotController;
        getAnnotationAt(index: number): anychart.core.annotations.Base;
        getAnnotationsCount(): number;
        getSelectedAnnotation(): anychart.core.annotations.Base;
        horizontalLine(settings?: Object): anychart.core.annotations.HorizontalLine;
        horizontalRange(settings?: Object): anychart.core.annotations.HorizontalRange;
        infiniteLine(settings?: Object): anychart.core.annotations.InfiniteLine;
        label(settings?: Object): anychart.core.annotations.Label;
        line(settings?: Object): anychart.core.annotations.Line;
        marker(settings?: Object): anychart.core.annotations.Marker;
        ray(settings?: Object): anychart.core.annotations.Ray;
        rectangle(settings?: Object): anychart.core.annotations.Rectangle;
        removeAllAnnotations(): anychart.core.annotations.PlotController;
        removeAnnotation(annotation: anychart.core.annotations.Base): anychart.core.annotations.PlotController;
        removeAnnotationAt(index: number): anychart.core.annotations.PlotController;
        select(annotation: anychart.core.annotations.Base): anychart.core.annotations.PlotController;
        startDrawing(annotationTypeOrConfig: string | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        toJson(stringify?: boolean): Object | string;
        toXml(asXmlNode?: boolean): string | Node;
        trendChannel(settings?: Object): anychart.core.annotations.TrendChannel;
        triangle(settings?: Object): anychart.core.annotations.Triangle;
        unselect(): anychart.core.annotations.PlotController;
        verticalLine(settings?: Object): anychart.core.annotations.VerticalLine;
        verticalRange(settings?: Object): anychart.core.annotations.VerticalRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.PlotController;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.PlotController;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.PlotController;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.PlotController;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface FibonacciBase extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.FibonacciBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.FibonacciBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.FibonacciBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.FibonacciBase;
        color(): string;
        color(color: string): anychart.core.annotations.FibonacciBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.FibonacciBase;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.FibonacciBase;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FibonacciBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.FibonacciBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciBase;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(levelsList?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.FibonacciBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.FibonacciBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.FibonacciBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.FibonacciBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.FibonacciBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.FibonacciBase;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.FibonacciBase;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.FibonacciBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciBase;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        stroke(settings?: Object): anychart.core.annotations.FibonacciBase;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciBase;
        trend(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciBase;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.FibonacciBase;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.FibonacciBase;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.FibonacciBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.FibonacciBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.FibonacciBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.FibonacciBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.FibonacciBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Triangle extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Triangle;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Triangle;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Triangle;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Triangle;
        color(): string;
        color(color: string): anychart.core.annotations.Triangle;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Triangle;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.annotations.Triangle;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.Triangle;
        fill(color: string, opacity?: number): anychart.core.annotations.Triangle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Triangle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Triangle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.Triangle;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.Triangle;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.Triangle;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.Triangle;
        hatchFill(enabled?: boolean): anychart.core.annotations.Triangle;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Triangle;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Triangle;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Triangle;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Triangle;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Triangle;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Triangle;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Triangle;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Triangle;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Triangle;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Triangle;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Triangle;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.Triangle;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.Triangle;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Triangle;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.Triangle;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Triangle;
        stroke(settings?: Object): anychart.core.annotations.Triangle;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Triangle;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Triangle;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Triangle;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Triangle;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Triangle;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Triangle;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Triangle;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Triangle;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Triangle;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Triangle;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface FibonacciRetracement extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.FibonacciRetracement;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.FibonacciRetracement;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.FibonacciRetracement;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.FibonacciRetracement;
        color(): string;
        color(color: string): anychart.core.annotations.FibonacciRetracement;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.FibonacciRetracement;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.FibonacciRetracement;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FibonacciRetracement;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.FibonacciRetracement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciRetracement;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.FibonacciRetracement;
        levels(): Array<number>;
        levels(levelsList?: Array<any>): anychart.core.annotations.FibonacciRetracement;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.FibonacciRetracement;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.FibonacciRetracement;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.FibonacciRetracement;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.FibonacciRetracement;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.FibonacciRetracement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.FibonacciRetracement;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.FibonacciRetracement;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciRetracement;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciRetracement;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.FibonacciRetracement;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciRetracement;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciRetracement;
        stroke(settings?: Object): anychart.core.annotations.FibonacciRetracement;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.FibonacciRetracement;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciRetracement;
        trend(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciRetracement;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciRetracement;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.FibonacciRetracement;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciRetracement;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.FibonacciRetracement;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.FibonacciRetracement;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.FibonacciRetracement;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.FibonacciRetracement;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.FibonacciRetracement;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.FibonacciRetracement;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface HorizontalRange extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.HorizontalRange;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.HorizontalRange;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.HorizontalRange;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.HorizontalRange;
        color(): string;
        color(color: string): anychart.core.annotations.HorizontalRange;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.HorizontalRange;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.annotations.HorizontalRange;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.HorizontalRange;
        fill(color: string, opacity?: number): anychart.core.annotations.HorizontalRange;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.HorizontalRange;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.HorizontalRange;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.HorizontalRange;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.HorizontalRange;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.HorizontalRange;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.HorizontalRange;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.HorizontalRange;
        hatchFill(enabled?: boolean): anychart.core.annotations.HorizontalRange;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.HorizontalRange;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.HorizontalRange;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.HorizontalRange;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.HorizontalRange;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.HorizontalRange;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.HorizontalRange;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.HorizontalRange;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.HorizontalRange;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.HorizontalRange;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.HorizontalRange;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.HorizontalRange;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.HorizontalRange;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.HorizontalRange;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.HorizontalRange;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.HorizontalRange;
        stroke(settings?: Object): anychart.core.annotations.HorizontalRange;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.HorizontalRange;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.HorizontalRange;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.HorizontalRange;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.HorizontalRange;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.HorizontalRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.HorizontalRange;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.HorizontalRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.HorizontalRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.HorizontalRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TrendChannel extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.TrendChannel;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.TrendChannel;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.TrendChannel;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.TrendChannel;
        color(): string;
        color(color: string): anychart.core.annotations.TrendChannel;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.TrendChannel;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.annotations.TrendChannel;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.TrendChannel;
        fill(color: string, opacity?: number): anychart.core.annotations.TrendChannel;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.TrendChannel;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.TrendChannel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.TrendChannel;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.TrendChannel;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.TrendChannel;
        hatchFill(enabled?: boolean): anychart.core.annotations.TrendChannel;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.TrendChannel;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.TrendChannel;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.TrendChannel;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.TrendChannel;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.TrendChannel;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.TrendChannel;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.TrendChannel;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.TrendChannel;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.TrendChannel;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.TrendChannel;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.TrendChannel;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.TrendChannel;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.TrendChannel;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.TrendChannel;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.TrendChannel;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.TrendChannel;
        stroke(settings?: Object): anychart.core.annotations.TrendChannel;
        thirdValueAnchor(): any;
        thirdValueAnchor(value: any): anychart.core.annotations.TrendChannel;
        thirdXAnchor(): any;
        thirdXAnchor(value: any): anychart.core.annotations.TrendChannel;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.TrendChannel;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.TrendChannel;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.TrendChannel;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.TrendChannel;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.TrendChannel;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.TrendChannel;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.TrendChannel;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.TrendChannel;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.TrendChannel;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.TrendChannel;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface VerticalLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.VerticalLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.VerticalLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.VerticalLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.VerticalLine;
        color(): string;
        color(color: string): anychart.core.annotations.VerticalLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.VerticalLine;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.VerticalLine;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.VerticalLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.VerticalLine;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.VerticalLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.VerticalLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.VerticalLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.VerticalLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.VerticalLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.VerticalLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.VerticalLine;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.VerticalLine;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.VerticalLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.VerticalLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.VerticalLine;
        stroke(settings?: Object): anychart.core.annotations.VerticalLine;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.VerticalLine;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.VerticalLine;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.VerticalLine;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.VerticalLine;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.VerticalLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.VerticalLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.VerticalLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.VerticalLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.VerticalLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface HorizontalLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.HorizontalLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.HorizontalLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.HorizontalLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.HorizontalLine;
        color(): string;
        color(color: string): anychart.core.annotations.HorizontalLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.HorizontalLine;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.HorizontalLine;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.HorizontalLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.HorizontalLine;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.HorizontalLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.HorizontalLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.HorizontalLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.HorizontalLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.HorizontalLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.HorizontalLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.HorizontalLine;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.HorizontalLine;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.HorizontalLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.HorizontalLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.HorizontalLine;
        stroke(settings?: Object): anychart.core.annotations.HorizontalLine;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.HorizontalLine;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.HorizontalLine;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.HorizontalLine;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.HorizontalLine;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.HorizontalLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.HorizontalLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.HorizontalLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.HorizontalLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.HorizontalLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ChartController extends anychart.core.Base {
        cancelDrawing(): void;
        getSelectedAnnotation(): anychart.core.annotations.Base;
        removeAllAnnotations(): anychart.core.annotations.ChartController;
        removeAnnotation(annotation: anychart.core.annotations.Base): anychart.core.annotations.ChartController;
        select(annotation: anychart.core.annotations.Base): anychart.core.annotations.ChartController;
        startDrawing(annotationTypeOrConfig: string | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        unselect(): anychart.core.annotations.ChartController;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface FibonacciArc extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.FibonacciArc;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.FibonacciArc;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.FibonacciArc;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.FibonacciArc;
        color(): string;
        color(color: string): anychart.core.annotations.FibonacciArc;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.FibonacciArc;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.FibonacciArc;
        hoverGap(): number;
        hoverGap(gap: any): anychart.core.annotations.FibonacciArc;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.FibonacciArc;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciArc;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.FibonacciArc;
        levels(): Array<number>;
        levels(levelsList?: Array<any>): anychart.core.annotations.FibonacciArc;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.FibonacciArc;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.FibonacciArc;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.FibonacciArc;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.FibonacciArc;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.FibonacciArc;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.FibonacciArc;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.FibonacciArc;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciArc;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciArc;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.FibonacciArc;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciArc;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        stroke(settings?: Object): anychart.core.annotations.FibonacciArc;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.FibonacciArc;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciArc;
        trend(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciArc;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.FibonacciArc;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciArc;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.FibonacciArc;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.FibonacciArc;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.FibonacciArc;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.FibonacciArc;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.FibonacciArc;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.FibonacciArc;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Line;
        color(): string;
        color(color: string): anychart.core.annotations.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Line;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Line;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Line;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Line;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Line;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.Line;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Line;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Line;
        stroke(settings?: Object): anychart.core.annotations.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Line;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Line;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Line;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Line;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface FibonacciTimezones extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.FibonacciTimezones;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.FibonacciTimezones;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.FibonacciTimezones;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.FibonacciTimezones;
        color(): string;
        color(color: string): anychart.core.annotations.FibonacciTimezones;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.FibonacciTimezones;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.FibonacciTimezones;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FibonacciTimezones;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.FibonacciTimezones;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.annotations.FibonacciTimezones;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.FibonacciTimezones;
        levels(): Array<number>;
        levels(levelsList?: Array<any>): anychart.core.annotations.FibonacciTimezones;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.FibonacciTimezones;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.FibonacciTimezones;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.FibonacciTimezones;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.FibonacciTimezones;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.FibonacciTimezones;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.FibonacciTimezones;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.FibonacciTimezones;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.FibonacciTimezones;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciTimezones;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        stroke(settings?: Object): anychart.core.annotations.FibonacciTimezones;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.FibonacciTimezones;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FibonacciTimezones;
        trend(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.FibonacciTimezones;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.FibonacciTimezones;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.FibonacciTimezones;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.FibonacciTimezones;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.FibonacciTimezones;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.FibonacciTimezones;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.FibonacciTimezones;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface FiniteTrendChannel extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.FiniteTrendChannel;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.FiniteTrendChannel;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.FiniteTrendChannel;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.FiniteTrendChannel;
        channelWidth(): any;
        channelWidth(value: any): anychart.core.annotations.FiniteTrendChannel;
        color(): string;
        color(color: string): anychart.core.annotations.FiniteTrendChannel;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.FiniteTrendChannel;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.annotations.FiniteTrendChannel;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.FiniteTrendChannel;
        fill(color: string, opacity?: number): anychart.core.annotations.FiniteTrendChannel;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.FiniteTrendChannel;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.FiniteTrendChannel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.FiniteTrendChannel;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.FiniteTrendChannel;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.FiniteTrendChannel;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.FiniteTrendChannel;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.FiniteTrendChannel;
        hatchFill(enabled?: boolean): anychart.core.annotations.FiniteTrendChannel;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.FiniteTrendChannel;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FiniteTrendChannel;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.FiniteTrendChannel;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.FiniteTrendChannel;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.FiniteTrendChannel;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.FiniteTrendChannel;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.FiniteTrendChannel;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.FiniteTrendChannel;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.FiniteTrendChannel;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.FiniteTrendChannel;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.FiniteTrendChannel;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.FiniteTrendChannel;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.FiniteTrendChannel;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.FiniteTrendChannel;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.FiniteTrendChannel;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FiniteTrendChannel;
        stroke(settings?: Object): anychart.core.annotations.FiniteTrendChannel;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.FiniteTrendChannel;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FiniteTrendChannel;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.FiniteTrendChannel;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FiniteTrendChannel;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.FiniteTrendChannel;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.FiniteTrendChannel;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.FiniteTrendChannel;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.FiniteTrendChannel;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.FiniteTrendChannel;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.FiniteTrendChannel;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Ellipse extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Ellipse;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Ellipse;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Ellipse;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Ellipse;
        color(): string;
        color(color: string): anychart.core.annotations.Ellipse;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Ellipse;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.annotations.Ellipse;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.Ellipse;
        fill(color: string, opacity?: number): anychart.core.annotations.Ellipse;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Ellipse;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Ellipse;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.Ellipse;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.Ellipse;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.Ellipse;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.Ellipse;
        hatchFill(enabled?: boolean): anychart.core.annotations.Ellipse;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Ellipse;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Ellipse;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Ellipse;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Ellipse;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Ellipse;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Ellipse;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Ellipse;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Ellipse;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Ellipse;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Ellipse;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Ellipse;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Ellipse;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Ellipse;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Ellipse;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.Ellipse;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ellipse;
        stroke(settings?: Object): anychart.core.annotations.Ellipse;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Ellipse;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Ellipse;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Ellipse;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Ellipse;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Ellipse;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Ellipse;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Ellipse;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Ellipse;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Ellipse;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Ellipse;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Marker;
        anchor(): string;
        anchor(value: string): anychart.core.annotations.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.annotations.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.annotations.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.annotations.Marker;
        color(): string;
        color(color: string): anychart.core.annotations.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.annotations.Marker;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.annotations.Marker;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.annotations.Marker;
        fill(color: string, opacity?: number): anychart.core.annotations.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.annotations.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.annotations.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.annotations.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.annotations.Marker;
        hatchFill(enabled?: boolean): anychart.core.annotations.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.annotations.Marker;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.annotations.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.annotations.Marker;
        markerType(): string;
        markerType(type: string): anychart.core.annotations.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.annotations.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.annotations.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.annotations.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.annotations.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.annotations.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.annotations.Marker;
        offsetX(): number | string;
        offsetX(value: number | string): anychart.core.annotations.Marker;
        offsetY(): number | string;
        offsetY(offset: number | string): anychart.core.annotations.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.annotations.Marker;
        select(): void;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.annotations.Marker;
        size(): number;
        size(size?: number): anychart.core.annotations.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.annotations.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Marker;
        stroke(settings?: Object): anychart.core.annotations.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.annotations.Marker;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.annotations.Marker;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Marker;
        xScale(): anychart.scales.Ordinal | anychart.scales.Linear | anychart.scales.Logarithmic | anychart.scales.StockScatterDateTime;
        xScale(settings?: anychart.scales.Base | anychart.scales.StockScatterDateTime | Object | string): anychart.core.annotations.Marker;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.annotations.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.annotations.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.annotations.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.annotations.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.annotations.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.axes {
    interface Surface extends anychart.core.axes.Linear {
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.Surface;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.Surface;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Surface;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Surface;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.Surface;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.Surface;
        orientation(): string;
        orientation(orientation?: string): anychart.core.axes.Surface;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.Surface;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axes.Surface;
        staggerLines(): number;
        staggerLines(count?: number): anychart.core.axes.Surface;
        staggerMaxLines(): number;
        staggerMaxLines(count?: number): anychart.core.axes.Surface;
        staggerMode(): boolean;
        staggerMode(enabled?: boolean): anychart.core.axes.Surface;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Surface;
        stroke(settings?: Object): anychart.core.axes.Surface;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.Surface;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.axes.Surface;
        value(): number;
        value(value?: number): anychart.core.axes.Surface;
        valueTarget(): anychart.core.axes.Surface;
        valueTarget(target?: anychart.core.axes.Linear): anychart.core.axes.Surface;
        width(): number | string;
        width(width?: number | string): anychart.core.axes.Surface;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Surface;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Surface;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Surface;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Surface;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface CircularTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.CircularTicks;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.axes.CircularTicks;
        fill(color: string, opacity?: number): anychart.core.axes.CircularTicks;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.CircularTicks;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.CircularTicks;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.CircularTicks;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.axes.CircularTicks;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.axes.CircularTicks;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.axes.CircularTicks;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.axes.CircularTicks;
        hatchFill(enabled?: boolean): anychart.core.axes.CircularTicks;
        length(): string;
        length(length?: number | string): anychart.core.axes.CircularTicks;
        position(): string;
        position(value?: string): anychart.core.axes.CircularTicks;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.axes.CircularTicks;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.CircularTicks;
        stroke(settings?: Object): anychart.core.axes.CircularTicks;
        type(): string | (() => void);
        type(type?: string | ((path:anychart.graphics.vector.Path,x:number,y:number,radius:number)=>void)): anychart.core.axes.CircularTicks;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.CircularTicks;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.CircularTicks;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.CircularTicks;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.CircularTicks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Timeline extends anychart.core.VisualBase {
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.axes.Timeline;
        fill(color: string, opacity?: number): anychart.core.axes.Timeline;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.Timeline;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.Timeline;
        height(): number;
        height(height: number): anychart.core.axes.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(config?: Object): anychart.core.axes.Timeline;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Timeline;
        stroke(settings?: Object): anychart.core.axes.Timeline;
        ticks(): anychart.core.axes.TimelineTicks;
        ticks(config?: Object): anychart.core.axes.Timeline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Timeline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Timeline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Timeline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Timeline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Timeline;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Polar extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Polar;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.axes.Polar;
        fill(color: string, opacity?: number): anychart.core.axes.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.Polar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.Polar;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Polar;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.Polar;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.Polar;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.Polar;
        scale(): anychart.scales.ScatterBase;
        scale(settings?: anychart.scales.ScatterBase | string | Object): anychart.core.axes.Polar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Polar;
        stroke(settings?: Object): anychart.core.axes.Polar;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.Polar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Polar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Polar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Polar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Linear extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Linear;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Linear;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.Linear;
        orientation(): string;
        orientation(orientation?: string): anychart.core.axes.Linear;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.Linear;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(count?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(count?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(enabled?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        stroke(settings?: Object): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.axes.Linear;
        value(): number;
        value(value?: number): anychart.core.axes.Linear;
        valueTarget(): anychart.core.axes.Linear;
        valueTarget(target?: anychart.core.axes.Linear): anychart.core.axes.Linear;
        width(): number | string;
        width(width?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Linear;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Linear;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Linear;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MapSettings extends anychart.core.VisualBase {
        bottom(): anychart.core.axes.Map;
        bottom(settings?: boolean | Object): anychart.core.axes.MapSettings;
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.MapSettings;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.MapSettings;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.MapSettings;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.MapSettings;
        left(): anychart.core.axes.Map;
        left(settings?: boolean | Object): anychart.core.axes.MapSettings;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.MapSettings;
        minorTicks(): anychart.core.axes.MapTicks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.MapSettings;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.MapSettings;
        right(): anychart.core.axes.Map;
        right(settings?: boolean | Object): anychart.core.axes.MapSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.MapSettings;
        stroke(settings?: Object): anychart.core.axes.MapSettings;
        ticks(): anychart.core.axes.MapTicks;
        ticks(settings?: Object | boolean): anychart.core.axes.MapSettings;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.axes.MapSettings;
        top(): anychart.core.axes.Map;
        top(settings?: boolean | Object): anychart.core.axes.MapSettings;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.MapSettings;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.MapSettings;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.MapSettings;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.MapSettings;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Radial extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.Radial;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.Radial;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Radial;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Radial;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.Radial;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.Radial;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.Radial;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axes.Radial;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radial;
        stroke(settings?: Object): anychart.core.axes.Radial;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.Radial;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Radial;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Radial;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Radial;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Radial;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Ticks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Ticks;
        length(): number;
        length(length?: number): anychart.core.axes.Ticks;
        position(): string;
        position(position?: string): anychart.core.axes.Ticks;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke): anychart.core.axes.Ticks;
        stroke(color?: string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Ticks;
        stroke(settings?: Object): anychart.core.axes.Ticks;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Ticks;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Ticks;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Ticks;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Ticks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SurfaceTicks extends anychart.core.axes.Ticks {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.SurfaceTicks;
        length(): number;
        length(length?: number): anychart.core.axes.SurfaceTicks;
        position(): string;
        position(position?: string): anychart.core.axes.SurfaceTicks;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke): anychart.core.axes.SurfaceTicks;
        stroke(color?: string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.SurfaceTicks;
        stroke(settings?: Object): anychart.core.axes.SurfaceTicks;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.SurfaceTicks;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.SurfaceTicks;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.SurfaceTicks;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.SurfaceTicks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Circular extends anychart.core.VisualBase {
        cornersRounding(): string;
        cornersRounding(radius?: number | string): anychart.core.axes.Circular;
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.Circular;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.Circular;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Circular;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.axes.Circular;
        fill(color: string, opacity?: number): anychart.core.axes.Circular;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.Circular;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.Circular;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.Circular;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Circular;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.Circular;
        minorTicks(): anychart.core.axes.CircularTicks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.Circular;
        overlapMode(): string;
        overlapMode(value?: string | boolean): anychart.core.axes.Circular;
        radius(): string;
        radius(value?: number | string): anychart.core.axes.Circular;
        scale(): anychart.scales.Linear | anychart.scales.Logarithmic;
        scale(settings?: string | anychart.scales.Linear | Object): anychart.core.axes.Circular;
        startAngle(): number;
        startAngle(value?: string | number): anychart.core.axes.Circular;
        sweepAngle(): number;
        sweepAngle(value?: string | number): anychart.core.axes.Circular;
        ticks(): anychart.core.axes.CircularTicks;
        ticks(settings?: Object | boolean): anychart.core.axes.Circular;
        width(): string;
        width(value?: number | string): anychart.core.axes.Circular;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Circular;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Circular;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Circular;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Circular;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StockDateTime extends anychart.core.VisualBase {
        background(): anychart.core.ui.Background;
        background(settings?: Object | boolean | string): anychart.core.axes.StockDateTime;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.StockDateTime;
        height(): number;
        height(height?: number): anychart.core.axes.StockDateTime;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.StockDateTime;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.StockDateTime;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.StockDateTime;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.StockDateTime;
        showHelperLabel(): boolean;
        showHelperLabel(settings?: boolean): anychart.core.axes.StockDateTime;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.StockDateTime;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.StockDateTime;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.StockDateTime;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.StockDateTime;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.StockDateTime;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Radar extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Radar;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Radar;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | string | Object): anychart.core.axes.Radar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radar;
        stroke(settings?: Object): anychart.core.axes.Radar;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.Radar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Radar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Radar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Radar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TimelineTicks extends anychart.core.VisualBase {
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke): anychart.core.axes.TimelineTicks;
        stroke(color?: string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.TimelineTicks;
        stroke(settings?: Object): anychart.core.axes.TimelineTicks;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.TimelineTicks;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.TimelineTicks;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.TimelineTicks;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.TimelineTicks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.TimelineTicks;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface LinearGauge extends anychart.core.axes.Linear {
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.LinearGauge;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.LinearGauge;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.LinearGauge;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.LinearGauge;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.LinearGauge;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.LinearGauge;
        offset(): string;
        offset(offset?: string): anychart.core.axes.LinearGauge;
        orientation(): string;
        orientation(orientation?: string): anychart.core.axes.LinearGauge;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.axes.LinearGauge;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.axes.LinearGauge;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.axes.LinearGauge;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axes.LinearGauge;
        staggerLines(): number;
        staggerLines(count?: number): anychart.core.axes.LinearGauge;
        staggerMaxLines(): number;
        staggerMaxLines(count?: number): anychart.core.axes.LinearGauge;
        staggerMode(): boolean;
        staggerMode(enabled?: boolean): anychart.core.axes.LinearGauge;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.LinearGauge;
        stroke(settings?: Object): anychart.core.axes.LinearGauge;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.axes.LinearGauge;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.axes.LinearGauge;
        width(): number | string;
        width(width?: number | string): anychart.core.axes.LinearGauge;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.LinearGauge;
        value(): number;
        value(value?: number): anychart.core.axes.LinearGauge;
        valueTarget(): anychart.core.axes.LinearGauge;
        valueTarget(target?: anychart.core.axes.Linear): anychart.core.axes.LinearGauge;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.LinearGauge;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.LinearGauge;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.LinearGauge;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MapTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.MapTicks;
        length(): number;
        length(length?: number | string): anychart.core.axes.MapTicks;
        position(): string;
        position(position?: string): anychart.core.axes.MapTicks;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.MapTicks;
        stroke(settings?: Object): anychart.core.axes.MapTicks;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.MapTicks;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.MapTicks;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.MapTicks;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.MapTicks;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Map extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.axes.Map;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.axes.Map;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axes.Map;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.axes.Map;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.axes.Map;
        minorTicks(): anychart.core.axes.MapTicks;
        minorTicks(settings?: Object | boolean): anychart.core.axes.Map;
        overlapMode(): string;
        overlapMode(value?: string): anychart.core.axes.Map;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Map;
        stroke(settings?: Object): anychart.core.axes.Map;
        ticks(): anychart.core.axes.MapTicks;
        ticks(settings?: Object | boolean): anychart.core.axes.Map;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.axes.Map;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axes.Map;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axes.Map;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axes.Map;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axes.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.axisMarkers {
    interface GanttLine extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.GanttLine;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.core.axisMarkers.GanttLine;
        scale(): anychart.scales.GanttDateTime;
        scale(scale?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.GanttLine;
        stroke(settings?: Object): anychart.core.axisMarkers.GanttLine;
        value(): number | string;
        value(value?: number | string): anychart.core.axisMarkers.GanttLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.GanttLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.GanttLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.GanttLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.GanttLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface GanttText extends anychart.core.Text {
        align(): string;
        align(align?: string): anychart.core.axisMarkers.GanttText;
        anchor(): string;
        anchor(anchor?: string): anychart.core.axisMarkers.GanttText;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.axisMarkers.GanttText;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.axisMarkers.GanttText;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.GanttText;
        fontColor(): string;
        fontColor(color?: string): anychart.core.axisMarkers.GanttText;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.axisMarkers.GanttText;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.axisMarkers.GanttText;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.axisMarkers.GanttText;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.axisMarkers.GanttText;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.axisMarkers.GanttText;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.axisMarkers.GanttText;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.axisMarkers.GanttText;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.axisMarkers.GanttText;
        height(): number | string;
        height(height?: number | string): anychart.core.axisMarkers.GanttText;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.core.axisMarkers.GanttText;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.axisMarkers.GanttText;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.axisMarkers.GanttText;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.axisMarkers.GanttText;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.axisMarkers.GanttText;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.axisMarkers.GanttText;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.axisMarkers.GanttText;
        rotation(): number;
        rotation(rotation?: number): anychart.core.axisMarkers.GanttText;
        scale(): anychart.scales.GanttDateTime;
        scale(scale?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttText;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.axisMarkers.GanttText;
        text(): string;
        text(text?: string): anychart.core.axisMarkers.GanttText;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.axisMarkers.GanttText;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.axisMarkers.GanttText;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.axisMarkers.GanttText;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.axisMarkers.GanttText;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.axisMarkers.GanttText;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.axisMarkers.GanttText;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.axisMarkers.GanttText;
        value(): number | string;
        value(value?: number | string): anychart.core.axisMarkers.GanttText;
        width(): number | string;
        width(width?: number | string): anychart.core.axisMarkers.GanttText;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.axisMarkers.GanttText;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.axisMarkers.GanttText;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.GanttText;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.axisMarkers.GanttText;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.GanttText;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.GanttText;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.GanttText;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface GanttRange extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.GanttRange;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.core.axisMarkers.GanttRange;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.GanttRange;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.GanttRange;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.GanttRange;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.GanttRange;
        from(): number | string;
        from(fromValue?: number | string): anychart.core.axisMarkers.GanttRange;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.core.axisMarkers.GanttRange;
        scale(): anychart.scales.GanttDateTime;
        scale(scale?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttRange;
        to(): number | string;
        to(toValue?: number | string): anychart.core.axisMarkers.GanttRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.GanttRange;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.GanttRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.GanttRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.GanttRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface CircularRange extends anychart.core.VisualBase {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.axisMarkers.CircularRange;
        cornersRounding(): string;
        cornersRounding(value?: number | string): anychart.core.axisMarkers.CircularRange;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.CircularRange;
        endSize(): string;
        endSize(value?: number | string): anychart.core.axisMarkers.CircularRange;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.axisMarkers.CircularRange;
        from(): number;
        from(fromValue?: number): anychart.core.axisMarkers.CircularRange;
        position(): string;
        position(positionType?: string): anychart.core.axisMarkers.CircularRange;
        radius(): string;
        radius(value?: number | string): anychart.core.axisMarkers.CircularRange;
        startSize(): string;
        startSize(value?: number | string): anychart.core.axisMarkers.CircularRange;
        to(): number;
        to(toValue?: number): anychart.core.axisMarkers.CircularRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.CircularRange;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.CircularRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.CircularRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.CircularRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Text extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.annotations.Label;
        align(): string;
        align(align?: string): anychart.core.axisMarkers.Text;
        anchor(): string;
        anchor(anchor?: string): anychart.core.axisMarkers.Text;
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.axisMarkers.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.axisMarkers.Text;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.Text;
        fontColor(): string;
        fontColor(color?: string): anychart.core.axisMarkers.Text;
        fontColor(): string;
        fontColor(color?: string): anychart.core.axisMarkers.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.axisMarkers.Text;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.axisMarkers.Text;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.axisMarkers.Text;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.axisMarkers.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.axisMarkers.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.axisMarkers.Text;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.axisMarkers.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.axisMarkers.Text;
        height(): number | string;
        height(height?: number | string): anychart.core.axisMarkers.Text;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.core.axisMarkers.Text;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.axisMarkers.Text;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.axisMarkers.Text;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.axisMarkers.Text;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.axisMarkers.Text;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.axisMarkers.Text;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.axisMarkers.Text;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.axisMarkers.Text;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.axisMarkers.Text;
        position(): string;
        position(position?: string): anychart.core.axisMarkers.Text;
        rotation(): number;
        rotation(rotation?: number): anychart.core.axisMarkers.Text;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axisMarkers.Text;
        scaleRangeMode(): string;
        scaleRangeMode(mode?: string): anychart.core.axisMarkers.Text;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.axisMarkers.Text;
        text(): string;
        text(text?: string): anychart.core.axisMarkers.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.axisMarkers.Text;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.axisMarkers.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.axisMarkers.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.axisMarkers.Text;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.axisMarkers.Text;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.axisMarkers.Text;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.axisMarkers.Text;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.axisMarkers.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.axisMarkers.Text;
        value(): number;
        value(value?: number): anychart.core.axisMarkers.Text;
        width(): number | string;
        width(width?: number | string): anychart.core.axisMarkers.Text;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.axisMarkers.Text;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.axisMarkers.Text;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.Text;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.Text;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.Text;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.Text;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface CurrentPriceIndicator extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(indexOrAxis?: number | anychart.core.axes.Linear): anychart.core.axisMarkers.CurrentPriceIndicator;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.CurrentPriceIndicator;
        fallingLabel(): anychart.core.ui.Label;
        fallingLabel(index?: string | number, settings?: boolean | Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.CurrentPriceIndicator;
        fallingStroke(settings?: Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        label(): anychart.core.ui.LabelsFactory;
        label(index?: string | number, settings?: boolean | Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        risingLabel(): anychart.core.ui.Label;
        risingLabel(index?: string | number, settings?: boolean | Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.CurrentPriceIndicator;
        risingStroke(settings?: Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        series(): anychart.core.stock.series.Base;
        series(indexOrSeries?: number | anychart.core.stock.series.Base): anychart.core.axisMarkers.CurrentPriceIndicator;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.CurrentPriceIndicator;
        stroke(settings?: Object): anychart.core.axisMarkers.CurrentPriceIndicator;
        value(): string | number | Date;
        value(value?: string | number | Date): anychart.core.axisMarkers.CurrentPriceIndicator;
        valueField(): string;
        valueField(fieldName: string): string;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.CurrentPriceIndicator;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.CurrentPriceIndicator;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.CurrentPriceIndicator;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.CurrentPriceIndicator;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.Line;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.core.axisMarkers.Line;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axisMarkers.Line;
        scaleRangeMode(): string;
        scaleRangeMode(mode?: string): anychart.core.axisMarkers.Line;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.Line;
        stroke(settings?: Object): anychart.core.axisMarkers.Line;
        value(): number;
        value(newValue?: number): anychart.core.axisMarkers.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Range extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.axisMarkers.Range;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.axisMarkers.Range;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.Range;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        from(): number;
        from(fromValue?: number): anychart.core.axisMarkers.Range;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.core.axisMarkers.Range;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.axisMarkers.Range;
        scaleRangeMode(): string;
        scaleRangeMode(mode?: string): anychart.core.axisMarkers.Range;
        to(): number;
        to(toValue?: number): anychart.core.axisMarkers.Range;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.axisMarkers.Range;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.axisMarkers.Range;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.axisMarkers.Range;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.axisMarkers.Range;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.calendar {
}

declare namespace anychart.core.calendar.settings {
    interface Months extends anychart.core.Base {
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.calendar.settings.Months;
        noDataStroke(): anychart.graphics.vector.Stroke;
        noDataStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.calendar.settings.Months;
        noDataStroke(settings?: Object): anychart.core.calendar.settings.Months;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.calendar.settings.Months;
        stroke(settings?: Object): anychart.core.calendar.settings.Months;
        underSpace(): number;
        underSpace(value: number): anychart.core.calendar.settings.Months;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Weeks extends anychart.core.Base {
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.calendar.settings.Weeks;
        rightSpace(): number;
        rightSpace(value: number): anychart.core.calendar.settings.Weeks;
        showWeekends(): boolean;
        showWeekends(value: boolean): anychart.core.calendar.settings.Weeks;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Years extends anychart.core.Base {
        background(): anychart.core.ui.Background;
        background(settings?: Object): anychart.core.calendar.settings.Years;
        inverted(): boolean;
        inverted(value: boolean): anychart.core.calendar.settings.Years;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.calendar.settings.Years;
        underSpace(): number;
        underSpace(value: number): anychart.core.calendar.settings.Years;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Days extends anychart.core.Base {
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.calendar.settings.Days;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.calendar.settings.Days;
        fill(color: string, opacity?: number): anychart.core.calendar.settings.Days;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.calendar.settings.Days;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.calendar.settings.Days;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.calendar.settings.Days;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.calendar.settings.Days;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.calendar.settings.Days;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.calendar.settings.Days;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.calendar.settings.Days;
        hatchFill(enabled?: boolean): anychart.core.calendar.settings.Days;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.calendar.settings.Days;
        noDataFill(): anychart.graphics.vector.Fill;
        noDataFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.calendar.settings.Days;
        noDataFill(color: string, opacity?: number): anychart.core.calendar.settings.Days;
        noDataFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.calendar.settings.Days;
        noDataFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.calendar.settings.Days;
        noDataFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.calendar.settings.Days;
        noDataHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        noDataHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.calendar.settings.Days;
        noDataHatchFill(hatchFillFunction?: (() => void)): anychart.core.calendar.settings.Days;
        noDataHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.calendar.settings.Days;
        noDataHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.calendar.settings.Days;
        noDataHatchFill(enabled?: boolean): anychart.core.calendar.settings.Days;
        noDataStroke(): anychart.graphics.vector.Stroke;
        noDataStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.calendar.settings.Days;
        noDataStroke(settings?: Object): anychart.core.calendar.settings.Days;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.calendar.settings.Days;
        spacing(): number;
        spacing(value: number): anychart.core.calendar.settings.Days;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.calendar.settings.Days;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.calendar.settings.Days;
        stroke(settings?: Object): anychart.core.calendar.settings.Days;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.cartesian {
}

declare namespace anychart.core.cartesian.series {
    interface ContinuousBase extends anychart.core.cartesian.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.ContinuousBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.ContinuousBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.ContinuousBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.ContinuousBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.ContinuousBase;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.ContinuousBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.ContinuousBase;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.ContinuousBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.ContinuousBase;
        hover(): anychart.core.cartesian.series.ContinuousBase;
        hover(index?: number): anychart.core.cartesian.series.ContinuousBase;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.ContinuousBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.ContinuousBase;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.ContinuousBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.ContinuousBase;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.ContinuousBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.ContinuousBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.ContinuousBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.ContinuousBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.ContinuousBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.ContinuousBase;
        meta(key?: string, value?: any): anychart.core.cartesian.series.ContinuousBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.ContinuousBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.ContinuousBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.ContinuousBase;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.ContinuousBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.ContinuousBase;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.ContinuousBase;
        select(index?: number): anychart.core.cartesian.series.ContinuousBase;
        select(indexes?: Array<number>): anychart.core.cartesian.series.ContinuousBase;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.ContinuousBase;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.ContinuousBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.ContinuousBase;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.ContinuousBase;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unselect(): anychart.core.cartesian.series.ContinuousBase;
        unselect(index?: number): anychart.core.cartesian.series.ContinuousBase;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.ContinuousBase;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.ContinuousBase;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.ContinuousBase;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.ContinuousBase;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.ContinuousBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.ContinuousBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.ContinuousBase;
        getStat(key: string): any;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.ContinuousBase;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.ContinuousBase;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.ContinuousBase;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.ContinuousBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.ContinuousBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.ContinuousBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.ContinuousBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Box extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Box;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Box;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Box;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Box;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Box;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Box;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Box;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Box;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Box;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Box;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Box;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Box;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Box;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Box;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Box;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Box;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Box;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Box;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Box;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Box;
        hover(): anychart.core.cartesian.series.Box;
        hover(index?: number): anychart.core.cartesian.series.Box;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Box;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Box;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Box;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Box;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Box;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Box;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Box;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Box;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Box;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Box;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Box;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Box;
        medianStroke(): anychart.graphics.vector.Stroke | (() => void);
        medianStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Box;
        medianStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        medianStroke(settings?: Object): anychart.core.cartesian.series.Box;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Box;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Box;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Box;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Box;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Box;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Box;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Box;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Box;
        outlierMarkers(): anychart.core.ui.MarkersFactory;
        outlierMarkers(settings?: Object | boolean | string): anychart.core.cartesian.series.Box;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Box;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Box;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Box;
        select(index?: number): anychart.core.cartesian.series.Box;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Box;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Box;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Box;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Box;
        stemStroke(): anychart.graphics.vector.Stroke | (() => void);
        stemStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Box;
        stemStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        stemStroke(settings?: Object): anychart.core.cartesian.series.Box;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Box;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        stroke(settings?: Object): anychart.core.cartesian.series.Box;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Box;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Box;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Box;
        unselect(): anychart.core.cartesian.series.Box;
        unselect(index?: number): anychart.core.cartesian.series.Box;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Box;
        whiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        whiskerStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Box;
        whiskerStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        whiskerStroke(settings?: Object): anychart.core.cartesian.series.Box;
        whiskerWidth(): number | string;
        whiskerWidth(width?: number | string): anychart.core.cartesian.series.Box;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Box;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Box;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Box;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Box;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Box;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Box;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Box;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Box;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Box;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line3d extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Line3d;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Line3d;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Line3d;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Line3d;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Line3d;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Line3d;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Line3d;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.Line3d;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line3d;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Line3d;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Line3d;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Line3d;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Line3d;
        hover(): anychart.core.cartesian.series.Line3d;
        hover(index?: number): anychart.core.cartesian.series.Line3d;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Line3d;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Line3d;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Line3d;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Line3d;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Line3d;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Line3d;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Line3d;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Line3d;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Line3d;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Line3d;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Line3d;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Line3d;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Line3d;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Line3d;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Line3d;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Line3d;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Line3d;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Line3d;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Line3d;
        select(index?: number): anychart.core.cartesian.series.Line3d;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Line3d;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Line3d;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Line3d;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Line3d;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Line3d;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Line3d;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Line3d;
        unselect(): anychart.core.cartesian.series.Line3d;
        unselect(index?: number): anychart.core.cartesian.series.Line3d;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Line3d;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Line3d;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Line3d;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Line3d;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Line3d;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Line3d;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Line3d;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Line3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Line3d;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Line3d;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Line3d;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SplineArea extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.SplineArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.SplineArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.SplineArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.SplineArea;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.SplineArea;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.SplineArea;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.SplineArea;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.SplineArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.SplineArea;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.SplineArea;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.SplineArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.SplineArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.SplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.SplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.SplineArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.SplineArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.SplineArea;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.SplineArea;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.SplineArea;
        hover(): anychart.core.cartesian.series.SplineArea;
        hover(index?: number): anychart.core.cartesian.series.SplineArea;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.SplineArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.SplineArea;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.SplineArea;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.SplineArea;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.SplineArea;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.SplineArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.SplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.SplineArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.SplineArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.SplineArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.SplineArea;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.SplineArea;
        meta(key?: string, value?: any): anychart.core.cartesian.series.SplineArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.SplineArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.SplineArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.SplineArea;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.SplineArea;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.SplineArea;
        negativeFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.SplineArea;
        negativeFill(color: string, opacity?: number): anychart.core.cartesian.series.SplineArea;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.SplineArea;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.SplineArea;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.SplineArea;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.SplineArea;
        negativeStroke(settings?: Object): anychart.core.cartesian.series.SplineArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.SplineArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.SplineArea;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.SplineArea;
        select(index?: number): anychart.core.cartesian.series.SplineArea;
        select(indexes?: Array<number>): anychart.core.cartesian.series.SplineArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.SplineArea;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.SplineArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.SplineArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.SplineArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.SplineArea;
        stroke(settings?: Object): anychart.core.cartesian.series.SplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.SplineArea;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.SplineArea;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.SplineArea;
        unselect(): anychart.core.cartesian.series.SplineArea;
        unselect(index?: number): anychart.core.cartesian.series.SplineArea;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.SplineArea;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.SplineArea;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.SplineArea;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.SplineArea;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.SplineArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.SplineArea;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.SplineArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.SplineArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.SplineArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.SplineArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Spline extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Spline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Spline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Spline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Spline;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Spline;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Spline;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Spline;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.Spline;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Spline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Spline;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Spline;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Spline;
        hover(): anychart.core.cartesian.series.Spline;
        hover(index?: number): anychart.core.cartesian.series.Spline;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Spline;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Spline;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Spline;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Spline;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Spline;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Spline;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Spline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Spline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Spline;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Spline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Spline;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Spline;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Spline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Spline;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Spline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Spline;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Spline;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Spline;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Spline;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Spline;
        select(index?: number): anychart.core.cartesian.series.Spline;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Spline;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Spline;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Spline;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Spline;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Spline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Spline;
        stroke(settings?: Object): anychart.core.cartesian.series.Spline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Spline;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Spline;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Spline;
        unselect(): anychart.core.cartesian.series.Spline;
        unselect(index?: number): anychart.core.cartesian.series.Spline;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Spline;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Spline;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Spline;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Spline;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Spline;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Spline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Spline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Spline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Spline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Spline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DiscreteBase extends anychart.core.cartesian.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.DiscreteBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        unhover(): anychart.core.cartesian.series.DiscreteBase;
        unhover(index?: number): anychart.core.cartesian.series.DiscreteBase;
        unhover(indexes?: Array<number>): anychart.core.cartesian.series.DiscreteBase;
        unselect(): anychart.core.cartesian.series.DiscreteBase;
        unselect(index?: number): anychart.core.cartesian.series.DiscreteBase;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.DiscreteBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.DiscreteBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.DiscreteBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.DiscreteBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.DiscreteBase;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.DiscreteBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.DiscreteBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.DiscreteBase;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.DiscreteBase;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.DiscreteBase;
        hover(): anychart.core.cartesian.series.DiscreteBase;
        hover(index?: number): anychart.core.cartesian.series.DiscreteBase;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.DiscreteBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.DiscreteBase;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.DiscreteBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.DiscreteBase;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.DiscreteBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.DiscreteBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.DiscreteBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.DiscreteBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.DiscreteBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.DiscreteBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.DiscreteBase;
        meta(key?: string, value?: any): anychart.core.cartesian.series.DiscreteBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.DiscreteBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.DiscreteBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.DiscreteBase;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.DiscreteBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.DiscreteBase;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.DiscreteBase;
        select(index?: number): anychart.core.cartesian.series.DiscreteBase;
        select(indexes?: Array<number>): anychart.core.cartesian.series.DiscreteBase;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.DiscreteBase;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.DiscreteBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.DiscreteBase;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.DiscreteBase;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.DiscreteBase;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.DiscreteBase;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.DiscreteBase;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.DiscreteBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.DiscreteBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.DiscreteBase;
        getStat(key: string): any;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.DiscreteBase;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.DiscreteBase;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.DiscreteBase;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.DiscreteBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.DiscreteBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.DiscreteBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeStepArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.RangeStepArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.RangeStepArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.RangeStepArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.RangeStepArea;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.RangeStepArea;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.RangeStepArea;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.RangeStepArea;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeStepArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.RangeStepArea;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.RangeStepArea;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeStepArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeStepArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.RangeStepArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.RangeStepArea;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.RangeStepArea;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.RangeStepArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeStepArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        highStroke(settings?: Object): anychart.core.cartesian.series.RangeStepArea;
        hover(): anychart.core.cartesian.series.RangeStepArea;
        hover(index?: number): anychart.core.cartesian.series.RangeStepArea;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.RangeStepArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.RangeStepArea;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.RangeStepArea;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.RangeStepArea;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.RangeStepArea;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.RangeStepArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.RangeStepArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeStepArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        lowStroke(settings?: Object): anychart.core.cartesian.series.RangeStepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.RangeStepArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.RangeStepArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeStepArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.RangeStepArea;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.RangeStepArea;
        meta(key?: string, value?: any): anychart.core.cartesian.series.RangeStepArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.RangeStepArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeStepArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.RangeStepArea;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.RangeStepArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.RangeStepArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.RangeStepArea;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.RangeStepArea;
        select(index?: number): anychart.core.cartesian.series.RangeStepArea;
        select(indexes?: Array<number>): anychart.core.cartesian.series.RangeStepArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.RangeStepArea;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.RangeStepArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.RangeStepArea;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.cartesian.series.RangeStepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.RangeStepArea;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.RangeStepArea;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.RangeStepArea;
        unselect(): anychart.core.cartesian.series.RangeStepArea;
        unselect(index?: number): anychart.core.cartesian.series.RangeStepArea;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.RangeStepArea;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.RangeStepArea;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.RangeStepArea;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeStepArea;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeStepArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.RangeStepArea;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.RangeStepArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.RangeStepArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.RangeStepArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.RangeStepArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StepArea extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.StepArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.StepArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.StepArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.StepArea;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.StepArea;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.StepArea;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.StepArea;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.StepArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.StepArea;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.StepArea;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.StepArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.StepArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.StepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.StepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.StepArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.StepArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.StepArea;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.StepArea;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.StepArea;
        hover(): anychart.core.cartesian.series.StepArea;
        hover(index?: number): anychart.core.cartesian.series.StepArea;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.StepArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.StepArea;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.StepArea;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.StepArea;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.StepArea;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.StepArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.StepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.StepArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.StepArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.StepArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.StepArea;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.StepArea;
        meta(key?: string, value?: any): anychart.core.cartesian.series.StepArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.StepArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.StepArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.StepArea;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.StepArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.StepArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.StepArea;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.StepArea;
        select(index?: number): anychart.core.cartesian.series.StepArea;
        select(indexes?: Array<number>): anychart.core.cartesian.series.StepArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.StepArea;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.StepArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.StepArea;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.cartesian.series.StepArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.StepArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepArea;
        stroke(settings?: Object): anychart.core.cartesian.series.StepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.StepArea;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.StepArea;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.StepArea;
        unselect(): anychart.core.cartesian.series.StepArea;
        unselect(index?: number): anychart.core.cartesian.series.StepArea;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.StepArea;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.StepArea;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.StepArea;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.StepArea;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.StepArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.StepArea;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.StepArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.StepArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.StepArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.StepArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.SeriesBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Base;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Base;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Base;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Base;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Base;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Base;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Base;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Base;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Base;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Base;
        select(index?: number): anychart.core.cartesian.series.Base;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Base;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Base;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Base;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Base;
        unselect(): anychart.core.cartesian.series.Base;
        unselect(index?: number): anychart.core.cartesian.series.Base;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Base;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Base;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Base;
        hover(): anychart.core.cartesian.series.Base;
        hover(index?: number): anychart.core.cartesian.series.Base;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeBar extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.RangeBar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.RangeBar;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.RangeBar;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.RangeBar;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.RangeBar;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.RangeBar;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeBar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.RangeBar;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.RangeBar;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeBar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeBar;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeBar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeBar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeBar;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.RangeBar;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.RangeBar;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.RangeBar;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.RangeBar;
        hover(): anychart.core.cartesian.series.RangeBar;
        hover(index?: number): anychart.core.cartesian.series.RangeBar;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.RangeBar;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.RangeBar;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.RangeBar;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.RangeBar;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.RangeBar;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.RangeBar;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.RangeBar;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.RangeBar;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.RangeBar;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeBar;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.RangeBar;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.RangeBar;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.RangeBar;
        meta(key?: string, value?: any): anychart.core.cartesian.series.RangeBar;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.RangeBar;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeBar;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.RangeBar;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.RangeBar;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.RangeBar;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.RangeBar;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.RangeBar;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.RangeBar;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.RangeBar;
        select(index?: number): anychart.core.cartesian.series.RangeBar;
        select(indexes?: Array<number>): anychart.core.cartesian.series.RangeBar;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.RangeBar;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.RangeBar;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.RangeBar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeBar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeBar;
        stroke(settings?: Object): anychart.core.cartesian.series.RangeBar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.RangeBar;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.RangeBar;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.RangeBar;
        unselect(): anychart.core.cartesian.series.RangeBar;
        unselect(index?: number): anychart.core.cartesian.series.RangeBar;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.RangeBar;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.RangeBar;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.RangeBar;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.RangeBar;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeBar;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeBar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.RangeBar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.RangeBar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.RangeBar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.RangeBar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Column3d extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Column3d;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Column3d;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Column3d;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Column3d;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Column3d;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column3d;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Column3d;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Column3d;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Column3d;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Column3d;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.cartesian.series.Column3d;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Column3d;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Column3d;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Column3d;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Column3d;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Column3d;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Column3d;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Column3d;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Column3d;
        hover(): anychart.core.cartesian.series.Column3d;
        hover(index?: number): anychart.core.cartesian.series.Column3d;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Column3d;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Column3d;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Column3d;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Column3d;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Column3d;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Column3d;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Column3d;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Column3d;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Column3d;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Column3d;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Column3d;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Column3d;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Column3d;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Column3d;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Column3d;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Column3d;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Column3d;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Column3d;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Column3d;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Column3d;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Column3d;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Column3d;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Column3d;
        select(index?: number): anychart.core.cartesian.series.Column3d;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Column3d;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Column3d;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Column3d;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Column3d;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Column3d;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Column3d;
        stroke(settings?: Object): anychart.core.cartesian.series.Column3d;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Column3d;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Column3d;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Column3d;
        unselect(): anychart.core.cartesian.series.Column3d;
        unselect(index?: number): anychart.core.cartesian.series.Column3d;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Column3d;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Column3d;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Column3d;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Column3d;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Column3d;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Column3d;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Column3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Column3d;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Column3d;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Column3d;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ContinuousRangeBase extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.ContinuousRangeBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.ContinuousRangeBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.ContinuousRangeBase;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.ContinuousRangeBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.ContinuousRangeBase;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.ContinuousRangeBase;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.ContinuousRangeBase;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.ContinuousRangeBase;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        highStroke(settings?: Object): anychart.core.cartesian.series.ContinuousRangeBase;
        hover(): anychart.core.cartesian.series.ContinuousRangeBase;
        hover(index?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.ContinuousRangeBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.ContinuousRangeBase;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.ContinuousRangeBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.ContinuousRangeBase;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.ContinuousRangeBase;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        lowStroke(settings?: Object): anychart.core.cartesian.series.ContinuousRangeBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.ContinuousRangeBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.ContinuousRangeBase;
        meta(key?: string, value?: any): anychart.core.cartesian.series.ContinuousRangeBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.ContinuousRangeBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.ContinuousRangeBase;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        select(index?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        select(indexes?: Array<number>): anychart.core.cartesian.series.ContinuousRangeBase;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.ContinuousRangeBase;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.ContinuousRangeBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousRangeBase;
        unselect(): anychart.core.cartesian.series.ContinuousRangeBase;
        unselect(index?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.ContinuousRangeBase;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.ContinuousRangeBase;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.ContinuousRangeBase;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.ContinuousRangeBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.ContinuousRangeBase;
        getStat(key: string): any;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.ContinuousRangeBase;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.ContinuousRangeBase;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.ContinuousRangeBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.ContinuousRangeBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.ContinuousRangeBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Area extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Area;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Area;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Area;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Area;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Area;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Area;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.Area;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Area;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Area;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Area;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Area;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Area;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Area;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Area;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Area;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Area;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Area;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Area;
        hover(): anychart.core.cartesian.series.Area;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Area;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Area;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Area;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Area;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Area;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Area;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Area;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Area;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Area;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Area;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Area;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Area;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Area;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Area;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Area;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Area;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Area;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Area;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Area;
        select(): anychart.core.cartesian.series.Area;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Area;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Area;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Area;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area;
        stroke(settings?: Object): anychart.core.cartesian.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.cartesian.series.Area;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Area;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Area;
        unselect(): anychart.core.cartesian.series.Area;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Area;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Area;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Area;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Area;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Area;
        getPixelPointWidth(): number;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Area;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Area;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Area;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Area;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Stick extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Stick;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Stick;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Stick;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Stick;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Stick;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Stick;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Stick;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Stick;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Stick;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Stick;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Stick;
        hover(): anychart.core.cartesian.series.Stick;
        hover(index?: number): anychart.core.cartesian.series.Stick;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Stick;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Stick;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Stick;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Stick;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Stick;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Stick;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Stick;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Stick;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Stick;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Stick;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Stick;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Stick;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Stick;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Stick;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Stick;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Stick;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Stick;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Stick;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Stick;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Stick;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Stick;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Stick;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Stick;
        select(index?: number): anychart.core.cartesian.series.Stick;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Stick;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Stick;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Stick;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Stick;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Stick;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Stick;
        stroke(settings?: Object): anychart.core.cartesian.series.Stick;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Stick;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Stick;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Stick;
        unselect(): anychart.core.cartesian.series.Stick;
        unselect(index?: number): anychart.core.cartesian.series.Stick;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Stick;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Stick;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Stick;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Stick;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Stick;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Stick;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Stick;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Stick;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Stick;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Stick;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bubble extends anychart.core.cartesian.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Bubble;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Bubble;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Bubble;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Bubble;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Bubble;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Bubble;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bubble;
        displayNegative(): boolean;
        displayNegative(enabled?: boolean): anychart.core.cartesian.series.Bubble;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Bubble;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Bubble;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Bubble;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Bubble;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Bubble;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Bubble;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Bubble;
        hover(): anychart.core.cartesian.series.Bubble;
        hover(index?: number): anychart.core.cartesian.series.Bubble;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Bubble;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Bubble;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Bubble;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Bubble;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Bubble;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Bubble;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Bubble;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Bubble;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Bubble;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Bubble;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Bubble;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Bubble;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Bubble;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Bubble;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Bubble;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Bubble;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Bubble;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Bubble;
        negativeFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(enabled?: boolean): anychart.core.cartesian.series.Bubble;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Bubble;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        negativeStroke(settings?: Object): anychart.core.cartesian.series.Bubble;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Bubble;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Bubble;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Bubble;
        select(index?: number): anychart.core.cartesian.series.Bubble;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Bubble;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Bubble;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Bubble;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Bubble;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Bubble;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        stroke(settings?: Object): anychart.core.cartesian.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Bubble;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Bubble;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Bubble;
        unselect(): anychart.core.cartesian.series.Bubble;
        unselect(index?: number): anychart.core.cartesian.series.Bubble;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Bubble;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Bubble;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Bubble;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Bubble;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Bubble;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Bubble;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Bubble;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Bubble;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Bubble;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Bubble;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bar extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Bar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Bar;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Bar;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Bar;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Bar;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Bar;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Bar;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Bar;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Bar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Bar;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bar;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Bar;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Bar;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Bar;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Bar;
        hover(): anychart.core.cartesian.series.Bar;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Bar;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Bar;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Bar;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Bar;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Bar;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Bar;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Bar;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Bar;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Bar;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Bar;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Bar;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Bar;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Bar;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Bar;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Bar;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Bar;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Bar;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Bar;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Bar;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Bar;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Bar;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Bar;
        select(): anychart.core.cartesian.series.Bar;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Bar;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Bar;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Bar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Bar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bar;
        stroke(settings?: Object): anychart.core.cartesian.series.Bar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Bar;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Bar;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Bar;
        unselect(): anychart.core.cartesian.series.Bar;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Bar;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Bar;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Bar;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Bar;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Bar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Bar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Bar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Bar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Bar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Area3d extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Area3d;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Area3d;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Area3d;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Area3d;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Area3d;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area3d;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Area3d;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.Area3d;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Area3d;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Area3d;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Area3d;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Area3d;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Area3d;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Area3d;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Area3d;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Area3d;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Area3d;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Area3d;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Area3d;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Area3d;
        hover(): anychart.core.cartesian.series.Area3d;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Area3d;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Area3d;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Area3d;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Area3d;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Area3d;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Area3d;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Area3d;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Area3d;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Area3d;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Area3d;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Area3d;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Area3d;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Area3d;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Area3d;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Area3d;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Area3d;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Area3d;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Area3d;
        select(): anychart.core.cartesian.series.Area3d;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Area3d;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Area3d;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Area3d;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Area3d;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area3d;
        stroke(settings?: Object): anychart.core.cartesian.series.Area3d;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Area3d;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Area3d;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Area3d;
        unselect(): anychart.core.cartesian.series.Area3d;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Area3d;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Area3d;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Area3d;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Area3d;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Area3d;
        getPixelPointWidth(): number;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Area3d;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Area3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Area3d;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Area3d;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Area3d;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OHLC extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.OHLC;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.OHLC;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.OHLC;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.OHLC;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.OHLC;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.OHLC;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.OHLC;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.OHLC;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.OHLC;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.OHLC;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.OHLC;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        fallingStroke(settings?: Object): anychart.core.cartesian.series.OHLC;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.OHLC;
        hover(): anychart.core.cartesian.series.OHLC;
        hover(index?: number): anychart.core.cartesian.series.OHLC;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.OHLC;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.OHLC;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.OHLC;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.OHLC;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.OHLC;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.OHLC;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.OHLC;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.OHLC;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.OHLC;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.OHLC;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.OHLC;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.OHLC;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.OHLC;
        meta(key?: string, value?: any): anychart.core.cartesian.series.OHLC;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.OHLC;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.OHLC;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.OHLC;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.OHLC;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.OHLC;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.OHLC;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.OHLC;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.OHLC;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.OHLC;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.OHLC;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        risingStroke(settings?: Object): anychart.core.cartesian.series.OHLC;
        select(index?: number): anychart.core.cartesian.series.OHLC;
        select(indexes?: Array<number>): anychart.core.cartesian.series.OHLC;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.OHLC;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.OHLC;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.OHLC;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.OHLC;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.OHLC;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.OHLC;
        unselect(): anychart.core.cartesian.series.OHLC;
        unselect(index?: number): anychart.core.cartesian.series.OHLC;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.OHLC;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.OHLC;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.OHLC;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.OHLC;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.OHLC;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.OHLC;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.OHLC;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.OHLC;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.OHLC;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.OHLC;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Candlestick extends anychart.core.cartesian.series.OHLC {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Candlestick;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Candlestick;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Candlestick;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Candlestick;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Candlestick;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Candlestick;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Candlestick;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Candlestick;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Candlestick;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Candlestick;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Candlestick;
        fallingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Candlestick;
        fallingFill(color: string, opacity?: number): anychart.core.cartesian.series.Candlestick;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Candlestick;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Candlestick;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Candlestick;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Candlestick;
        fallingHatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        fallingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Candlestick;
        fallingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Candlestick;
        fallingHatchFill(enabled?: boolean): anychart.core.cartesian.series.Candlestick;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Candlestick;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Candlestick;
        fallingStroke(settings?: Object): anychart.core.cartesian.series.Candlestick;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Candlestick;
        hover(): anychart.core.cartesian.series.Candlestick;
        hover(index?: number): anychart.core.cartesian.series.Candlestick;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Candlestick;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Candlestick;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Candlestick;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Candlestick;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Candlestick;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Candlestick;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Candlestick;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Candlestick;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Candlestick;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Candlestick;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Candlestick;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Candlestick;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Candlestick;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Candlestick;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Candlestick;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Candlestick;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Candlestick;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Candlestick;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Candlestick;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Candlestick;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Candlestick;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Candlestick;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Candlestick;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Candlestick;
        risingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Candlestick;
        risingFill(color: string, opacity?: number): anychart.core.cartesian.series.Candlestick;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Candlestick;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Candlestick;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Candlestick;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Candlestick;
        risingHatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        risingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Candlestick;
        risingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Candlestick;
        risingHatchFill(enabled?: boolean): anychart.core.cartesian.series.Candlestick;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Candlestick;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Candlestick;
        risingStroke(settings?: Object): anychart.core.cartesian.series.Candlestick;
        select(index?: number): anychart.core.cartesian.series.Candlestick;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Candlestick;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Candlestick;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Candlestick;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Candlestick;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Candlestick;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Candlestick;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Candlestick;
        unselect(): anychart.core.cartesian.series.Candlestick;
        unselect(index?: number): anychart.core.cartesian.series.Candlestick;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Candlestick;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Candlestick;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Candlestick;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Candlestick;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Candlestick;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Candlestick;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Candlestick;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Candlestick;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Candlestick;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Candlestick;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Column extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Column;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Column;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Column;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Column;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Column;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Column;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Column;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Column;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Column;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Column;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Column;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Column;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Column;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Column;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Column;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Column;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Column;
        hover(): anychart.core.cartesian.series.Column;
        hover(index?: number): anychart.core.cartesian.series.Column;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Column;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Column;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Column;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Column;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Column;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Column;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Column;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Column;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Column;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Column;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Column;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Column;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Column;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Column;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Column;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Column;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Column;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Column;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Column;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Column;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Column;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Column;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Column;
        select(): anychart.core.cartesian.series.Column;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Column;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Column;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Column;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Column;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Column;
        stroke(settings?: Object): anychart.core.cartesian.series.Column;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Column;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Column;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Column;
        unselect(): anychart.core.cartesian.series.Column;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Column;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Column;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Column;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Column;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Column;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Column;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Column;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Column;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface WidthBased extends anychart.core.cartesian.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.WidthBased;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.WidthBased;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.WidthBased;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.WidthBased;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.WidthBased;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.WidthBased;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.WidthBased;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.WidthBased;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.WidthBased;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.WidthBased;
        hover(): anychart.core.cartesian.series.WidthBased;
        hover(index?: number): anychart.core.cartesian.series.WidthBased;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.WidthBased;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.WidthBased;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.WidthBased;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.WidthBased;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.WidthBased;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.WidthBased;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.WidthBased;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.WidthBased;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.WidthBased;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.WidthBased;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.WidthBased;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.WidthBased;
        meta(key?: string, value?: any): anychart.core.cartesian.series.WidthBased;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.WidthBased;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.WidthBased;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.WidthBased;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.WidthBased;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.WidthBased;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.WidthBased;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.WidthBased;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.WidthBased;
        select(index?: number): anychart.core.cartesian.series.WidthBased;
        select(indexes?: Array<number>): anychart.core.cartesian.series.WidthBased;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.WidthBased;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.WidthBased;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.WidthBased;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.WidthBased;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.WidthBased;
        unselect(): anychart.core.cartesian.series.WidthBased;
        unselect(index?: number): anychart.core.cartesian.series.WidthBased;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.WidthBased;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.WidthBased;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.WidthBased;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.WidthBased;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.WidthBased;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.WidthBased;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.WidthBased;
        getStat(key: string): any;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.WidthBased;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.WidthBased;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.WidthBased;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.WidthBased;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.WidthBased;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.WidthBased;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.WidthBased;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.RangeArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.RangeArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.RangeArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.RangeArea;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.RangeArea;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.RangeArea;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.RangeArea;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.RangeArea;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.RangeArea;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.RangeArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.RangeArea;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.RangeArea;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.RangeArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        highStroke(settings?: Object): anychart.core.cartesian.series.RangeArea;
        hover(): anychart.core.cartesian.series.RangeArea;
        hover(index?: number): anychart.core.cartesian.series.RangeArea;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.RangeArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.RangeArea;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.RangeArea;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.RangeArea;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.RangeArea;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.RangeArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.RangeArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        lowStroke(settings?: Object): anychart.core.cartesian.series.RangeArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.RangeArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.RangeArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.RangeArea;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.RangeArea;
        meta(key?: string, value?: any): anychart.core.cartesian.series.RangeArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.RangeArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.RangeArea;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.RangeArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.RangeArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.RangeArea;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.RangeArea;
        select(index?: number): anychart.core.cartesian.series.RangeArea;
        select(indexes?: Array<number>): anychart.core.cartesian.series.RangeArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.RangeArea;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.RangeArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.RangeArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.RangeArea;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.RangeArea;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.RangeArea;
        unselect(): anychart.core.cartesian.series.RangeArea;
        unselect(index?: number): anychart.core.cartesian.series.RangeArea;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.RangeArea;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.RangeArea;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.RangeArea;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeArea;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.RangeArea;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.RangeArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.RangeArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.RangeArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.RangeArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaseWithMarkers extends anychart.core.cartesian.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.BaseWithMarkers;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.BaseWithMarkers;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.BaseWithMarkers;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.BaseWithMarkers;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.BaseWithMarkers;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.BaseWithMarkers;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.BaseWithMarkers;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        hover(): anychart.core.cartesian.series.BaseWithMarkers;
        hover(index?: number): anychart.core.cartesian.series.BaseWithMarkers;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.BaseWithMarkers;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.BaseWithMarkers;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.BaseWithMarkers;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.BaseWithMarkers;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.BaseWithMarkers;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.BaseWithMarkers;
        meta(key?: string, value?: any): anychart.core.cartesian.series.BaseWithMarkers;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.BaseWithMarkers;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.BaseWithMarkers;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.BaseWithMarkers;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        select(index?: number): anychart.core.cartesian.series.BaseWithMarkers;
        select(indexes?: Array<number>): anychart.core.cartesian.series.BaseWithMarkers;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.BaseWithMarkers;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.BaseWithMarkers;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.BaseWithMarkers;
        unselect(): anychart.core.cartesian.series.BaseWithMarkers;
        unselect(index?: number): anychart.core.cartesian.series.BaseWithMarkers;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.BaseWithMarkers;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.BaseWithMarkers;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.BaseWithMarkers;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.BaseWithMarkers;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.BaseWithMarkers;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.BaseWithMarkers;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.BaseWithMarkers;
        getStat(key: string): any;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.BaseWithMarkers;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.BaseWithMarkers;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.BaseWithMarkers;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.BaseWithMarkers;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.BaseWithMarkers;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.BaseWithMarkers;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.BaseWithMarkers;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface JumpLine extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.JumpLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.JumpLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.JumpLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.JumpLine;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.JumpLine;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.JumpLine;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.JumpLine;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.JumpLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.JumpLine;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.JumpLine;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.JumpLine;
        hover(): anychart.core.cartesian.series.JumpLine;
        hover(index?: number): anychart.core.cartesian.series.JumpLine;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.JumpLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.JumpLine;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.JumpLine;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.JumpLine;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.JumpLine;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.JumpLine;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.JumpLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.JumpLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.JumpLine;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.JumpLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.JumpLine;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.JumpLine;
        meta(key?: string, value?: any): anychart.core.cartesian.series.JumpLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.JumpLine;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.JumpLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.JumpLine;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.JumpLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.JumpLine;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.JumpLine;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.JumpLine;
        select(index?: number): anychart.core.cartesian.series.JumpLine;
        select(indexes?: Array<number>): anychart.core.cartesian.series.JumpLine;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.JumpLine;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.JumpLine;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.JumpLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.JumpLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.JumpLine;
        stroke(settings?: Object): anychart.core.cartesian.series.JumpLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.JumpLine;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.JumpLine;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.JumpLine;
        unselect(): anychart.core.cartesian.series.JumpLine;
        unselect(index?: number): anychart.core.cartesian.series.JumpLine;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.JumpLine;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.JumpLine;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.JumpLine;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.JumpLine;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.JumpLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.JumpLine;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.JumpLine;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.JumpLine;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.JumpLine;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.JumpLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.JumpLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.JumpLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.JumpLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StepLine extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.StepLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.StepLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.StepLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.StepLine;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.StepLine;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepLine;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.StepLine;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.StepLine;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.StepLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.StepLine;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.StepLine;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.StepLine;
        hover(): anychart.core.cartesian.series.StepLine;
        hover(index?: number): anychart.core.cartesian.series.StepLine;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.StepLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.StepLine;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.StepLine;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.StepLine;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.StepLine;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.StepLine;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.StepLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.StepLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.StepLine;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.StepLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.StepLine;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.StepLine;
        meta(key?: string, value?: any): anychart.core.cartesian.series.StepLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.StepLine;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.StepLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.StepLine;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.StepLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.StepLine;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.StepLine;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.StepLine;
        select(index?: number): anychart.core.cartesian.series.StepLine;
        select(indexes?: Array<number>): anychart.core.cartesian.series.StepLine;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.StepLine;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.StepLine;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.StepLine;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.cartesian.series.StepLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.StepLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepLine;
        stroke(settings?: Object): anychart.core.cartesian.series.StepLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.StepLine;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.StepLine;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.StepLine;
        unselect(): anychart.core.cartesian.series.StepLine;
        unselect(index?: number): anychart.core.cartesian.series.StepLine;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.StepLine;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.StepLine;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.StepLine;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.StepLine;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.StepLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.StepLine;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.StepLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.StepLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.StepLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.StepLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Line;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Line;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Line;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Line;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.Line;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Line;
        draw(): anychart.core.cartesian.series.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Line;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Line;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getIterator(): anychart.data.Iterator;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getResetIterator(): anychart.data.Iterator;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Line;
        hover(): anychart.core.cartesian.series.Line;
        hover(index?: number): anychart.core.cartesian.series.Line;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Line;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Line;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Line;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Line;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Line;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Line;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Line;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Line;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Line;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Line;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Line;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Line;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Line;
        select(index?: number): anychart.core.cartesian.series.Line;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Line;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Line;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Line;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Line;
        stroke(settings?: Object): anychart.core.cartesian.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Line;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Line;
        unselect(): anychart.core.cartesian.series.Line;
        unselect(index?: number): anychart.core.cartesian.series.Line;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Line;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Line;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Line;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Line;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColumn extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.RangeColumn;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.RangeColumn;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.RangeColumn;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.RangeColumn;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.RangeColumn;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.RangeColumn;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeColumn;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.RangeColumn;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.RangeColumn;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeColumn;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeColumn;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.RangeColumn;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.RangeColumn;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.RangeColumn;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.RangeColumn;
        hover(): anychart.core.cartesian.series.RangeColumn;
        hover(index?: number): anychart.core.cartesian.series.RangeColumn;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.RangeColumn;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.RangeColumn;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.RangeColumn;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.RangeColumn;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.RangeColumn;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.RangeColumn;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.RangeColumn;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.RangeColumn;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.RangeColumn;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeColumn;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.RangeColumn;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.RangeColumn;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.RangeColumn;
        meta(key?: string, value?: any): anychart.core.cartesian.series.RangeColumn;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.RangeColumn;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeColumn;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.RangeColumn;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.RangeColumn;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.RangeColumn;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.RangeColumn;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.RangeColumn;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.RangeColumn;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.RangeColumn;
        select(index?: number): anychart.core.cartesian.series.RangeColumn;
        select(indexes?: Array<number>): anychart.core.cartesian.series.RangeColumn;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.RangeColumn;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.RangeColumn;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.RangeColumn;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeColumn;
        stroke(settings?: Object): anychart.core.cartesian.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.cartesian.series.RangeColumn;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.RangeColumn;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.RangeColumn;
        unselect(): anychart.core.cartesian.series.RangeColumn;
        unselect(index?: number): anychart.core.cartesian.series.RangeColumn;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.RangeColumn;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.RangeColumn;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.RangeColumn;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.RangeColumn;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeColumn;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeColumn;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.RangeColumn;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.RangeColumn;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.RangeColumn;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.RangeColumn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeSplineArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.RangeSplineArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.RangeSplineArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.RangeSplineArea;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.RangeSplineArea;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.RangeSplineArea;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.RangeSplineArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.RangeSplineArea;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.RangeSplineArea;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeSplineArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeSplineArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.RangeSplineArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.RangeSplineArea;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.RangeSplineArea;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        highFill(): anychart.graphics.vector.Fill;
        highFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeSplineArea;
        highFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeSplineArea;
        highFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        highFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        highFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        highFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeSplineArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        highStroke(settings?: Object): anychart.core.cartesian.series.RangeSplineArea;
        hover(): anychart.core.cartesian.series.RangeSplineArea;
        hover(index?: number): anychart.core.cartesian.series.RangeSplineArea;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.RangeSplineArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.RangeSplineArea;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.RangeSplineArea;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.RangeSplineArea;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.RangeSplineArea;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.RangeSplineArea;
        lowFill(): anychart.graphics.vector.Fill;
        lowFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.RangeSplineArea;
        lowFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.RangeSplineArea;
        lowFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        lowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        lowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        lowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.RangeSplineArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        lowStroke(settings?: Object): anychart.core.cartesian.series.RangeSplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.RangeSplineArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeSplineArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.RangeSplineArea;
        meta(key?: string, value?: any): anychart.core.cartesian.series.RangeSplineArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.RangeSplineArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.RangeSplineArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.RangeSplineArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        select(index?: number): anychart.core.cartesian.series.RangeSplineArea;
        select(indexes?: Array<number>): anychart.core.cartesian.series.RangeSplineArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.RangeSplineArea;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.RangeSplineArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.RangeSplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.RangeSplineArea;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.RangeSplineArea;
        unselect(): anychart.core.cartesian.series.RangeSplineArea;
        unselect(index?: number): anychart.core.cartesian.series.RangeSplineArea;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.RangeSplineArea;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.RangeSplineArea;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.RangeSplineArea;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeSplineArea;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.RangeSplineArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.RangeSplineArea;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.RangeSplineArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.RangeSplineArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.RangeSplineArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.RangeSplineArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Hilo extends anychart.core.cartesian.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Hilo;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Hilo;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Hilo;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Hilo;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Hilo;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Hilo;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Hilo;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Hilo;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Hilo;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Hilo;
        hover(): anychart.core.cartesian.series.Hilo;
        hover(index?: number): anychart.core.cartesian.series.Hilo;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Hilo;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Hilo;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Hilo;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Hilo;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Hilo;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Hilo;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Hilo;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Hilo;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Hilo;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Hilo;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Hilo;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Hilo;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Hilo;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Hilo;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Hilo;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Hilo;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Hilo;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Hilo;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Hilo;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Hilo;
        select(index?: number): anychart.core.cartesian.series.Hilo;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Hilo;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Hilo;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Hilo;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Hilo;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Hilo;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Hilo;
        stroke(settings?: Object): anychart.core.cartesian.series.Hilo;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Hilo;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Hilo;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Hilo;
        unselect(): anychart.core.cartesian.series.Hilo;
        unselect(index?: number): anychart.core.cartesian.series.Hilo;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Hilo;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Hilo;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Hilo;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Hilo;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Hilo;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Hilo;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.cartesian.series.Hilo;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Hilo;
        getPixelPointWidth(): number;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Hilo;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Hilo;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Hilo;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Hilo;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.cartesian.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Marker;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Marker;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Marker;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Marker;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Marker;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.cartesian.series.Marker;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Marker;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Marker;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Marker;
        hover(): anychart.core.cartesian.series.Marker;
        hover(index?: number): anychart.core.cartesian.series.Marker;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Marker;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Marker;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Marker;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Marker;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Marker;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Marker;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Marker;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Marker;
        name(): string;
        name(value?: string): anychart.core.cartesian.series.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Marker;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Marker;
        select(index?: number): anychart.core.cartesian.series.Marker;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Marker;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Marker;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Marker;
        size(): number;
        size(size?: number): anychart.core.cartesian.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Marker;
        stroke(settings?: Object): anychart.core.cartesian.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Marker;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        type(): string | (() => void);
        type(type?: string | ((path:anychart.graphics.vector.Path,x:number,y:number,size:number)=>anychart.graphics.vector.Path)): anychart.core.cartesian.series.Marker;
        unhover(): anychart.core.cartesian.series.Marker;
        unselect(): anychart.core.cartesian.series.Marker;
        unselect(index?: number): anychart.core.cartesian.series.Marker;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Marker;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Marker;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Marker;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Marker;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bar3d extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.cartesian.series.Bar3d;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.cartesian.series.Bar3d;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.cartesian.series.Bar3d;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.cartesian.series.Bar3d;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Bar3d;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar3d;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.cartesian.series.Bar3d;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.cartesian.series.Bar3d;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.cartesian.series.Bar3d;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.cartesian.series.Bar3d;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.cartesian.series.Bar3d;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.cartesian.series.Bar3d;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bar3d;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bar3d;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.cartesian.series.Bar3d;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.cartesian.series.Bar3d;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.cartesian.series.Bar3d;
        hatchFill(enabled?: boolean): anychart.core.cartesian.series.Bar3d;
        height(): number | string;
        height(height?: number | string): anychart.core.cartesian.series.Bar3d;
        hover(): anychart.core.cartesian.series.Bar3d;
        hover(index?: number): anychart.core.cartesian.series.Bar3d;
        hover(indexes?: Array<number>): anychart.core.cartesian.series.Bar3d;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.cartesian.series.Bar3d;
        id(): string | number;
        id(id?: string | number): anychart.core.cartesian.series.Bar3d;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.cartesian.series.Bar3d;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.cartesian.series.Bar3d;
        left(): number | string;
        left(left?: number | string): anychart.core.cartesian.series.Bar3d;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.cartesian.series.Bar3d;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.cartesian.series.Bar3d;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.cartesian.series.Bar3d;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.cartesian.series.Bar3d;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.cartesian.series.Bar3d;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.cartesian.series.Bar3d;
        meta(key?: any): any;
        meta(object?: any): anychart.core.cartesian.series.Bar3d;
        meta(key?: string, value?: any): anychart.core.cartesian.series.Bar3d;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.cartesian.series.Bar3d;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.cartesian.series.Bar3d;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.cartesian.series.Bar3d;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.cartesian.series.Bar3d;
        name(): string;
        name(name?: string): anychart.core.cartesian.series.Bar3d;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.cartesian.series.Bar3d;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.cartesian.series.Bar3d;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.cartesian.series.Bar3d;
        right(): number | string;
        right(right?: number | string): anychart.core.cartesian.series.Bar3d;
        select(index?: number): anychart.core.cartesian.series.Bar3d;
        select(indexes?: Array<number>): anychart.core.cartesian.series.Bar3d;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.cartesian.series.Bar3d;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.cartesian.series.Bar3d;
        seriesType(): string;
        seriesType(type?: string): anychart.core.cartesian.series.Bar3d;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.cartesian.series.Bar3d;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bar3d;
        stroke(settings?: Object): anychart.core.cartesian.series.Bar3d;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.cartesian.series.Bar3d;
        top(): number | string;
        top(top?: number | string): anychart.core.cartesian.series.Bar3d;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.cartesian.series.Bar3d;
        unselect(): anychart.core.cartesian.series.Bar3d;
        unselect(index?: number): anychart.core.cartesian.series.Bar3d;
        unselect(indexes?: Array<number>): anychart.core.cartesian.series.Bar3d;
        width(): number | string;
        width(width?: number | string): anychart.core.cartesian.series.Bar3d;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Bar3d;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Bar3d;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.cartesian.series.Bar3d;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.cartesian.series.Bar3d;
        xMode(): string;
        xMode(xMode?: string): anychart.core.cartesian.series.Bar3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.cartesian.series.Bar3d;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.cartesian.series.Bar3d;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.cartesian.series.Bar3d;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.gantt {
    interface Calendar extends anychart.core.Base {
        getWorkingSchedule(): Array<anychart.core.gantt.Calendar.DailyScheduleData>;
        holidays(): Array<anychart.core.gantt.Calendar.Holiday>;
        holidays(holidays: Array<anychart.core.gantt.Calendar.Holiday>): anychart.core.gantt.Calendar;
        schedule(): Array<anychart.core.gantt.Calendar.DailyWorkingSchedule>;
        schedule(schedule: Array<anychart.core.gantt.Calendar.DailyWorkingSchedule>): anychart.core.gantt.Calendar;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Calendar {
    type DailyWorkingSchedule = {
        from: number;
        to: number;
    }
    type Holiday = {
        day: number;
        label: string;
        month: number;
        year: number;
    }
    type DailyScheduleData = {
        end: number;
        isHoliday: boolean;
        isWeekend: boolean;
        notWorkingIntervals: Array<anychart.core.gantt.Calendar.DailyWorkingSchedule>;
        start: number;
        workingIntervals: Array<anychart.core.gantt.Calendar.DailyWorkingSchedule>;
    }
    }
    interface TimeLineHeader extends anychart.core.VisualBaseWithBounds {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.gantt.TimeLineHeader;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.gantt.TimeLineHeader;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.gantt.TimeLineHeader;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.gantt.TimeLineHeader;
        drawBottomLine(): boolean;
        drawBottomLine(enabled?: boolean): anychart.core.resource.Grid;
        drawLeftLine(): boolean;
        drawLeftLine(enabled?: boolean): anychart.core.resource.Grid;
        drawRightLine(): boolean;
        drawRightLine(enabled?: boolean): anychart.core.resource.Grid;
        drawTopLine(): boolean;
        drawTopLine(enabled?: boolean): anychart.core.resource.Grid;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.TimeLineHeader;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.TimeLineHeader;
        fill(color: string, opacity?: number): anychart.core.gantt.TimeLineHeader;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.TimeLineHeader;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.TimeLineHeader;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.TimeLineHeader;
        fontColor(): string;
        fontColor(color?: string): anychart.core.gantt.TimeLineHeader;
        fontDecoration(): anychart.graphics.vector.Text.Decoration;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.gantt.TimeLineHeader;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.core.gantt.TimeLineHeader;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.gantt.TimeLineHeader;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.gantt.TimeLineHeader;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(style?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.gantt.TimeLineHeader;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(type?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.gantt.TimeLineHeader;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.gantt.TimeLineHeader;
        format(): (() => void) | string;
        format(format?: (() => void) | string): anychart.core.gantt.TimeLineHeader;
        getPixelBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(align?: string | anychart.graphics.vector.Text.HAlign): anychart.core.gantt.TimeLineHeader;
        height(): number | string;
        height(height?: number | string): anychart.core.gantt.TimeLineHeader;
        holidays(): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        holidays(settings?: Object): anychart.core.gantt.TimeLineHeader;
        left(): number | string;
        left(left?: number | string): anychart.core.gantt.TimeLineHeader;
        letterSpacing(): number;
        letterSpacing(spacing?: number | string): anychart.core.gantt.TimeLineHeader;
        level(index?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        level(settings?: Object | boolean): anychart.core.gantt.TimeLineHeader;
        level(index?: number, settings?: Object | boolean): anychart.core.gantt.TimeLineHeader;
        levelHeight(): number;
        levelHeight(height: number): anychart.core.gantt.TimeLineHeader;
        lineHeight(): number | string;
        lineHeight(height?: number | string): anychart.core.gantt.TimeLineHeader;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.gantt.TimeLineHeader;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.gantt.TimeLineHeader;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.gantt.TimeLineHeader;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.gantt.TimeLineHeader;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.gantt.TimeLineHeader;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.gantt.TimeLineHeader;
        overlay(): anychart.core.gantt.Overlay;
        overlay(settings?: Object | boolean): anychart.core.gantt.TimeLineHeader;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.gantt.TimeLineHeader;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.gantt.TimeLineHeader;
        right(): number | string;
        right(right?: number | string): anychart.core.gantt.TimeLineHeader;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.gantt.TimeLineHeader;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.TimeLineHeader;
        stroke(settings?: Object): anychart.core.gantt.TimeLineHeader;
        textDirection(): anychart.graphics.vector.Text.Direction;
        textDirection(type?: string | anychart.graphics.vector.Text.Direction): anychart.core.gantt.TimeLineHeader;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.gantt.TimeLineHeader;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.gantt.TimeLineHeader;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.gantt.TimeLineHeader;
        top(): number | string;
        top(top?: number | string): anychart.core.gantt.TimeLineHeader;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.gantt.TimeLineHeader;
        vAlign(): anychart.graphics.vector.Text.VAlign;
        vAlign(align?: string | anychart.graphics.vector.Text.VAlign): anychart.core.gantt.TimeLineHeader;
        width(): number | string;
        width(width?: number | string): anychart.core.gantt.TimeLineHeader;
        wordBreak(): string;
        wordBreak(type?: string): anychart.core.gantt.TimeLineHeader;
        wordWrap(): string;
        wordWrap(type?: string): anychart.core.gantt.TimeLineHeader;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gantt.TimeLineHeader;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.gantt.TimeLineHeader;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.gantt.TimeLineHeader;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gantt.TimeLineHeader;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gantt.TimeLineHeader;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gantt.TimeLineHeader;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace TimeLineHeader {
    type Level = {
        adjustFontSize: boolean | Array<boolean> | Object;
        count: number;
        disablePointerEvents: boolean;
        fill: anychart.graphics.vector.Fill;
        fontColor: string;
        fontDecoration: string;
        fontFamily: string;
        fontOpacity: number;
        fontSize: number;
        fontStyle: string;
        fontVariant: string;
        fontWeight: string | number;
        format: (() => void);
        formats: string | Array<string>;
        hAlign: string;
        height: number | string;
        holiday: {fill:anychart.graphics.vector.Fill,padding:Object|Array<number>|number|string,minFontSize:number,maxFontSize:number,adjustFontSize:boolean|Array<boolean>|{width:boolean,height:boolean},fontSize:number,fontFamily:string,fontColor:string,fontOpacity:number,fontDecoration:string,fontStyle:string|string,fontVariant:string|string,fontWeight:string|number,letterSpacing:number|string,textDirection:string,lineHeight:number|string,textIndent:number,vAlign:string|string,hAlign:string|string,wordWrap:string,wordBreak:string,textOverflow:anychart.graphics.vector.Text.TextOverflow|string,selectable:boolean,disablePointerEvents:boolean,useHtml:boolean,format:Function};
        letterSpacing: number | string;
        lineHeight: number | string;
        maxFontSize: number;
        minFontSize: number;
        padding: Object | Array<any> | number | string;
        selectable: boolean;
        textDirection: string;
        textIndent: number;
        textOverflow: anychart.graphics.vector.Text.TextOverflow | string;
        unit: string;
        useHtml: boolean;
        vAlign: string;
        wordBreak: string;
        wordWrap: string;
    }
    }
    module TimeLineHeader {
    interface LevelWrapper extends anychart.core.Base {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        enabled(): boolean;
        enabled(state?: boolean): anychart.core.ui.LabelsFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fill(color: string, opacity?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontColor(): string;
        fontColor(color?: string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(value?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        format(): (() => void) | string;
        format(value?: (() => void) | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(value?: string | anychart.graphics.vector.Text.HAlign): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        height(): number | string;
        height(height?: number | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        letterSpacing(): number;
        letterSpacing(value?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        minFontSize(): number;
        minFontSize(minFontSize?: number | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        stroke(settings?: Object): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        textIndent(): number;
        textIndent(value?: number): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        wordBreak(): string;
        wordBreak(value?: string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        wordWrap(): string;
        wordWrap(value?: string): anychart.core.gantt.TimeLineHeader.LevelWrapper;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    }
    interface Overlay extends anychart.core.Base {
        className(): string;
        className(name?: string): anychart.core.gantt.Overlay;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.Overlay;
        getElement(): Element;
        id(): string;
        id(id?: string): anychart.core.gantt.Overlay;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TimeLineHeaderLevelHolidaysSettings extends anychart.core.VisualBaseWithBounds {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fill(color: string, opacity?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontColor(): string;
        fontColor(color?: string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(type?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(type?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        format(): (() => void) | string;
        format(format?: (() => void) | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(type?: string | anychart.graphics.vector.Text.HAlign): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        letterSpacing(): number | string;
        letterSpacing(spacing?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(type?: anychart.graphics.vector.Text.VAlign | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        wordBreak(): string;
        wordBreak(type?: string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        wordWrap(): string;
        wordWrap(type?: string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        left(): number | string;
        left(left?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        right(): number | string;
        right(right?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        top(): number | string;
        top(top?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        width(): number | string;
        width(width?: number | string): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gantt.TimeLineHeaderLevelHolidaysSettings;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DataGridButton extends anychart.core.VisualBase {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.gantt.DataGridButton;
        content(): string | number;
        content(content?: string | number): anychart.core.gantt.DataGridButton;
        content(func?: ((path:anychart.graphics.vector.Path)=>void)): anychart.core.gantt.DataGridButton;
        cursor(): string;
        cursor(cursorType?: string): anychart.core.gantt.DataGridButton;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.gantt.DataGridButton;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.DataGridButton;
        fontColor(): string;
        fontColor(color?: string): anychart.core.gantt.DataGridButton;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(fontDecoration?: anychart.graphics.vector.Text.Decoration | string): anychart.core.gantt.DataGridButton;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.core.gantt.DataGridButton;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.gantt.DataGridButton;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.gantt.DataGridButton;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.gantt.DataGridButton;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.gantt.DataGridButton;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.gantt.DataGridButton;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.gantt.DataGridButton;
        height(): number | string;
        height(height?: number | string): anychart.core.gantt.DataGridButton;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.gantt.DataGridButton;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.gantt.DataGridButton;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.gantt.DataGridButton;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.DataGridButton;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.gantt.DataGridButton;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.gantt.DataGridButton;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.gantt.DataGridButton;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.DataGridButton;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.gantt.DataGridButton;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.gantt.DataGridButton;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.gantt.DataGridButton;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.gantt.DataGridButton;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.gantt.DataGridButton;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.gantt.DataGridButton;
        width(): number | string;
        width(width?: number | string): anychart.core.gantt.DataGridButton;
        wordBreak(): string;
        wordBreak(type?: string): anychart.core.gantt.DataGridButton;
        wordWrap(): string;
        wordWrap(type?: string): anychart.core.gantt.DataGridButton;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gantt.DataGridButton;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gantt.DataGridButton;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gantt.DataGridButton;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gantt.DataGridButton;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.gantt.edit {
    interface Thumb extends anychart.core.Base {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.edit.Thumb;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.edit.Thumb;
        fill(color: string, opacity?: number): anychart.core.gantt.edit.Thumb;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.edit.Thumb;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.edit.Thumb;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.edit.Thumb;
        horizontalOffset(): number;
        horizontalOffset(offset?: number): anychart.core.gantt.edit.Thumb;
        size(): number;
        size(size?: number): anychart.core.gantt.edit.Thumb;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.edit.Thumb;
        stroke(settings?: Object): anychart.core.gantt.edit.Thumb;
        type(): string;
        type(type?: string): anychart.core.gantt.edit.Thumb;
        verticalOffset(): number;
        verticalOffset(offset?: number): anychart.core.gantt.edit.Thumb;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ElementEdit extends anychart.core.Base {
        connectorThumbs(): anychart.core.gantt.edit.Thumb;
        connectorThumbs(settings?: Object): anychart.core.gantt.edit.ElementEdit;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.edit.ElementEdit;
        end(): anychart.core.gantt.edit.SideControl;
        end(settings?: Object): anychart.core.gantt.edit.ElementEdit;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.edit.ElementEdit;
        fill(color: string, opacity?: number): anychart.core.gantt.edit.ElementEdit;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.edit.ElementEdit;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.edit.ElementEdit;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.edit.ElementEdit;
        start(): anychart.core.gantt.edit.SideControl;
        start(settings?: Object): anychart.core.gantt.edit.ElementEdit;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.edit.ElementEdit;
        stroke(settings?: Object): anychart.core.gantt.edit.ElementEdit;
        thumbs(): anychart.core.gantt.edit.Thumb;
        thumbs(settings?: Object): anychart.core.gantt.edit.ElementEdit;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StructureEdit extends anychart.core.Base {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gantt.edit.StructureEdit;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.edit.StructureEdit;
        fill(color: string, opacity?: number): anychart.core.gantt.edit.StructureEdit;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.edit.StructureEdit;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.edit.StructureEdit;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.edit.StructureEdit;
        placementStroke(): anychart.graphics.vector.Stroke;
        placementStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.edit.StructureEdit;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.edit.StructureEdit;
        stroke(settings?: Object): anychart.core.gantt.edit.StructureEdit;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SideControl extends anychart.core.Base {
        connectorThumb(): anychart.core.gantt.edit.Thumb;
        connectorThumb(settings?: Object): anychart.core.gantt.edit.SideControl;
        thumb(): anychart.core.gantt.edit.Thumb;
        thumb(settings?: Object): anychart.core.gantt.edit.SideControl;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.gantt.elements {
    interface GroupingTasksElement extends anychart.core.gantt.elements.TimelineElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.GroupingTasksElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.GroupingTasksElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.GroupingTasksElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.GroupingTasksElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.GroupingTasksElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.GroupingTasksElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.GroupingTasksElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.GroupingTasksElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.GroupingTasksElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.GroupingTasksElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.GroupingTasksElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.GroupingTasksElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.GroupingTasksElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.GroupingTasksElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.GroupingTasksElement;
        progress(): anychart.core.gantt.elements.ProgressElement;
        progress(settings?: Object): anychart.core.gantt.elements.GroupingTasksElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.GroupingTasksElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.GroupingTasksElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.GroupingTasksElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.GroupingTasksElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.GroupingTasksElement;
        stroke(settings?: Object): anychart.core.gantt.elements.GroupingTasksElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.GroupingTasksElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ConnectorElement extends anychart.core.Base {
        fill(): anychart.graphics.vector.Fill | string;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.ui.Timeline;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.ConnectorElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.ConnectorElement;
        previewStroke(): anychart.graphics.vector.Stroke | string;
        previewStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.ConnectorElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.ConnectorElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.ConnectorElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.ConnectorElement;
        stroke(settings?: Object): anychart.core.gantt.elements.ConnectorElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaselineMilestonesElement extends anychart.core.gantt.elements.TimelineElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.BaselineMilestonesElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.BaselineMilestonesElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.BaselineMilestonesElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.BaselineMilestonesElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.BaselineMilestonesElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.BaselineMilestonesElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.BaselineMilestonesElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.BaselineMilestonesElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.BaselineMilestonesElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesElement;
        markerType(): string;
        markerType(markerType: string): anychart.core.gantt.elements.BaselineMilestonesElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesElement;
        preview(): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        preview(settings: Object): anychart.core.gantt.elements.BaselineMilestonesElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.BaselineMilestonesElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.BaselineMilestonesElement;
        stroke(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.BaselineMilestonesElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.BaselineMilestonesElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface PeriodsElement extends anychart.core.gantt.elements.TimelineElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.PeriodsElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.PeriodsElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.PeriodsElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.PeriodsElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.PeriodsElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.PeriodsElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.PeriodsElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.PeriodsElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.PeriodsElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.PeriodsElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.PeriodsElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.PeriodsElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.PeriodsElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.PeriodsElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.PeriodsElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.PeriodsElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.PeriodsElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.PeriodsElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.PeriodsElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.PeriodsElement;
        stroke(settings?: Object): anychart.core.gantt.elements.PeriodsElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.PeriodsElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MilestonesPreviewElement extends anychart.core.gantt.elements.MilestonesElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.MilestonesPreviewElement;
        depth(): number;
        depth(value: number): anychart.core.gantt.elements.MilestonesPreviewElement;
        drawOnCollapsedOnly(): boolean;
        drawOnCollapsedOnly(value: boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.MilestonesPreviewElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.MilestonesPreviewElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.MilestonesPreviewElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.MilestonesPreviewElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.MilestonesPreviewElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.MilestonesPreviewElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.MilestonesPreviewElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        markerType(): string;
        markerType(markerType: string): anychart.core.gantt.elements.MilestonesPreviewElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.MilestonesPreviewElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.MilestonesPreviewElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.MilestonesPreviewElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.MilestonesPreviewElement;
        stroke(settings?: Object): anychart.core.gantt.elements.MilestonesPreviewElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.MilestonesPreviewElement;
        preview(): anychart.core.gantt.elements.MilestonesPreviewElement;
        preview(settings: Object): anychart.core.gantt.elements.MilestonesPreviewElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.MilestonesPreviewElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.MilestonesPreviewElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.MilestonesPreviewElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ProgressElement extends anychart.core.gantt.elements.TimelineElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.ProgressElement;
        drawOverEnd(): boolean;
        drawOverEnd(value: boolean): anychart.core.gantt.elements.ProgressElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.ProgressElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.ProgressElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.ProgressElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.ProgressElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.ProgressElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.ProgressElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.ProgressElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.ProgressElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.ProgressElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.ProgressElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.ProgressElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.ProgressElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.ProgressElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.ProgressElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.ProgressElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.ProgressElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.ProgressElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.ProgressElement;
        stroke(settings?: Object): anychart.core.gantt.elements.ProgressElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.ProgressElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaselineProgressElement extends anychart.core.gantt.elements.ProgressElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.BaselineProgressElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.BaselineProgressElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.BaselineProgressElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.BaselineProgressElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.BaselineProgressElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.BaselineProgressElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.BaselineProgressElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.BaselineProgressElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.BaselineProgressElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.BaselineProgressElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.BaselineProgressElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.BaselineProgressElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.BaselineProgressElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.BaselineProgressElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.BaselineProgressElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.BaselineProgressElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.BaselineProgressElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.BaselineProgressElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.BaselineProgressElement;
        stroke(settings?: Object): anychart.core.gantt.elements.BaselineProgressElement;
        drawOverEnd(): boolean;
        drawOverEnd(value: boolean): anychart.core.gantt.elements.BaselineProgressElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.BaselineProgressElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaselinesElement extends anychart.core.gantt.elements.TimelineElement {
        above(): boolean;
        above(enabled?: boolean): anychart.core.gantt.elements.BaselinesElement;
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.BaselinesElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.BaselinesElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.BaselinesElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.BaselinesElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.BaselinesElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.BaselinesElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.BaselinesElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.BaselinesElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.BaselinesElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.BaselinesElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.BaselinesElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.BaselinesElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.BaselinesElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.BaselinesElement;
        progress(): anychart.core.gantt.elements.BaselineProgressElement;
        progress(settings?: Object): anychart.core.gantt.elements.BaselinesElement;
        removeAllListeners(type?: string): number;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.BaselinesElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.BaselinesElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.BaselinesElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.BaselinesElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.BaselinesElement;
        stroke(settings?: Object): anychart.core.gantt.elements.BaselinesElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.BaselinesElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.BaselinesElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TimelineElement extends anychart.core.Base {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.TimelineElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.TimelineElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.TimelineElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.TimelineElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.TimelineElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.TimelineElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.TimelineElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.TimelineElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.TimelineElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.TimelineElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.TimelineElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.TimelineElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.TimelineElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.TimelineElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.TimelineElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.TimelineElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.TimelineElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.TimelineElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.TimelineElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.TimelineElement;
        stroke(settings?: Object): anychart.core.gantt.elements.TimelineElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.TimelineElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MilestonesElement extends anychart.core.gantt.elements.TimelineElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.MilestonesElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.MilestonesElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.MilestonesElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.MilestonesElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.MilestonesElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.MilestonesElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.MilestonesElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.MilestonesElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.MilestonesElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.MilestonesElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.MilestonesElement;
        markerType(): string;
        markerType(markerType: string): anychart.core.gantt.elements.MilestonesElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.MilestonesElement;
        preview(): anychart.core.gantt.elements.MilestonesPreviewElement;
        preview(settings: Object): anychart.core.gantt.elements.MilestonesElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.MilestonesElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.MilestonesElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.MilestonesElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.MilestonesElement;
        stroke(settings?: Object): anychart.core.gantt.elements.MilestonesElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.MilestonesElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.MilestonesElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.MilestonesElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.MilestonesElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.MilestonesElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TasksElement extends anychart.core.gantt.elements.TimelineElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.TasksElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.TasksElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.TasksElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.TasksElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.TasksElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.TasksElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.TasksElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.TasksElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.TasksElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.TasksElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.TasksElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.TasksElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.TasksElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.TasksElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.TasksElement;
        progress(): anychart.core.gantt.elements.ProgressElement;
        progress(settings?: Object): anychart.core.gantt.elements.TasksElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.TasksElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.TasksElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.TasksElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.TasksElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.TasksElement;
        stroke(settings?: Object): anychart.core.gantt.elements.TasksElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.TasksElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaselineMilestonesPreviewElement extends anychart.core.gantt.elements.BaselineMilestonesElement {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        depth(): number;
        depth(value: number): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        drawOnCollapsedOnly(): boolean;
        drawOnCollapsedOnly(value: boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        edit(): anychart.core.gantt.edit.ElementEdit;
        edit(settings?: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        enabled(): boolean;
        enabled(settings?: boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        fill(color: string, opacity?: number): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        height(): string | number;
        height(height?: string | number): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        markerType(): string;
        markerType(markerType: string): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        rendering(): anychart.core.gantt.rendering.Settings;
        rendering(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        stroke(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        preview(): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        preview(settings: Object): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        endMarker(): anychart.core.gantt.elements.Marker;
        endMarker(config: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        position(): string;
        position(position?: string): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        startMarker(): anychart.core.gantt.elements.Marker;
        startMarker(config: Object | boolean): anychart.core.gantt.elements.BaselineMilestonesPreviewElement;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.Base {
        anchor(): string;
        anchor(anchor?: string): anychart.core.gantt.elements.Marker;
        fill(): anychart.graphics.vector.Fill;
        fill(fill: anychart.graphics.vector.Fill): anychart.core.gantt.elements.Marker;
        offsetX(): number | string;
        offsetX(offset: number): anychart.core.gantt.elements.Marker;
        offsetY(): number;
        offsetY(offset: number): anychart.core.gantt.elements.Marker;
        rotation(): number;
        rotation(angle: number): anychart.core.gantt.elements.Marker;
        size(): number;
        size(size: number): anychart.core.gantt.elements.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(stroke: anychart.graphics.vector.Stroke): anychart.core.gantt.elements.Marker;
        type(): string;
        type(type: string): anychart.core.gantt.elements.Marker;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.gantt.rendering {
    interface Settings extends anychart.core.Base {
        drawer(): (() => void);
        drawer(drawerFunction: (() => void)): anychart.core.gantt.rendering.Settings;
        shapes(): Array<anychart.core.gantt.rendering.Settings.ShapeConfig>;
        shapes(config?: Array<anychart.core.gantt.rendering.Settings.ShapeConfig>): anychart.core.gantt.rendering.Settings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Settings {
    type ShapeConfig = {
        disablePointerEvents?: boolean;
        name?: string;
        shapeType?: string;
        zIndex?: number;
    }
    }
}

declare namespace anychart.core.gauge {
    interface Cap extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gauge.Cap;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gauge.Cap;
        fill(color: string, opacity?: number): anychart.core.gauge.Cap;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.Cap;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.Cap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.Cap;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.gauge.Cap;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.gauge.Cap;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.gauge.Cap;
        hatchFill(enabled?: boolean): anychart.core.gauge.Cap;
        radius(): string;
        radius(radius?: number | string): anychart.core.gauge.Cap;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.Cap;
        stroke(settings?: Object): anychart.core.gauge.Cap;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gauge.Cap;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gauge.Cap;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gauge.Cap;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gauge.Cap;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.gauge.pointers {
    interface Needle extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Needle;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.gauge.pointers.Needle;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Needle;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gauge.pointers.Needle;
        endRadius(): string;
        endRadius(radius?: number | string): anychart.core.gauge.pointers.Needle;
        endWidth(): string;
        endWidth(width?: number | string): anychart.core.gauge.pointers.Needle;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gauge.pointers.Needle;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Needle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Needle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Needle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Needle;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Needle;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.gauge.pointers.Needle;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.gauge.pointers.Needle;
        hatchFill(enabled?: boolean): anychart.core.gauge.pointers.Needle;
        id(): anychart.core.gauge.pointers.Needle;
        id(id?: string | number): anychart.core.gauge.pointers.Needle;
        middleRadius(): string;
        middleRadius(radius?: number | string): anychart.core.gauge.pointers.Needle;
        middleWidth(): string;
        middleWidth(width?: number | string): anychart.core.gauge.pointers.Needle;
        startRadius(): string;
        startRadius(radius?: number | string): anychart.core.gauge.pointers.Needle;
        startWidth(): string;
        startWidth(width?: number | string): anychart.core.gauge.pointers.Needle;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gauge.pointers.Needle;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Needle;
        stroke(settings?: Object): anychart.core.gauge.pointers.Needle;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gauge.pointers.Needle;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gauge.pointers.Needle;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gauge.pointers.Needle;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gauge.pointers.Needle;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.VisualBase {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gauge.pointers.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.gauge.pointers.Base;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.gauge.pointers.Base;
        hatchFill(enabled?: boolean): anychart.core.gauge.pointers.Base;
        id(): anychart.core.gauge.pointers.Base;
        id(id?: string | number): anychart.core.gauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        stroke(settings?: Object): anychart.core.gauge.pointers.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gauge.pointers.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gauge.pointers.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gauge.pointers.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gauge.pointers.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bar extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Bar;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.gauge.pointers.Bar;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Bar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gauge.pointers.Bar;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gauge.pointers.Bar;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Bar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Bar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Bar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Bar;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Bar;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.gauge.pointers.Bar;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.gauge.pointers.Bar;
        hatchFill(enabled?: boolean): anychart.core.gauge.pointers.Bar;
        id(): anychart.core.gauge.pointers.Bar;
        id(id?: string | number): anychart.core.gauge.pointers.Bar;
        position(): string;
        position(position?: string): anychart.core.gauge.pointers.Bar;
        radius(): string;
        radius(radius?: number | string): anychart.core.gauge.pointers.Bar;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gauge.pointers.Bar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Bar;
        stroke(settings?: Object): anychart.core.gauge.pointers.Bar;
        width(): string;
        width(width?: number | string): anychart.core.gauge.pointers.Bar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gauge.pointers.Bar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gauge.pointers.Bar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gauge.pointers.Bar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gauge.pointers.Bar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Knob extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Knob;
        bottomRadius(): string;
        bottomRadius(radius?: number | string): anychart.core.gauge.pointers.Knob;
        bottomRatio(): number;
        bottomRatio(ratio?: number): anychart.core.gauge.pointers.Knob;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.gauge.pointers.Knob;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Knob;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gauge.pointers.Knob;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gauge.pointers.Knob;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Knob;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Knob;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Knob;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Knob;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Knob;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.gauge.pointers.Knob;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.gauge.pointers.Knob;
        hatchFill(enabled?: boolean): anychart.core.gauge.pointers.Knob;
        id(): anychart.core.gauge.pointers.Knob;
        id(id?: string | number): anychart.core.gauge.pointers.Knob;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gauge.pointers.Knob;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Knob;
        stroke(settings?: Object): anychart.core.gauge.pointers.Knob;
        topRadius(): string;
        topRadius(radius?: number | string): anychart.core.gauge.pointers.Knob;
        topRatio(): number;
        topRatio(ratio?: number): anychart.core.gauge.pointers.Knob;
        verticesCount(): number;
        verticesCount(count?: number): anychart.core.gauge.pointers.Knob;
        verticesCurvature(): number;
        verticesCurvature(curvature?: number): anychart.core.gauge.pointers.Knob;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gauge.pointers.Knob;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gauge.pointers.Knob;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gauge.pointers.Knob;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gauge.pointers.Knob;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Marker;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.gauge.pointers.Marker;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.gauge.pointers.Marker;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.gauge.pointers.Marker;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Marker;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.gauge.pointers.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.gauge.pointers.Marker;
        hatchFill(enabled?: boolean): anychart.core.gauge.pointers.Marker;
        id(): anychart.core.gauge.pointers.Marker;
        id(id?: string | number): anychart.core.gauge.pointers.Marker;
        position(): string;
        position(position?: string): anychart.core.gauge.pointers.Marker;
        radius(): string;
        radius(radius?: number | string): anychart.core.gauge.pointers.Marker;
        size(): string;
        size(size?: number | string): anychart.core.gauge.pointers.Marker;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.gauge.pointers.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Marker;
        stroke(settings?: Object): anychart.core.gauge.pointers.Marker;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.gauge.pointers.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.gauge.pointers.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.gauge.pointers.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.gauge.pointers.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.gauge.pointers.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.graph {
}

declare namespace anychart.core.graph.elements {
    interface Layout extends anychart.core.Base {
        iterationCount(): number;
        iterationCount(value: number): anychart.core.graph.elements.Layout;
        type(): string;
        type(value: string): anychart.core.graph.elements.Layout;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Interactivity {
        edges(): boolean;
        edges(value: boolean): anychart.core.graph.elements.Interactivity;
        enabled(): boolean;
        enabled(value: boolean): anychart.core.graph.elements.Interactivity;
        hoverGap(): number;
        hoverGap(value: number): anychart.core.graph.elements.Interactivity;
        magnetize(): boolean;
        magnetize(value: boolean): anychart.core.graph.elements.Interactivity;
        nodes(): boolean;
        nodes(value: boolean): anychart.core.graph.elements.Interactivity;
        scrollOnMouseWheel(): boolean;
        scrollOnMouseWheel(value: boolean): anychart.core.graph.elements.Interactivity;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(value: boolean): anychart.core.graph.elements.Interactivity;
    }
    interface Group {
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string): anychart.core.graph.elements.Group;
        fill(Function: (() => void)): anychart.core.graph.elements.Group;
        height(): number;
        height(value: number): anychart.core.graph.elements.Group;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.graph.elements.Group;
        labels(): anychart.core.ui.LabelsFactory;
        labels(config: object): anychart.core.graph.elements.Group;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.graph.elements.Group;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.graph.elements.Group;
        shape(): string;
        shape(value: string): anychart.core.graph.elements.Group;
        stroke(): anychart.graphics.vector.Fill;
        stroke(func: (() => void)): anychart.core.graph.elements.Group;
        stroke(color: anychart.graphics.vector.Fill): anychart.core.graph.elements.Group;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.graph.elements.Group;
        width(): number;
        width(value: number): anychart.core.graph.elements.Group;
    }
    interface Node {
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string): anychart.core.graph.elements.Node;
        fill(Function: (() => void)): anychart.core.graph.elements.Node;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.graph.elements.Node;
        height(): number;
        height(value: number): void;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.graph.elements.Node;
        labels(): anychart.core.ui.LabelsFactory;
        labels(config: object): void;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.graph.elements.Node;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.graph.elements.Node;
        shape(): string;
        shape(value: string | 'rectangle'): anychart.core.graph.elements.Node;
        stroke(): anychart.graphics.vector.Fill;
        stroke(stringOrObject: anychart.graphics.vector.Fill | string): anychart.core.graph.elements.Node;
        stroke(func: (() => void)): anychart.core.graph.elements.Node;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.graph.elements.Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(tooltipConfig: object | boolean): anychart.core.graph.elements.Node;
        width(): number;
        width(value: number): void;
    }
    interface Edge {
        arrows(): anychart.core.graph.elements.edges.arrows.Controller;
        arrows(config: anychart.core.graph.elements.edges.arrows.Controller.Config): anychart.core.graph.elements.Edge;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.graph.elements.Edge;
        labels(): anychart.core.ui.LabelsFactory;
        labels(labelsConfig: object): anychart.core.graph.elements.Edge;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.graph.elements.Edge;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.graph.elements.Edge;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(fillFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.graph.elements.Edge;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.graph.elements.Edge;
        stroke(settings?: Object): anychart.core.graph.elements.Edge;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(tooltipConfig: object | boolean): anychart.core.graph.elements.Edge;
    }
}

declare namespace anychart.core.graph.elements.edges {
}

declare namespace anychart.core.graph.elements.edges.arrows {
    interface Controller {
        enabled(): boolean;
        enabled(enabled: boolean): anychart.core.graph.elements.edges.arrows.Controller;
        position(): string | number;
        position(position: string | number): anychart.core.graph.elements.edges.arrows.Controller;
        size(): number;
        size(size: number): anychart.core.graph.elements.edges.arrows.Controller;
    }
    namespace Controller {
    type Config = {
        enabled: boolean;
        position: string | number;
        size: string;
    }
    }
}

declare namespace anychart.core.grids {
    interface Surface extends anychart.core.VisualBase {
        drawFirstLine(): boolean;
        drawFirstLine(enabled?: boolean): anychart.core.grids.Surface;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.Surface;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.Surface;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.Surface;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Surface;
        fill(color: string, opacity?: number): anychart.core.grids.Surface;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Surface;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Surface;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Surface;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.core.grids.Surface;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Surface;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Surface;
        stroke(settings?: Object): anychart.core.grids.Surface;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.grids.Surface;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.grids.Surface;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.grids.Surface;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.grids.Surface;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Polar extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Polar | anychart.core.axes.Radial;
        axis(axis?: anychart.core.axes.Polar | anychart.core.axes.Radial): anychart.core.grids.Polar;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.Polar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.Polar;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.Polar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.core.grids.Polar;
        isRadial(): boolean;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Polar;
        stroke(settings?: Object): anychart.core.grids.Polar;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | string | Object): anychart.core.grids.Polar;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | string | Object): anychart.core.grids.Polar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.grids.Polar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.grids.Polar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.grids.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.grids.Polar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Linear extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.core.grids.Linear;
        drawFirstLine(): boolean;
        drawFirstLine(enabled?: boolean): anychart.core.grids.Linear;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.Linear;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.Linear;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.Linear;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Linear;
        fill(color: string, opacity?: number): anychart.core.grids.Linear;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.core.grids.Linear;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Linear;
        scale(): anychart.scales.Base;
        scale(settings?: Object | string | anychart.scales.Base): anychart.core.grids.Linear;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Linear;
        stroke(settings?: Object): anychart.core.grids.Linear;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.grids.Linear;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.grids.Linear;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.grids.Linear;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.grids.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MapSettings extends anychart.core.Base {
        drawFirstLine(): boolean;
        drawFirstLine(enabled?: boolean): anychart.core.grids.MapSettings;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.MapSettings;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.MapSettings;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.MapSettings;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.MapSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.MapSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.MapSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.MapSettings;
        horizontal(): anychart.core.grids.Map;
        horizontal(settings?: boolean | Object): anychart.core.grids.MapSettings;
        minorStroke(): string | anychart.graphics.vector.Stroke;
        minorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.MapSettings;
        minorStroke(settings?: Object): anychart.core.grids.MapSettings;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.MapSettings;
        stroke(settings?: Object): anychart.core.grids.MapSettings;
        vertical(): anychart.core.grids.Map;
        vertical(settings?: boolean | Object): anychart.core.grids.MapSettings;
        zIndex(): number | string;
        zIndex(zIndex?: number | string): anychart.core.grids.MapSettings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Stock extends anychart.core.VisualBase {
        axis(): anychart.core.axes.StockDateTime | anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.StockDateTime | anychart.core.axes.Linear): anychart.core.grids.Stock;
        drawFirstLine(): boolean;
        drawFirstLine(enabled?: boolean): anychart.core.grids.Stock;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.Stock;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.Stock;
        fill(): anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.Stock;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Stock;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Stock;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Stock;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.core.grids.Stock;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        scale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        scale(settings?: Object | anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.grids.Stock;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Stock;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.grids.Stock;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.grids.Stock;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.grids.Stock;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.grids.Stock;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Radar extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Radar | anychart.core.axes.Radial;
        axis(axis?: anychart.core.axes.Radar | anychart.core.axes.Radial): anychart.core.grids.Radar;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.Radar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.Radar;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.Radar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Radar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.core.grids.Radar;
        isRadial(): boolean;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        stroke(settings?: Object): anychart.core.grids.Radar;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Radar;
        stroke(settings?: Object): anychart.core.grids.Radar;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: anychart.scales.Ordinal | string | Object): anychart.core.grids.Radar;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | string | Object): anychart.core.grids.Radar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.grids.Radar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.grids.Radar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.grids.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.grids.Radar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Map extends anychart.core.VisualBase {
        drawFirstLine(): boolean;
        drawFirstLine(enabled?: boolean): anychart.core.grids.Map;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.core.grids.Map;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.grids.Map;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.grids.Map;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.core.grids.Map;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Map;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Map;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Map;
        minorStroke(): string | anychart.graphics.vector.Stroke;
        minorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Map;
        minorStroke(settings?: Object): anychart.core.grids.Map;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Map;
        stroke(settings?: Object): anychart.core.grids.Map;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.grids.Map;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.grids.Map;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.grids.Map;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.grids.Map;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.linearGauge {
    interface ScaleBar extends anychart.core.VisualBase {
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.linearGauge.ScaleBar;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.ScaleBar;
        fill(color: string, opacity?: number): anychart.core.linearGauge.ScaleBar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.ScaleBar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.ScaleBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.ScaleBar;
        from(): string | number;
        from(fromValue?: string | number): anychart.core.linearGauge.ScaleBar;
        offset(): string;
        offset(offset?: string): anychart.core.linearGauge.ScaleBar;
        points(): Array<anychart.core.linearGauge.ScaleBar.ControlPoint>;
        points(pointsList?: Array<anychart.core.linearGauge.ScaleBar.ControlPoint>): anychart.core.linearGauge.ScaleBar;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.scales.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.ScaleBar;
        stroke(settings?: Object): anychart.core.linearGauge.ScaleBar;
        to(): string | number;
        to(toValue?: string | number): anychart.core.linearGauge.ScaleBar;
        width(): string;
        width(width?: string): anychart.core.linearGauge.ScaleBar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.ScaleBar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.ScaleBar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.ScaleBar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.ScaleBar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.ScaleBar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace ScaleBar {
    type ControlPoint = {
        height: number;
        left: number;
        right: number;
    }
    }
}

declare namespace anychart.core.linearGauge.pointers {
    interface Tank extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.Tank;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.Tank;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Tank;
        emptyFill(): anychart.graphics.vector.Fill | (() => void);
        emptyFill(color: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Tank;
        emptyFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.linearGauge.pointers.Tank;
        emptyFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Tank;
        emptyHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        emptyHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Tank;
        emptyHatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Tank;
        emptyHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Tank;
        emptyHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Tank;
        emptyHatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Tank;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.Tank;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.Tank;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Tank;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Tank;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Tank;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Tank;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Tank;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Tank;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Tank;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Tank;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Tank;
        hover(): anychart.core.linearGauge.pointers.Tank;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.Tank;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.Tank;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Tank;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.Tank;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.Tank;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.Tank;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.Tank;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.Tank;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Tank;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.Tank;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.Tank;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Tank;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.Tank;
        unhover(): anychart.core.linearGauge.pointers.Tank;
        unselect(): anychart.core.linearGauge.pointers.Tank;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.Tank;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.Tank;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.Tank;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.Tank;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.Tank;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.VisualBase {
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.Base;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.Base;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Base;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Base;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Base;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeBar extends anychart.core.linearGauge.pointers.Bar {
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.RangeBar;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.RangeBar;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.RangeBar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.RangeBar;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.RangeBar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.linearGauge.pointers.RangeBar;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.RangeBar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.RangeBar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.RangeBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.RangeBar;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.RangeBar;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.RangeBar;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.RangeBar;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.RangeBar;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.RangeBar;
        hover(): anychart.core.linearGauge.pointers.RangeBar;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.RangeBar;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.RangeBar;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.RangeBar;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.RangeBar;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.RangeBar;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.RangeBar;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.RangeBar;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.RangeBar;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.RangeBar;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.RangeBar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.RangeBar;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.RangeBar;
        unhover(): anychart.core.linearGauge.pointers.RangeBar;
        unselect(): anychart.core.linearGauge.pointers.RangeBar;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.RangeBar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.RangeBar;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.RangeBar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.RangeBar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.RangeBar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.RangeBar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bar extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.Bar;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.Bar;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Bar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.Bar;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.Bar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.linearGauge.pointers.Bar;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Bar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Bar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Bar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Bar;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Bar;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Bar;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Bar;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Bar;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Bar;
        hover(): anychart.core.linearGauge.pointers.Bar;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.Bar;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.Bar;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Bar;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.Bar;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.Bar;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.Bar;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.Bar;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.Bar;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Bar;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.Bar;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.Bar;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Bar;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.Bar;
        unhover(): anychart.core.linearGauge.pointers.Bar;
        unselect(): anychart.core.linearGauge.pointers.Bar;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.Bar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.Bar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.Bar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.Bar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.Bar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Led extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.Led;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(colorScale?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.linearGauge.pointers.Led;
        count(): number;
        count(count?: number): anychart.core.linearGauge.pointers.Led;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.Led;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Led;
        dimmer(): ((fill:anychart.graphics.vector.Fill)=>anychart.graphics.vector.Fill);
        dimmer(dimmerFunction?: ((fill:anychart.graphics.vector.Fill)=>anychart.graphics.vector.Fill)): anychart.core.linearGauge.pointers.Led;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.Led;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.Led;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Led;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Led;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Led;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Led;
        gap(): number | string;
        gap(gap?: number | string): anychart.core.linearGauge.pointers.Led;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Led;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Led;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Led;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Led;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Led;
        hover(): anychart.core.linearGauge.pointers.Led;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.Led;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.Led;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Led;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.Led;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.Led;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.Led;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.Led;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.Led;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Led;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.Led;
        size(): number | string;
        size(size?: number | string): anychart.core.linearGauge.pointers.Led;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.Led;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Led;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.Led;
        unhover(): anychart.core.linearGauge.pointers.Led;
        unselect(): anychart.core.linearGauge.pointers.Led;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.Led;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.Led;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.Led;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.Led;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.Led;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.linearGauge.pointers.Base {
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.Marker;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.Marker;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.Marker;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.Marker;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Marker;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Marker;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Marker;
        hover(): anychart.core.linearGauge.pointers.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.Marker;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.Marker;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.Marker;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.Marker;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.Marker;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.Marker;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.Marker;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Marker;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.Marker;
        type(): string;
        type(type?: string): anychart.core.linearGauge.pointers.Marker;
        unhover(): anychart.core.linearGauge.pointers.Marker;
        unselect(): anychart.core.linearGauge.pointers.Marker;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Thermometer extends anychart.core.linearGauge.pointers.Base {
        bulbPadding(): string | number;
        bulbPadding(padding?: string | number): anychart.core.linearGauge.pointers.Thermometer;
        bulbRadius(): string;
        bulbRadius(radius?: string): anychart.core.linearGauge.pointers.Thermometer;
        color(): string;
        color(color: string): anychart.core.linearGauge.pointers.Thermometer;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.linearGauge.pointers.Thermometer;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Thermometer;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.linearGauge.pointers.Thermometer;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.linearGauge.pointers.Thermometer;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Thermometer;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Thermometer;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Thermometer;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Thermometer;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Thermometer;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.linearGauge.pointers.Thermometer;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.linearGauge.pointers.Thermometer;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.linearGauge.pointers.Thermometer;
        hatchFill(enabled?: boolean): anychart.core.linearGauge.pointers.Thermometer;
        hover(): anychart.core.linearGauge.pointers.Thermometer;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.linearGauge.pointers.Thermometer;
        id(): string | number;
        id(id?: string | number): anychart.core.linearGauge.pointers.Thermometer;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Thermometer;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.linearGauge.pointers.Thermometer;
        name(): string;
        name(name?: string): anychart.core.linearGauge.pointers.Thermometer;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.linearGauge.pointers.Thermometer;
        offset(): string;
        offset(offset?: string | number): anychart.core.linearGauge.pointers.Thermometer;
        scale(): anychart.scales.Base;
        scale(scale?: anychart.scales.Base): anychart.core.linearGauge.pointers.Thermometer;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Thermometer;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.linearGauge.pointers.Thermometer;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.linearGauge.pointers.Thermometer;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Thermometer;
        stroke(settings?: Object): anychart.core.linearGauge.pointers.Thermometer;
        unhover(): anychart.core.linearGauge.pointers.Thermometer;
        unselect(): anychart.core.linearGauge.pointers.Thermometer;
        width(): string;
        width(width?: string): anychart.core.linearGauge.pointers.Thermometer;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.linearGauge.pointers.Thermometer;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.linearGauge.pointers.Thermometer;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.linearGauge.pointers.Thermometer;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.linearGauge.pointers.Thermometer;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.map {
}

declare namespace anychart.core.map.series {
    interface Base extends anychart.core.SeriesBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.map.series.Base;
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.map.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.map.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.map.series.Base;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.map.series.Base;
        color(): string;
        color(color: string): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.map.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.map.series.Base;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(id?: string): anychart.core.map.series.Base;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.Base;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.Base;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.Base;
        hatchFill(enabled?: boolean): anychart.core.map.series.Base;
        height(): number | string;
        height(height?: number | string): anychart.core.map.series.Base;
        hover(): anychart.core.map.series.Base;
        hover(index?: number): anychart.core.map.series.Base;
        hover(indexes?: Array<number>): anychart.core.map.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.map.series.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.map.series.Base;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.map.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.map.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.map.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.map.series.Base;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.map.series.Base;
        meta(key?: any, value?: any): anychart.core.map.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.map.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.map.series.Base;
        name(): string;
        name(name?: string): anychart.core.map.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.map.series.Base;
        overlapMode(): string;
        overlapMode(mode?: string | boolean): anychart.core.map.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.map.series.Base;
        select(index?: number): anychart.core.map.series.Base;
        select(indexes?: number | Array<number>): anychart.core.map.series.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.map.series.Base;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.map.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        stroke(settings?: Object): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.map.series.Base;
        transformXY(xCoord: number, yCoord: number): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.map.series.Base;
        unselect(): anychart.core.map.series.Base;
        unselect(index?: number): anychart.core.map.series.Base;
        unselect(indexes?: Array<number>): anychart.core.map.series.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.map.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.map.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.map.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.map.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.map.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.map.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Choropleth extends anychart.core.map.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.map.series.Choropleth;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.map.series.Choropleth;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.map.series.Choropleth;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.map.series.Choropleth;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.map.series.Choropleth;
        color(): string;
        color(color: string): anychart.core.map.series.Choropleth;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(colorScale?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.map.series.Choropleth;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Choropleth;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.map.series.Choropleth;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.map.series.Choropleth;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.map.series.Choropleth;
        fill(color: string, opacity?: number): anychart.core.map.series.Choropleth;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Choropleth;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Choropleth;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Choropleth;
        geoIdField(): string;
        geoIdField(id?: string): anychart.core.map.series.Choropleth;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.Choropleth;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.Choropleth;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.Choropleth;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.Choropleth;
        hatchFill(enabled?: boolean): anychart.core.map.series.Choropleth;
        height(): number | string;
        height(height?: number | string): anychart.core.map.series.Choropleth;
        hover(): anychart.core.map.series.Choropleth;
        hover(index?: number): anychart.core.map.series.Choropleth;
        hover(indexes?: Array<number>): anychart.core.map.series.Choropleth;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.map.series.Choropleth;
        id(): string | number;
        id(id?: string | number): anychart.core.map.series.Choropleth;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.map.series.Choropleth;
        left(): number | string;
        left(left?: number | string): anychart.core.map.series.Choropleth;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.map.series.Choropleth;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.map.series.Choropleth;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.map.series.Choropleth;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.map.series.Choropleth;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.map.series.Choropleth;
        meta(key?: any, value?: any): anychart.core.map.series.Choropleth;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.map.series.Choropleth;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.map.series.Choropleth;
        name(): string;
        name(name?: string): anychart.core.map.series.Choropleth;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.map.series.Choropleth;
        overlapMode(): string;
        overlapMode(mode?: string | boolean): anychart.core.map.series.Choropleth;
        right(): number | string;
        right(right?: number | string): anychart.core.map.series.Choropleth;
        select(index?: number): anychart.core.map.series.Choropleth;
        select(indexes?: number | Array<number>): anychart.core.map.series.Choropleth;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.map.series.Choropleth;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.map.series.Choropleth;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Choropleth;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Choropleth;
        stroke(settings?: Object): anychart.core.map.series.Choropleth;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.map.series.Choropleth;
        top(): number | string;
        top(top?: number | string): anychart.core.map.series.Choropleth;
        transformXY(xCoord: number, yCoord: number): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.map.series.Choropleth;
        unselect(): anychart.core.map.series.Choropleth;
        unselect(index?: number): anychart.core.map.series.Choropleth;
        unselect(indexes?: Array<number>): anychart.core.map.series.Choropleth;
        width(): number | string;
        width(width?: number | string): anychart.core.map.series.Choropleth;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.map.series.Choropleth;
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Choropleth;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.map.series.Choropleth;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.map.series.Choropleth;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.map.series.Choropleth;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bubble extends anychart.core.map.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.map.series.Bubble;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.map.series.Bubble;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.map.series.Bubble;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.map.series.Bubble;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.map.series.Bubble;
        color(): string;
        color(color: string): anychart.core.map.series.Bubble;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(colorScale?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.map.series.Bubble;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Bubble;
        displayNegative(): boolean;
        displayNegative(enabled?: boolean): anychart.core.map.series.Bubble;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.map.series.Bubble;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.map.series.Bubble;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.map.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.map.series.Bubble;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Bubble;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        geoIdField(): string;
        geoIdField(id?: string): anychart.core.map.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.Bubble;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.Bubble;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.Bubble;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.Bubble;
        hatchFill(enabled?: boolean): anychart.core.map.series.Bubble;
        height(): number | string;
        height(height?: number | string): anychart.core.map.series.Bubble;
        hover(): anychart.core.map.series.Bubble;
        hover(index?: number): anychart.core.map.series.Bubble;
        hover(indexes?: Array<number>): anychart.core.map.series.Bubble;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.map.series.Bubble;
        id(): string | number;
        id(id?: string | number): anychart.core.map.series.Bubble;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.map.series.Bubble;
        left(): number | string;
        left(left?: number | string): anychart.core.map.series.Bubble;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.map.series.Bubble;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.map.series.Bubble;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.map.series.Bubble;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.map.series.Bubble;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.map.series.Bubble;
        meta(key?: any, value?: any): anychart.core.map.series.Bubble;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.map.series.Bubble;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.map.series.Bubble;
        name(): string;
        name(name?: string): anychart.core.map.series.Bubble;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.map.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.map.series.Bubble;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Bubble;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        negativeHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.Bubble;
        negativeHatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.Bubble;
        negativeHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.Bubble;
        negativeHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.Bubble;
        negativeHatchFill(enabled?: boolean): anychart.core.map.series.Bubble;
        negativeStroke(): anychart.core.map.series.Bubble;
        negativeStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Bubble;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Bubble;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.map.series.Bubble;
        overlapMode(): string;
        overlapMode(mode?: string | boolean): anychart.core.map.series.Bubble;
        right(): number | string;
        right(right?: number | string): anychart.core.map.series.Bubble;
        select(index?: number): anychart.core.map.series.Bubble;
        select(indexes?: number | Array<number>): anychart.core.map.series.Bubble;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.map.series.Bubble;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.map.series.Bubble;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Bubble;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Bubble;
        stroke(settings?: Object): anychart.core.map.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.map.series.Bubble;
        top(): number | string;
        top(top?: number | string): anychart.core.map.series.Bubble;
        transformXY(xCoord: number, yCoord: number): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.map.series.Bubble;
        unselect(): anychart.core.map.series.Bubble;
        unselect(index?: number): anychart.core.map.series.Bubble;
        unselect(indexes?: Array<number>): anychart.core.map.series.Bubble;
        width(): number | string;
        width(width?: number | string): anychart.core.map.series.Bubble;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.map.series.Bubble;
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Bubble;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.map.series.Bubble;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.map.series.Bubble;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.map.series.Bubble;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaseWithMarkers extends anychart.core.map.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.map.series.BaseWithMarkers;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.map.series.BaseWithMarkers;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.map.series.BaseWithMarkers;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.map.series.BaseWithMarkers;
        color(): string;
        color(color: string): anychart.core.map.series.BaseWithMarkers;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.BaseWithMarkers;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.map.series.BaseWithMarkers;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.map.series.BaseWithMarkers;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.map.series.BaseWithMarkers;
        fill(color: string, opacity?: number): anychart.core.map.series.BaseWithMarkers;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.BaseWithMarkers;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.BaseWithMarkers;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.BaseWithMarkers;
        geoIdField(): string;
        geoIdField(id?: string): anychart.core.map.series.BaseWithMarkers;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.BaseWithMarkers;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.BaseWithMarkers;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.BaseWithMarkers;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.BaseWithMarkers;
        hatchFill(enabled?: boolean): anychart.core.map.series.BaseWithMarkers;
        height(): number | string;
        height(height?: number | string): anychart.core.map.series.BaseWithMarkers;
        hover(): anychart.core.map.series.BaseWithMarkers;
        hover(index?: number): anychart.core.map.series.BaseWithMarkers;
        hover(indexes?: Array<number>): anychart.core.map.series.BaseWithMarkers;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.map.series.BaseWithMarkers;
        id(): string | number;
        id(id?: string | number): anychart.core.map.series.BaseWithMarkers;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.map.series.BaseWithMarkers;
        left(): number | string;
        left(left?: number | string): anychart.core.map.series.BaseWithMarkers;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.map.series.BaseWithMarkers;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.map.series.BaseWithMarkers;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.map.series.BaseWithMarkers;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.map.series.BaseWithMarkers;
        meta(key?: any, value?: any): anychart.core.map.series.BaseWithMarkers;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.map.series.BaseWithMarkers;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.map.series.BaseWithMarkers;
        name(): string;
        name(name?: string): anychart.core.map.series.BaseWithMarkers;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.map.series.BaseWithMarkers;
        right(): number | string;
        right(right?: number | string): anychart.core.map.series.BaseWithMarkers;
        select(index?: number): anychart.core.map.series.BaseWithMarkers;
        select(indexes?: number | Array<number>): anychart.core.map.series.BaseWithMarkers;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.map.series.BaseWithMarkers;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.map.series.BaseWithMarkers;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.BaseWithMarkers;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.BaseWithMarkers;
        stroke(settings?: Object): anychart.core.map.series.BaseWithMarkers;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.map.series.BaseWithMarkers;
        top(): number | string;
        top(top?: number | string): anychart.core.map.series.BaseWithMarkers;
        transformXY(xCoord: number, yCoord: number): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.map.series.BaseWithMarkers;
        unselect(): anychart.core.map.series.BaseWithMarkers;
        unselect(index?: number): anychart.core.map.series.BaseWithMarkers;
        unselect(indexes?: Array<number>): anychart.core.map.series.BaseWithMarkers;
        width(): number | string;
        width(width?: number | string): anychart.core.map.series.BaseWithMarkers;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.map.series.BaseWithMarkers;
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.BaseWithMarkers;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.map.series.BaseWithMarkers;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        overlapMode(): string;
        overlapMode(mode?: string | boolean): anychart.core.map.series.BaseWithMarkers;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.map.series.BaseWithMarkers;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.map.series.BaseWithMarkers;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.map.series.BaseWithMarkers;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.map.series.BaseWithMarkers;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Connector extends anychart.core.map.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.map.series.Connector;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.map.series.Connector;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.map.series.Connector;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.map.series.Connector;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.map.series.Connector;
        color(): string;
        color(color: string): anychart.core.map.series.Connector;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(colorScale?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.map.series.Connector;
        curvature(): string | number;
        curvature(curvature?: number | string): anychart.core.map.series.Connector;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Connector;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.map.series.Connector;
        endSize(): string | number;
        endSize(value?: number | string): anychart.core.map.series.Connector;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.map.series.Connector;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.map.series.Connector;
        fill(color: string, opacity?: number): anychart.core.map.series.Connector;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Connector;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Connector;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Connector;
        geoIdField(): string;
        geoIdField(id?: string): anychart.core.map.series.Connector;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.Connector;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.Connector;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.Connector;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.Connector;
        hatchFill(enabled?: boolean): anychart.core.map.series.Connector;
        height(): number | string;
        height(height?: number | string): anychart.core.map.series.Connector;
        hover(): anychart.core.map.series.Connector;
        hover(index?: number): anychart.core.map.series.Connector;
        hover(indexes?: Array<number>): anychart.core.map.series.Connector;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.map.series.Connector;
        id(): string | number;
        id(id?: string | number): anychart.core.map.series.Connector;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.map.series.Connector;
        left(): number | string;
        left(left?: number | string): anychart.core.map.series.Connector;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.map.series.Connector;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.map.series.Connector;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.map.series.Connector;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.map.series.Connector;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.map.series.Connector;
        meta(key?: any, value?: any): anychart.core.map.series.Connector;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.map.series.Connector;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.map.series.Connector;
        name(): string;
        name(name?: string): anychart.core.map.series.Connector;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.map.series.Connector;
        overlapMode(): string;
        overlapMode(mode?: string | boolean): anychart.core.map.series.Connector;
        right(): number | string;
        right(right?: number | string): anychart.core.map.series.Connector;
        select(index?: number): anychart.core.map.series.Connector;
        select(indexes?: number | Array<number>): anychart.core.map.series.Connector;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.map.series.Connector;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.map.series.Connector;
        startSize(): number | string;
        startSize(size?: number | string): anychart.core.map.series.Connector;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Connector;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Connector;
        stroke(settings?: Object): anychart.core.map.series.Connector;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.map.series.Connector;
        top(): number | string;
        top(top?: number | string): anychart.core.map.series.Connector;
        transformXY(xCoord: number, yCoord: number): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.map.series.Connector;
        unselect(): anychart.core.map.series.Connector;
        unselect(index?: number): anychart.core.map.series.Connector;
        unselect(indexes?: Array<number>): anychart.core.map.series.Connector;
        width(): number | string;
        width(width?: number | string): anychart.core.map.series.Connector;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.map.series.Connector;
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Connector;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.map.series.Connector;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.map.series.Connector;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.map.series.Connector;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.map.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.map.series.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.map.series.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.map.series.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.map.series.Marker;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.map.series.Marker;
        color(): string;
        color(color: string): anychart.core.map.series.Marker;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(colorScale?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.map.series.Marker;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.map.series.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.map.series.Marker;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | string | Array<any>): anychart.core.map.series.Marker;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.map.series.Marker;
        fill(color: string, opacity?: number): anychart.core.map.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Marker;
        geoIdField(): string;
        geoIdField(id?: string): anychart.core.map.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.map.series.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.map.series.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.map.series.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.map.series.Marker;
        hatchFill(enabled?: boolean): anychart.core.map.series.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.map.series.Marker;
        hover(): anychart.core.map.series.Marker;
        hover(index?: number): anychart.core.map.series.Marker;
        hover(indexes?: Array<number>): anychart.core.map.series.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.map.series.Marker;
        id(): string | number;
        id(id?: string | number): anychart.core.map.series.Marker;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.map.series.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.map.series.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.map.series.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.map.series.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.map.series.Marker;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.map.series.Marker;
        meta(key?: any, value?: any): anychart.core.map.series.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.map.series.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.map.series.Marker;
        name(): string;
        name(name?: string): anychart.core.map.series.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.map.series.Marker;
        overlapMode(): string;
        overlapMode(mode?: string | boolean): anychart.core.map.series.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.map.series.Marker;
        select(index?: number): anychart.core.map.series.Marker;
        select(indexes?: number | Array<number>): anychart.core.map.series.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.map.series.Marker;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.map.series.Marker;
        size(): number;
        size(size?: number): anychart.core.map.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Marker;
        stroke(settings?: Object): anychart.core.map.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.map.series.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.map.series.Marker;
        transformXY(xCoord: number, yCoord: number): {[prop:string]:number};
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.map.series.Marker;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.map.series.Marker;
        unselect(): anychart.core.map.series.Marker;
        unselect(index?: number): anychart.core.map.series.Marker;
        unselect(indexes?: Array<number>): anychart.core.map.series.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.map.series.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.map.series.Marker;
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.map.series.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.map.series.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.map.series.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.mekko {
}

declare namespace anychart.core.mekko.series {
    interface Mekko extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.mekko.series.Mekko;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.mekko.series.Mekko;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.mekko.series.Mekko;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.mekko.series.Mekko;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.mekko.series.Mekko;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.mekko.series.Mekko;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.mekko.series.Mekko;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.mekko.series.Mekko;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.mekko.series.Mekko;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.mekko.series.Mekko;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.mekko.series.Mekko;
        fill(color: string, opacity?: number): anychart.core.mekko.series.Mekko;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.mekko.series.Mekko;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.mekko.series.Mekko;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.mekko.series.Mekko;
        getExcludedPoints(): Array<anychart.core.Point>;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        getType(): string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.mekko.series.Mekko;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.mekko.series.Mekko;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.mekko.series.Mekko;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.mekko.series.Mekko;
        hatchFill(enabled?: boolean): anychart.core.mekko.series.Mekko;
        height(): number | string;
        height(height?: number | string): anychart.core.mekko.series.Mekko;
        hover(): anychart.core.mekko.series.Mekko;
        hover(index?: number): anychart.core.mekko.series.Mekko;
        hover(indexes?: Array<number>): anychart.core.mekko.series.Mekko;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.mekko.series.Mekko;
        id(): string | number;
        id(id?: string | number): anychart.core.mekko.series.Mekko;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.mekko.series.Mekko;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.mekko.series.Mekko;
        left(): number | string;
        left(left?: number | string): anychart.core.mekko.series.Mekko;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.mekko.series.Mekko;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.mekko.series.Mekko;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.mekko.series.Mekko;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.mekko.series.Mekko;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.mekko.series.Mekko;
        meta(key?: any): any;
        meta(object?: any): anychart.core.mekko.series.Mekko;
        meta(key?: string, value?: any): anychart.core.mekko.series.Mekko;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.mekko.series.Mekko;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.mekko.series.Mekko;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.mekko.series.Mekko;
        name(): string;
        name(value?: string): anychart.core.mekko.series.Mekko;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.mekko.series.Mekko;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.mekko.series.Mekko;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.mekko.series.Mekko;
        right(): number | string;
        right(right?: number | string): anychart.core.mekko.series.Mekko;
        select(index?: number): anychart.core.mekko.series.Mekko;
        select(indexes?: Array<number>): anychart.core.mekko.series.Mekko;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.mekko.series.Mekko;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.mekko.series.Mekko;
        seriesType(): string;
        seriesType(type?: string): anychart.core.mekko.series.Mekko;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.mekko.series.Mekko;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.mekko.series.Mekko;
        stroke(settings?: Object): anychart.core.mekko.series.Mekko;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.mekko.series.Mekko;
        top(): number | string;
        top(top?: number | string): anychart.core.mekko.series.Mekko;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.mekko.series.Mekko;
        unselect(): anychart.core.mekko.series.Mekko;
        unselect(index?: number): anychart.core.mekko.series.Mekko;
        unselect(indexes?: Array<number>): anychart.core.mekko.series.Mekko;
        width(): number | string;
        width(width?: number | string): anychart.core.mekko.series.Mekko;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.mekko.series.Mekko;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.mekko.series.Mekko;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.mekko.series.Mekko;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.mekko.series.Mekko;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.mekko.series.Mekko;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.mekko.series.Mekko;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.mekko.series.Mekko;
        xMode(): string;
        xMode(xMode?: string): anychart.core.mekko.series.Mekko;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.mekko.series.Mekko;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.mekko.series.Mekko;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.mekko.series.Mekko;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.pert {
    interface Tasks {
        color(): string;
        color(color: string): anychart.core.pert.Tasks;
        dummyFill(): anychart.graphics.vector.Fill;
        dummyFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.pert.Tasks;
        dummyFill(value: anychart.graphics.vector.Fill): anychart.core.pert.Tasks;
        dummyFill(color: string, opacity?: number): anychart.core.pert.Tasks;
        dummyFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Tasks;
        dummyFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        dummyFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Tasks;
        dummyStroke(): anychart.graphics.vector.Stroke;
        dummyStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.pert.Tasks;
        dummyStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        dummyStroke(settings?: Object): anychart.core.pert.Tasks;
        fill(): anychart.graphics.vector.Fill;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.pert.Tasks;
        fill(color: anychart.graphics.vector.Fill): anychart.core.pert.Tasks;
        fill(color: string, opacity?: number): anychart.core.pert.Tasks;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Tasks;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Tasks;
        hovered(): anychart.core.pert.Tasks;
        hovered(settings?: Object): anychart.core.pert.Tasks;
        lowerLabels(): anychart.core.ui.LabelsFactory;
        lowerLabels(settings?: Object | boolean): anychart.core.pert.Tasks;
        normal(): anychart.core.pert.Tasks;
        normal(settings?: Object): anychart.core.pert.Tasks;
        selected(): anychart.core.pert.Tasks;
        selected(settings?: Object): anychart.core.pert.Tasks;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.pert.Tasks;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        stroke(settings?: Object): anychart.core.pert.Tasks;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.pert.Tasks;
        upperLabels(): anychart.core.ui.LabelsFactory;
        upperLabels(settings?: Object | boolean): anychart.core.pert.Tasks;
    }
    interface Milestones {
        color(): string;
        color(color: string): anychart.core.pert.Milestones;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.pert.Milestones;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.pert.Milestones;
        fill(color: string, opacity?: number): anychart.core.pert.Milestones;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Milestones;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Milestones;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.pert.Milestones;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.pert.Milestones;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.pert.Milestones;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.pert.Milestones;
        shape(): string;
        shape(shape?: string): anychart.core.pert.Milestones;
        size(): number | string;
        size(size?: number | string): anychart.core.pert.Milestones;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.pert.Milestones;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Milestones;
        stroke(settings?: Object): anychart.core.pert.Milestones;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.pert.Milestones;
    }
    interface CriticalPath extends anychart.core.Base {
        milestones(): anychart.core.pert.Milestones;
        milestones(settings?: Object): anychart.core.pert.CriticalPath;
        tasks(): anychart.core.pert.Tasks;
        tasks(settings?: Object): anychart.core.pert.CriticalPath;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.polar {
}

declare namespace anychart.core.polar.series {
    interface Polyline extends anychart.core.polar.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Polyline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Polyline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Polyline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Polyline;
        closed(): boolean;
        closed(enabled?: boolean): anychart.core.polar.series.Polyline;
        color(): string;
        color(value: string): anychart.core.polar.series.Polyline;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Polyline;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.polar.series.Polyline;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Polyline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Polyline;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Polyline;
        hover(): anychart.core.polar.series.Polyline;
        hover(index?: number): anychart.core.polar.series.Polyline;
        hover(indexes?: Array<number>): anychart.core.polar.series.Polyline;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Polyline;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Polyline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Polyline;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Polyline;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Polyline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.polar.series.Polyline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Polyline;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Polyline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Polyline;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Polyline;
        meta(key?: string, value?: any): anychart.core.polar.series.Polyline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Polyline;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Polyline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Polyline;
        name(): string;
        name(name?: string): anychart.core.polar.series.Polyline;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Polyline;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Polyline;
        select(index?: number): anychart.core.polar.series.Polyline;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Polyline;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Polyline;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Polyline;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.Polyline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Polyline;
        stroke(settings?: Object): anychart.core.polar.series.Polyline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Polyline;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Polyline;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(): anychart.core.polar.series.Polyline;
        unselect(): anychart.core.polar.series.Polyline;
        unselect(index?: number): anychart.core.polar.series.Polyline;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Polyline;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Polyline;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Polyline;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Polyline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Polyline;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Polyline;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Polyline;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Polyline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Polyline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Polyline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Polyline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ContinuousBase extends anychart.core.polar.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.ContinuousBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.ContinuousBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.ContinuousBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.ContinuousBase;
        closed(): boolean;
        closed(enabled?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): string;
        color(value: string): anychart.core.polar.series.ContinuousBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.ContinuousBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.ContinuousBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.ContinuousBase;
        hover(): anychart.core.polar.series.ContinuousBase;
        hover(index?: number): anychart.core.polar.series.ContinuousBase;
        hover(indexes?: Array<number>): anychart.core.polar.series.ContinuousBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.ContinuousBase;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.ContinuousBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.ContinuousBase;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.ContinuousBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.ContinuousBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.ContinuousBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.ContinuousBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.ContinuousBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.ContinuousBase;
        meta(key?: string, value?: any): anychart.core.polar.series.ContinuousBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.ContinuousBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.ContinuousBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.ContinuousBase;
        name(): string;
        name(name?: string): anychart.core.polar.series.ContinuousBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.ContinuousBase;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.ContinuousBase;
        select(index?: number): anychart.core.polar.series.ContinuousBase;
        select(indexes?: number | Array<number>): anychart.core.polar.series.ContinuousBase;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.ContinuousBase;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.ContinuousBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.ContinuousBase;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.ContinuousBase;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unselect(): anychart.core.polar.series.ContinuousBase;
        unselect(index?: number): anychart.core.polar.series.ContinuousBase;
        unselect(indexes?: Array<number>): anychart.core.polar.series.ContinuousBase;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.ContinuousBase;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.ContinuousBase;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.ContinuousBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.ContinuousBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.ContinuousBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.ContinuousBase;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.ContinuousBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.ContinuousBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.ContinuousBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.ContinuousBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.ContinuousBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.SeriesBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Base;
        color(): string;
        color(value: string): anychart.core.polar.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Base;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Base;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Base;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Base;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Base;
        meta(key?: string, value?: any): anychart.core.polar.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Base;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Base;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Base;
        name(): string;
        name(name?: string): anychart.core.polar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Base;
        select(index?: number): anychart.core.polar.series.Base;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Base;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Base;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.polar.series.Base;
        unselect(): anychart.core.polar.series.Base;
        unselect(index?: number): anychart.core.polar.series.Base;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Base;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Base;
        hover(): anychart.core.polar.series.Base;
        hover(index?: number): anychart.core.polar.series.Base;
        hover(indexes?: Array<number>): anychart.core.polar.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Area extends anychart.core.polar.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Area;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Area;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Area;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Area;
        closed(): boolean;
        closed(enabled?: boolean): anychart.core.polar.series.Area;
        color(): string;
        color(value: string): anychart.core.polar.series.Area;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Area;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.polar.series.Area;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Area;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Area;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.polar.series.Area;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.polar.series.Area;
        fill(color: string, opacity?: number): anychart.core.polar.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Area;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.polar.series.Area;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.polar.series.Area;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.polar.series.Area;
        hatchFill(enabled?: boolean): anychart.core.polar.series.Area;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Area;
        hover(): anychart.core.polar.series.Area;
        hover(index?: number): anychart.core.polar.series.Area;
        hover(indexes?: Array<number>): anychart.core.polar.series.Area;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Area;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Area;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Area;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Area;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Area;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.polar.series.Area;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Area;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Area;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Area;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Area;
        meta(key?: string, value?: any): anychart.core.polar.series.Area;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Area;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Area;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Area;
        name(): string;
        name(name?: string): anychart.core.polar.series.Area;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Area;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Area;
        select(index?: number): anychart.core.polar.series.Area;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Area;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Area;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Area;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Area;
        stroke(settings?: Object): anychart.core.polar.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Area;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Area;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(): anychart.core.polar.series.Area;
        unselect(): anychart.core.polar.series.Area;
        unselect(index?: number): anychart.core.polar.series.Area;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Area;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Area;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Area;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Area;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Area;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Area;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Area;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Area;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Area;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Area;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Area;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Column extends anychart.core.polar.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Column;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Column;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Column;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Column;
        color(): string;
        color(value: string): anychart.core.polar.series.Column;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Column;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Column;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Column;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.polar.series.Column;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.polar.series.Column;
        fill(color: string, opacity?: number): anychart.core.polar.series.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Column;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Column;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.polar.series.Column;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.polar.series.Column;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.polar.series.Column;
        hatchFill(enabled?: boolean): anychart.core.polar.series.Column;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Column;
        hover(): anychart.core.polar.series.Column;
        hover(index?: number): anychart.core.polar.series.Column;
        hover(indexes?: Array<number>): anychart.core.polar.series.Column;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Column;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Column;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Column;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Column;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Column;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.Column;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Column;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Column;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Column;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Column;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Column;
        meta(key?: string, value?: any): anychart.core.polar.series.Column;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Column;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Column;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Column;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Column;
        name(): string;
        name(name?: string): anychart.core.polar.series.Column;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Column;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.polar.series.Column;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Column;
        select(index?: number): anychart.core.polar.series.Column;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Column;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Column;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Column;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.Column;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Column;
        stroke(settings?: Object): anychart.core.polar.series.Column;
        stroke(settings?: Object): anychart.core.polar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Column;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Column;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.polar.series.Column;
        unselect(): anychart.core.polar.series.Column;
        unselect(index?: number): anychart.core.polar.series.Column;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Column;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Column;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Column;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Column;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Column;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Column;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Column;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Column;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.polar.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Line;
        closed(): boolean;
        closed(enabled?: boolean): anychart.core.polar.series.Line;
        color(): string;
        color(value: string): anychart.core.polar.series.Line;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Line;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.polar.series.Line;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Line;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Line;
        hover(): anychart.core.polar.series.Line;
        hover(index?: number): anychart.core.polar.series.Line;
        hover(indexes?: Array<number>): anychart.core.polar.series.Line;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Line;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Line;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Line;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.polar.series.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Line;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Line;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Line;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Line;
        meta(key?: string, value?: any): anychart.core.polar.series.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Line;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Line;
        name(): string;
        name(name?: string): anychart.core.polar.series.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Line;
        select(index?: number): anychart.core.polar.series.Line;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Line;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Line;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Line;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(): anychart.core.polar.series.Line;
        unselect(): anychart.core.polar.series.Line;
        unselect(index?: number): anychart.core.polar.series.Line;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Line;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Line;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Line;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Line;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Line;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColumn extends anychart.core.polar.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.RangeColumn;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.RangeColumn;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.RangeColumn;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.RangeColumn;
        color(): string;
        color(value: string): anychart.core.polar.series.RangeColumn;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.RangeColumn;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.RangeColumn;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.RangeColumn;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.polar.series.RangeColumn;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.polar.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.polar.series.RangeColumn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.RangeColumn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.RangeColumn;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.polar.series.RangeColumn;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.polar.series.RangeColumn;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.polar.series.RangeColumn;
        hatchFill(enabled?: boolean): anychart.core.polar.series.RangeColumn;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.RangeColumn;
        hover(): anychart.core.polar.series.RangeColumn;
        hover(index?: number): anychart.core.polar.series.RangeColumn;
        hover(indexes?: Array<number>): anychart.core.polar.series.RangeColumn;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.RangeColumn;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.RangeColumn;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.RangeColumn;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.RangeColumn;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.RangeColumn;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.RangeColumn;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.RangeColumn;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.RangeColumn;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.RangeColumn;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.RangeColumn;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.RangeColumn;
        meta(key?: string, value?: any): anychart.core.polar.series.RangeColumn;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.RangeColumn;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.RangeColumn;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.RangeColumn;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.RangeColumn;
        name(): string;
        name(name?: string): anychart.core.polar.series.RangeColumn;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.RangeColumn;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.polar.series.RangeColumn;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.RangeColumn;
        select(index?: number): anychart.core.polar.series.RangeColumn;
        select(indexes?: number | Array<number>): anychart.core.polar.series.RangeColumn;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.RangeColumn;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.RangeColumn;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.RangeColumn;
        stroke(settings?: Object): anychart.core.polar.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.RangeColumn;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.RangeColumn;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.polar.series.RangeColumn;
        unselect(): anychart.core.polar.series.RangeColumn;
        unselect(index?: number): anychart.core.polar.series.RangeColumn;
        unselect(indexes?: Array<number>): anychart.core.polar.series.RangeColumn;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.RangeColumn;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.RangeColumn;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.RangeColumn;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.RangeColumn;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.RangeColumn;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.RangeColumn;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.RangeColumn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.polar.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Marker;
        color(): string;
        color(value: string): anychart.core.polar.series.Marker;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Marker;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Marker;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.polar.series.Marker;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.polar.series.Marker;
        fill(color: string, opacity?: number): anychart.core.polar.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.polar.series.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.polar.series.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.polar.series.Marker;
        hatchFill(enabled?: boolean): anychart.core.polar.series.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Marker;
        hover(): anychart.core.polar.series.Marker;
        hover(index?: number): anychart.core.polar.series.Marker;
        hover(indexes?: Array<number>): anychart.core.polar.series.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Marker;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Marker;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Marker;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Marker;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Marker;
        meta(key?: string, value?: any): anychart.core.polar.series.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Marker;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Marker;
        name(): string;
        name(name?: string): anychart.core.polar.series.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Marker;
        select(index?: number): anychart.core.polar.series.Marker;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Marker;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Marker;
        size(): number;
        size(size?: number): anychart.core.polar.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Marker;
        stroke(settings?: Object): anychart.core.polar.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Marker;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.polar.series.Marker;
        unhover(): anychart.core.polar.series.Marker;
        unselect(): anychart.core.polar.series.Marker;
        unselect(index?: number): anychart.core.polar.series.Marker;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Marker;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Marker;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Marker;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Marker;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Marker;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Polygon extends anychart.core.polar.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.polar.series.Polygon;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.polar.series.Polygon;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.polar.series.Polygon;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.polar.series.Polygon;
        closed(): boolean;
        closed(enabled?: boolean): anychart.core.polar.series.Polygon;
        color(): string;
        color(value: string): anychart.core.polar.series.Polygon;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.polar.series.Polygon;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.polar.series.Polygon;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.polar.series.Polygon;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.polar.series.Polygon;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.polar.series.Polygon;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.polar.series.Polygon;
        fill(color: string, opacity?: number): anychart.core.polar.series.Polygon;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Polygon;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Polygon;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Polygon;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Polygon;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.polar.series.Polygon;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.polar.series.Polygon;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.polar.series.Polygon;
        hatchFill(enabled?: boolean): anychart.core.polar.series.Polygon;
        height(): number | string;
        height(height?: number | string): anychart.core.polar.series.Polygon;
        hover(): anychart.core.polar.series.Polygon;
        hover(index?: number): anychart.core.polar.series.Polygon;
        hover(indexes?: Array<number>): anychart.core.polar.series.Polygon;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.polar.series.Polygon;
        id(): string | number;
        id(id?: string | number): anychart.core.polar.series.Polygon;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.polar.series.Polygon;
        left(): number | string;
        left(left?: number | string): anychart.core.polar.series.Polygon;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.polar.series.Polygon;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.polar.series.Polygon;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.polar.series.Polygon;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.polar.series.Polygon;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.polar.series.Polygon;
        meta(key?: any): any;
        meta(object?: any): anychart.core.polar.series.Polygon;
        meta(key?: string, value?: any): anychart.core.polar.series.Polygon;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.polar.series.Polygon;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.polar.series.Polygon;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.polar.series.Polygon;
        name(): string;
        name(name?: string): anychart.core.polar.series.Polygon;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.polar.series.Polygon;
        right(): number | string;
        right(right?: number | string): anychart.core.polar.series.Polygon;
        select(index?: number): anychart.core.polar.series.Polygon;
        select(indexes?: number | Array<number>): anychart.core.polar.series.Polygon;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.polar.series.Polygon;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.polar.series.Polygon;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.polar.series.Polygon;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Polygon;
        stroke(settings?: Object): anychart.core.polar.series.Polygon;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.polar.series.Polygon;
        top(): number | string;
        top(top?: number | string): anychart.core.polar.series.Polygon;
        transformXY(xValue: any, yValue: any): {[prop:string]:number};
        unhover(): anychart.core.polar.series.Polygon;
        unselect(): anychart.core.polar.series.Polygon;
        unselect(index?: number): anychart.core.polar.series.Polygon;
        unselect(indexes?: Array<number>): anychart.core.polar.series.Polygon;
        width(): number | string;
        width(width?: number | string): anychart.core.polar.series.Polygon;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Polygon;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.polar.series.Polygon;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.polar.series.Polygon;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        maxPointWidth(): string | number;
        maxPointWidth(value?: number | string): anychart.core.polar.series.Polygon;
        minPointLength(): string | number;
        minPointLength(value?: number | string): anychart.core.polar.series.Polygon;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.polar.series.Polygon;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.polar.series.Polygon;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.polar.series.Polygon;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.polar.series.Polygon;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.radar {
}

declare namespace anychart.core.radar.series {
    interface ContinuousBase extends anychart.core.radar.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.radar.series.ContinuousBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.radar.series.ContinuousBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.radar.series.ContinuousBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.radar.series.ContinuousBase;
        color(): string;
        color(color: string): anychart.core.radar.series.ContinuousBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.ContinuousBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.radar.series.ContinuousBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.radar.series.ContinuousBase;
        hover(): anychart.core.radar.series.ContinuousBase;
        hover(index?: number): anychart.core.radar.series.ContinuousBase;
        hover(indexes?: Array<number>): anychart.core.radar.series.ContinuousBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.radar.series.ContinuousBase;
        id(): string | number;
        id(id?: string | number): anychart.core.radar.series.ContinuousBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.radar.series.ContinuousBase;
        left(): number | string;
        left(left?: number | string): anychart.core.radar.series.ContinuousBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.radar.series.ContinuousBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.radar.series.ContinuousBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.radar.series.ContinuousBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.radar.series.ContinuousBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.ContinuousBase;
        meta(key?: string, value?: any): anychart.core.radar.series.ContinuousBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.radar.series.ContinuousBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.radar.series.ContinuousBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.radar.series.ContinuousBase;
        name(): string;
        name(name?: string): anychart.core.radar.series.ContinuousBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.radar.series.ContinuousBase;
        right(): number | string;
        right(right?: number | string): anychart.core.radar.series.ContinuousBase;
        select(index?: number): anychart.core.radar.series.ContinuousBase;
        select(indexes?: number | Array<number>): anychart.core.radar.series.ContinuousBase;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.radar.series.ContinuousBase;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.radar.series.ContinuousBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.radar.series.ContinuousBase;
        top(): number | string;
        top(top?: number | string): anychart.core.radar.series.ContinuousBase;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop:string]:number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unselect(): anychart.core.radar.series.ContinuousBase;
        unselect(index?: number): anychart.core.radar.series.ContinuousBase;
        unselect(indexes?: Array<number>): anychart.core.radar.series.ContinuousBase;
        width(): number | string;
        width(width?: number | string): anychart.core.radar.series.ContinuousBase;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.ContinuousBase;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.ContinuousBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.radar.series.ContinuousBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.radar.series.ContinuousBase;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.radar.series.ContinuousBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.radar.series.ContinuousBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.radar.series.ContinuousBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.SeriesBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.radar.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.radar.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.radar.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.radar.series.Base;
        color(): string;
        color(color: string): anychart.core.radar.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.radar.series.Base;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.radar.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.radar.series.Base;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.radar.series.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.radar.series.Base;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.radar.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.radar.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.radar.series.Base;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.radar.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.radar.series.Base;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.radar.series.Base;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.radar.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.radar.series.Base;
        name(): string;
        name(name?: string): anychart.core.radar.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.radar.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.radar.series.Base;
        select(index?: number): anychart.core.radar.series.Base;
        select(indexes?: number | Array<number>): anychart.core.radar.series.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.radar.series.Base;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.radar.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.radar.series.Base;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop:string]:number};
        unhover(): anychart.core.radar.series.Base;
        unhover(index?: number): anychart.core.radar.series.Base;
        unhover(indexes?: Array<number>): anychart.core.radar.series.Base;
        unselect(): anychart.core.radar.series.Base;
        unselect(index?: number): anychart.core.radar.series.Base;
        unselect(indexes?: Array<number>): anychart.core.radar.series.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.radar.series.Base;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.radar.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.radar.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.radar.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.radar.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Area extends anychart.core.radar.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.radar.series.Area;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.radar.series.Area;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.radar.series.Area;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.radar.series.Area;
        color(): string;
        color(color: string): anychart.core.radar.series.Area;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.radar.series.Area;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.radar.series.Area;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Area;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.radar.series.Area;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.radar.series.Area;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.radar.series.Area;
        fill(color: string, opacity?: number): anychart.core.radar.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Area;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.radar.series.Area;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.radar.series.Area;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.radar.series.Area;
        hatchFill(enabled?: boolean): anychart.core.radar.series.Area;
        height(): number | string;
        height(height?: number | string): anychart.core.radar.series.Area;
        hover(): anychart.core.radar.series.Area;
        hover(index?: number): anychart.core.radar.series.Area;
        hover(indexes?: Array<number>): anychart.core.radar.series.Area;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.radar.series.Area;
        id(): string | number;
        id(id?: string | number): anychart.core.radar.series.Area;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.radar.series.Area;
        left(): number | string;
        left(left?: number | string): anychart.core.radar.series.Area;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.radar.series.Area;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.radar.series.Area;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.radar.series.Area;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.radar.series.Area;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.radar.series.Area;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Area;
        meta(key?: string, value?: any): anychart.core.radar.series.Area;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.radar.series.Area;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.radar.series.Area;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.radar.series.Area;
        name(): string;
        name(name?: string): anychart.core.radar.series.Area;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.radar.series.Area;
        right(): number | string;
        right(right?: number | string): anychart.core.radar.series.Area;
        select(index?: number): anychart.core.radar.series.Area;
        select(indexes?: number | Array<number>): anychart.core.radar.series.Area;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.radar.series.Area;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.radar.series.Area;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.radar.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Area;
        stroke(settings?: Object): anychart.core.radar.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.radar.series.Area;
        top(): number | string;
        top(top?: number | string): anychart.core.radar.series.Area;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop:string]:number};
        unhover(): anychart.core.radar.series.Area;
        unselect(): anychart.core.radar.series.Area;
        unselect(index?: number): anychart.core.radar.series.Area;
        unselect(indexes?: Array<number>): anychart.core.radar.series.Area;
        width(): number | string;
        width(width?: number | string): anychart.core.radar.series.Area;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Area;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Area;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.radar.series.Area;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.radar.series.Area;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.radar.series.Area;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.radar.series.Area;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.radar.series.ContinuousBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.radar.series.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.radar.series.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.radar.series.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.radar.series.Line;
        color(): string;
        color(color: string): anychart.core.radar.series.Line;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.radar.series.Line;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.radar.series.Line;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.radar.series.Line;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.radar.series.Line;
        hover(): anychart.core.radar.series.Line;
        hover(index?: number): anychart.core.radar.series.Line;
        hover(indexes?: Array<number>): anychart.core.radar.series.Line;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.radar.series.Line;
        id(): string | number;
        id(id?: string | number): anychart.core.radar.series.Line;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.radar.series.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.radar.series.Line;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.radar.series.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.radar.series.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.radar.series.Line;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.radar.series.Line;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.radar.series.Line;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Line;
        meta(key?: string, value?: any): anychart.core.radar.series.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.radar.series.Line;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.radar.series.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.radar.series.Line;
        name(): string;
        name(name?: string): anychart.core.radar.series.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.radar.series.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.radar.series.Line;
        select(index?: number): anychart.core.radar.series.Line;
        select(indexes?: number | Array<number>): anychart.core.radar.series.Line;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.radar.series.Line;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.radar.series.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.radar.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Line;
        stroke(settings?: Object): anychart.core.radar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.radar.series.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.radar.series.Line;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop:string]:number};
        unhover(): anychart.core.radar.series.Line;
        unselect(): anychart.core.radar.series.Line;
        unselect(index?: number): anychart.core.radar.series.Line;
        unselect(indexes?: Array<number>): anychart.core.radar.series.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.radar.series.Line;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Line;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.radar.series.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.radar.series.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.radar.series.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.radar.series.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.radar.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.radar.series.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.radar.series.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.radar.series.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.radar.series.Marker;
        color(): string;
        color(color: string): anychart.core.radar.series.Marker;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.radar.series.Marker;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.radar.series.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.radar.series.Marker;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.radar.series.Marker;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.radar.series.Marker;
        fill(color: string, opacity?: number): anychart.core.radar.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.radar.series.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.radar.series.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.radar.series.Marker;
        hatchFill(enabled?: boolean): anychart.core.radar.series.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.radar.series.Marker;
        hover(): anychart.core.radar.series.Marker;
        hover(index?: number): anychart.core.radar.series.Marker;
        hover(indexes?: Array<number>): anychart.core.radar.series.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.radar.series.Marker;
        id(): string | number;
        id(id?: string | number): anychart.core.radar.series.Marker;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.radar.series.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.radar.series.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.radar.series.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.radar.series.Marker;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.radar.series.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.radar.series.Marker;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Marker;
        meta(key?: string, value?: any): anychart.core.radar.series.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.radar.series.Marker;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.radar.series.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.radar.series.Marker;
        name(): string;
        name(name?: string): anychart.core.radar.series.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.radar.series.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.radar.series.Marker;
        select(index?: number): anychart.core.radar.series.Marker;
        select(indexes?: number | Array<number>): anychart.core.radar.series.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.radar.series.Marker;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.radar.series.Marker;
        size(): number;
        size(size?: number): anychart.core.radar.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.radar.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Marker;
        stroke(settings?: Object): anychart.core.radar.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.radar.series.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.radar.series.Marker;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop:string]:number};
        type(): string | (() => void);
        type(value?: string | (() => void)): anychart.core.radar.series.Marker;
        unhover(): anychart.core.radar.series.Marker;
        unselect(): anychart.core.radar.series.Marker;
        unselect(index?: number): anychart.core.radar.series.Marker;
        unselect(indexes?: Array<number>): anychart.core.radar.series.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.radar.series.Marker;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Marker;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.radar.series.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.radar.series.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.radar.series.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.radar.series.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.radar.series.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.resource {
    interface Conflicts extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.resource.Conflicts;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Conflicts;
        fill(color: string, opacity?: number): anychart.core.resource.Conflicts;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Conflicts;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Conflicts;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Conflicts;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Conflicts;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.resource.Conflicts;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.resource.Conflicts;
        height(): number;
        height(height?: number): anychart.core.resource.Conflicts;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.resource.Conflicts;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.resource.Conflicts;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Conflicts;
        stroke(settings?: Object): anychart.core.resource.Conflicts;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.resource.Conflicts;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.resource.Conflicts;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.resource.Conflicts;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.resource.Conflicts;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Activities extends anychart.core.Base {
        color(): string;
        color(color: string): anychart.core.resource.Activities;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Activities;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.resource.Activities;
        fill(color: string, opacity?: number): anychart.core.resource.Activities;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Activities;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Activities;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Activities;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Activities;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.resource.Activities;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.resource.Activities;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.resource.Activities;
        hatchFill(enabled?: boolean): anychart.core.resource.Activities;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.resource.Activities;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.resource.Activities;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.resource.Activities;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.resource.Activities;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.resource.Activities;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Activities;
        stroke(settings?: Object): anychart.core.resource.Activities;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Grid extends anychart.core.VisualBaseWithBounds {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.resource.Grid;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.resource.Grid;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.resource.Grid;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.resource.Grid;
        drawBottomLine(): boolean;
        drawBottomLine(enabled?: boolean): anychart.core.resource.Grid;
        drawLeftLine(): boolean;
        drawLeftLine(enabled?: boolean): anychart.core.resource.Grid;
        drawRightLine(): boolean;
        drawRightLine(enabled?: boolean): anychart.core.resource.Grid;
        drawTopLine(): boolean;
        drawTopLine(enabled?: boolean): anychart.core.resource.Grid;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.resource.Grid;
        evenFill(): anychart.graphics.vector.Fill;
        evenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Grid;
        evenFill(color: string, opacity?: number): anychart.core.resource.Grid;
        evenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        evenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        evenHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        evenHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        evenHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.resource.Grid;
        evenHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.resource.Grid;
        evenHolidayFill(): anychart.graphics.vector.Fill;
        evenHolidayFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Grid;
        evenHolidayFill(color: string, opacity?: number): anychart.core.resource.Grid;
        evenHolidayFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        evenHolidayFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        evenHolidayFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        evenHolidayHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        evenHolidayHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        evenHolidayHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.resource.Grid;
        evenHolidayHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.resource.Grid;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.resource.Grid;
        horizontalStroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        horizontalStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Grid;
        left(): number | string;
        left(left?: number | string): anychart.core.resource.Grid;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.resource.Grid;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.resource.Grid;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.resource.Grid;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.resource.Grid;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Grid;
        oddFill(color: string, opacity?: number): anychart.core.resource.Grid;
        oddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        oddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        oddHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        oddHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        oddHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.resource.Grid;
        oddHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.resource.Grid;
        oddHolidayFill(): anychart.graphics.vector.Fill;
        oddHolidayFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Grid;
        oddHolidayFill(color: string, opacity?: number): anychart.core.resource.Grid;
        oddHolidayFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Grid;
        oddHolidayFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Grid;
        oddHolidayFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.Grid;
        oddHolidayHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        oddHolidayHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.resource.Grid;
        oddHolidayHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.resource.Grid;
        oddHolidayHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.resource.Grid;
        overlay(): anychart.core.gantt.Overlay;
        overlay(settings?: Object | boolean): anychart.core.resource.Grid;
        right(): number | string;
        right(right?: number | string): anychart.core.resource.Grid;
        top(): number | string;
        top(top?: number | string): anychart.core.resource.Grid;
        verticalStroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        verticalStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Grid;
        width(): number | string;
        width(width?: number | string): anychart.core.resource.Grid;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.resource.Grid;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.resource.Grid;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.resource.Grid;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.resource.Grid;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Logo extends anychart.core.ui.Background {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.resource.Logo;
        bottomStroke(): anychart.graphics.vector.Stroke;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.resource.Logo;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Logo;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.resource.Logo;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.resource.Logo;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.resource.Logo;
        cornerType(): string;
        cornerType(type?: string): anychart.core.resource.Logo;
        corners(): Array<number>;
        corners(corners?: number | string | Array<number>): anychart.core.resource.Logo;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.resource.Logo;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.resource.Logo;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.resource.Logo;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.Logo;
        fill(color: string, opacity?: number): anychart.core.resource.Logo;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.Logo;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.Logo;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.resource.Logo;
        left(): number | string;
        left(left?: number | string): anychart.core.resource.Logo;
        leftStroke(): anychart.graphics.vector.Stroke;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.resource.Logo;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Logo;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.resource.Logo;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.resource.Logo;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.resource.Logo;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.resource.Logo;
        overlay(): anychart.core.gantt.Overlay;
        overlay(settings?: Object | boolean): anychart.core.resource.Logo;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.resource.Logo;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.resource.Logo;
        right(): number | string;
        right(right?: number | string): anychart.core.resource.Logo;
        rightStroke(): anychart.graphics.vector.Stroke;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.resource.Logo;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Logo;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.resource.Logo;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Logo;
        top(): number | string;
        top(top?: number | string): anychart.core.resource.Logo;
        topStroke(): anychart.graphics.vector.Stroke;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.resource.Logo;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.Logo;
        width(): number | string;
        width(width?: number | string): anychart.core.resource.Logo;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.resource.Logo;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ResourceList extends anychart.core.VisualBaseWithBounds {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.resource.ResourceList;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.resource.ResourceList;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.resource.ResourceList;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.resource.ResourceList;
        descriptions(): anychart.core.resource.resourceList.TextSettings;
        descriptions(settings?: Object): anychart.core.resource.ResourceList;
        drawBottomLine(): boolean;
        drawBottomLine(enabled?: boolean): anychart.core.resource.ResourceList;
        drawLeftLine(): boolean;
        drawLeftLine(enabled?: boolean): anychart.core.resource.ResourceList;
        drawRightLine(): boolean;
        drawRightLine(enabled?: boolean): anychart.core.resource.ResourceList;
        drawTopLine(): boolean;
        drawTopLine(enabled?: boolean): anychart.core.resource.ResourceList;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.resource.ResourceList;
        evenFill(): anychart.graphics.vector.Fill;
        evenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.ResourceList;
        evenFill(color: string, opacity?: number): anychart.core.resource.ResourceList;
        evenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.ResourceList;
        evenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.ResourceList;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.resource.ResourceList;
        images(): anychart.core.resource.resourceList.ImageSettings;
        images(settings?: Object): anychart.core.resource.ResourceList;
        left(): number | string;
        left(left?: number | string): anychart.core.resource.ResourceList;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.resource.ResourceList;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.resource.ResourceList;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.resource.ResourceList;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.resource.ResourceList;
        names(): anychart.core.resource.resourceList.TextSettings;
        names(settings?: Object): anychart.core.resource.ResourceList;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.resource.ResourceList;
        oddFill(color: string, opacity?: number): anychart.core.resource.ResourceList;
        oddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.resource.ResourceList;
        oddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.resource.ResourceList;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.resource.ResourceList;
        overlay(): anychart.core.gantt.Overlay;
        overlay(settings?: string | Object | boolean): anychart.core.resource.ResourceList;
        right(): number | string;
        right(right?: number | string): anychart.core.resource.ResourceList;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.resource.ResourceList;
        stroke(settings?: Object): anychart.core.resource.ResourceList;
        tags(): anychart.core.resource.resourceList.TagsSettings;
        tags(settings?: Object): anychart.core.resource.ResourceList;
        target(): anychart.charts.Resource;
        target(target?: anychart.charts.Resource): anychart.core.resource.ResourceList;
        top(): number | string;
        top(top?: number | string): anychart.core.resource.ResourceList;
        types(): anychart.core.resource.resourceList.TextSettings;
        types(settings?: Object): anychart.core.resource.ResourceList;
        width(): number | string;
        width(width?: number | string): anychart.core.resource.ResourceList;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.resource.ResourceList;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.resource.ResourceList;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.resource.ResourceList;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.resource.ResourceList;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.resource.resourceList {
    interface TagsSettings extends anychart.core.resource.resourceList.TextSettings {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.resource.resourceList.TagsSettings;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Tooltip;
        fontColor(): string;
        fontColor(color?: string): anychart.core.resource.resourceList.TagsSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.resource.resourceList.TagsSettings;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.core.resource.resourceList.TagsSettings;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.resource.resourceList.TagsSettings;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.resource.resourceList.TagsSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.resource.resourceList.TagsSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.resource.resourceList.TagsSettings;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.resource.resourceList.TagsSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.resource.resourceList.TagsSettings;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.resource.resourceList.TagsSettings;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.resource.resourceList.TagsSettings;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.resource.resourceList.TagsSettings;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.TagsSettings;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.resource.resourceList.TagsSettings;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.TagsSettings;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.resource.resourceList.TagsSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.resource.resourceList.TagsSettings;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.resource.resourceList.TagsSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.resource.resourceList.TagsSettings;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.resource.resourceList.TagsSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.resource.resourceList.TagsSettings;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.resource.resourceList.TagsSettings;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.resource.resourceList.TagsSettings;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.resource.resourceList.TagsSettings;
    }
    interface ImageSettings extends anychart.core.resource.resourceList.SettingsWithMargin {
        align(): string;
        align(align: string | anychart.graphics.vector.Image.Align): anychart.core.resource.resourceList.ImageSettings;
        borderRadius(): Array<number>;
        borderRadius(borders?: number | Array<number>): anychart.core.resource.resourceList.ImageSettings;
        fittingMode(): string;
        fittingMode(mode: string | anychart.graphics.vector.Image.Fitting): anychart.core.resource.resourceList.ImageSettings;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.resource.resourceList.ImageSettings;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.ImageSettings;
        opacity(): string;
        opacity(opacity?: number): anychart.core.resource.resourceList.ImageSettings;
        size(): string | number;
        size(size?: string | number): anychart.core.resource.resourceList.ImageSettings;
    }
    interface TextSettings extends anychart.core.resource.resourceList.SettingsWithMargin {
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Tooltip;
        fontColor(): string;
        fontColor(color?: string): anychart.core.resource.resourceList.TextSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.resource.resourceList.TextSettings;
        fontFamily(): string;
        fontFamily(fontFamily?: string): anychart.core.resource.resourceList.TextSettings;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.resource.resourceList.TextSettings;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.resource.resourceList.TextSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.resource.resourceList.TextSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.resource.resourceList.TextSettings;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.resource.resourceList.TextSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.resource.resourceList.TextSettings;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.resource.resourceList.TextSettings;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.resource.resourceList.TextSettings;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.resource.resourceList.TextSettings;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.TextSettings;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.resource.resourceList.TextSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.resource.resourceList.TextSettings;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.resource.resourceList.TextSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.resource.resourceList.TextSettings;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.resource.resourceList.TextSettings;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.resource.resourceList.TextSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.resource.resourceList.TextSettings;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.resource.resourceList.TextSettings;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.resource.resourceList.TextSettings;
    }
    interface SettingsWithMargin {
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.resource.resourceList.SettingsWithMargin;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.resource.resourceList.SettingsWithMargin;
    }
}

declare namespace anychart.core.sankey {
}

declare namespace anychart.core.sankey.elements {
    interface Dropoff extends anychart.core.Base {
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.sankey.elements.Dropoff;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.sankey.elements.Dropoff;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.sankey.elements.Dropoff;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Flow extends anychart.core.Base {
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.sankey.elements.Flow;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.sankey.elements.Flow;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.sankey.elements.Flow;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Node extends anychart.core.Base {
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.sankey.elements.Node;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.sankey.elements.Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.sankey.elements.Node;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.scatter {
}

declare namespace anychart.core.scatter.series {
    interface Base extends anychart.core.SeriesBase {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.scatter.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.scatter.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.scatter.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.scatter.series.Base;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): string;
        color(value: string): anychart.core.scatter.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.scatter.series.Base;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.scatter.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.scatter.series.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.scatter.series.Base;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.scatter.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.scatter.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.scatter.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.scatter.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.scatter.series.Base;
        meta(key?: any): any;
        meta(object?: any): anychart.core.scatter.series.Base;
        meta(key?: string, value?: any): anychart.core.scatter.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.scatter.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.scatter.series.Base;
        name(): string;
        name(value?: string): anychart.core.scatter.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.scatter.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.scatter.series.Base;
        select(index?: number): anychart.core.scatter.series.Base;
        select(indexes?: number | Array<number>): anychart.core.scatter.series.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.scatter.series.Base;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.scatter.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.scatter.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.scatter.series.Base;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.scatter.series.Base;
        unselect(): anychart.core.scatter.series.Base;
        unselect(index?: number): anychart.core.scatter.series.Base;
        unselect(indexes?: Array<number>): anychart.core.scatter.series.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.scatter.series.Base;
        xScale(): anychart.scales.ScatterBase;
        xScale(scale?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.scatter.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.scatter.series.Base;
        hover(): anychart.core.scatter.series.Base;
        hover(index?: number): anychart.core.scatter.series.Base;
        hover(indexes?: Array<number>): anychart.core.scatter.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.scatter.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.scatter.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.scatter.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bubble extends anychart.core.scatter.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.scatter.series.Bubble;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.scatter.series.Bubble;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.scatter.series.Bubble;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.scatter.series.Bubble;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.scatter.series.Bubble;
        color(): string;
        color(value: string): anychart.core.scatter.series.Bubble;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Bubble;
        displayNegative(): boolean;
        displayNegative(enabled?: boolean): anychart.core.scatter.series.Bubble;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.scatter.series.Bubble;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.scatter.series.Bubble;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.scatter.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.scatter.series.Bubble;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.scatter.series.Bubble;
        hatchFill(enabled?: boolean): anychart.core.scatter.series.Bubble;
        height(): number | string;
        height(height?: number | string): anychart.core.scatter.series.Bubble;
        hover(): anychart.core.scatter.series.Bubble;
        hover(index?: number): anychart.core.scatter.series.Bubble;
        hover(indexes?: Array<number>): anychart.core.scatter.series.Bubble;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.scatter.series.Bubble;
        id(): string | number;
        id(id?: string | number): anychart.core.scatter.series.Bubble;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.scatter.series.Bubble;
        left(): number | string;
        left(left?: number | string): anychart.core.scatter.series.Bubble;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.scatter.series.Bubble;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.scatter.series.Bubble;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.scatter.series.Bubble;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.scatter.series.Bubble;
        meta(key?: any): any;
        meta(object?: any): anychart.core.scatter.series.Bubble;
        meta(key?: string, value?: any): anychart.core.scatter.series.Bubble;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.scatter.series.Bubble;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.scatter.series.Bubble;
        name(): string;
        name(value?: string): anychart.core.scatter.series.Bubble;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.scatter.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        negativeFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        negativeHatchFill(negativeHatchFillFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        negativeHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.scatter.series.Bubble;
        negativeHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.scatter.series.Bubble;
        negativeHatchFill(enabled?: boolean): anychart.core.scatter.series.Bubble;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.scatter.series.Bubble;
        negativeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        negativeStroke(settings?: Object): anychart.core.scatter.series.Bubble;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.scatter.series.Bubble;
        right(): number | string;
        right(right?: number | string): anychart.core.scatter.series.Bubble;
        select(index?: number): anychart.core.scatter.series.Bubble;
        select(indexes?: number | Array<number>): anychart.core.scatter.series.Bubble;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.scatter.series.Bubble;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.scatter.series.Bubble;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.scatter.series.Bubble;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        stroke(settings?: Object): anychart.core.scatter.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.scatter.series.Bubble;
        top(): number | string;
        top(top?: number | string): anychart.core.scatter.series.Bubble;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(): anychart.core.scatter.series.Bubble;
        unselect(): anychart.core.scatter.series.Bubble;
        unselect(index?: number): anychart.core.scatter.series.Bubble;
        unselect(indexes?: Array<number>): anychart.core.scatter.series.Bubble;
        width(): number | string;
        width(width?: number | string): anychart.core.scatter.series.Bubble;
        xScale(): anychart.scales.ScatterBase;
        xScale(scale?: anychart.scales.Base): anychart.core.scatter.series.Bubble;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.scatter.series.Bubble;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.scatter.series.Bubble;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.scatter.series.Bubble;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.scatter.series.Bubble;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.scatter.series.Bubble;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.scatter.series.Bubble;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface BaseWithMarkers extends anychart.core.scatter.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.scatter.series.BaseWithMarkers;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.scatter.series.BaseWithMarkers;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.scatter.series.BaseWithMarkers;
        color(): string;
        color(value: string): anychart.core.scatter.series.BaseWithMarkers;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.BaseWithMarkers;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.scatter.series.BaseWithMarkers;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.scatter.series.BaseWithMarkers;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        hover(): anychart.core.scatter.series.BaseWithMarkers;
        hover(index?: number): anychart.core.scatter.series.BaseWithMarkers;
        hover(indexes?: Array<number>): anychart.core.scatter.series.BaseWithMarkers;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.scatter.series.BaseWithMarkers;
        id(): string | number;
        id(id?: string | number): anychart.core.scatter.series.BaseWithMarkers;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.scatter.series.BaseWithMarkers;
        left(): number | string;
        left(left?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.scatter.series.BaseWithMarkers;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        meta(key?: any): any;
        meta(object?: any): anychart.core.scatter.series.BaseWithMarkers;
        meta(key?: string, value?: any): anychart.core.scatter.series.BaseWithMarkers;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        name(): string;
        name(value?: string): anychart.core.scatter.series.BaseWithMarkers;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.scatter.series.BaseWithMarkers;
        right(): number | string;
        right(right?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        select(index?: number): anychart.core.scatter.series.BaseWithMarkers;
        select(indexes?: number | Array<number>): anychart.core.scatter.series.BaseWithMarkers;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.scatter.series.BaseWithMarkers;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.scatter.series.BaseWithMarkers;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.scatter.series.BaseWithMarkers;
        top(): number | string;
        top(top?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.scatter.series.BaseWithMarkers;
        unselect(): anychart.core.scatter.series.BaseWithMarkers;
        unselect(index?: number): anychart.core.scatter.series.BaseWithMarkers;
        unselect(indexes?: Array<number>): anychart.core.scatter.series.BaseWithMarkers;
        width(): number | string;
        width(width?: number | string): anychart.core.scatter.series.BaseWithMarkers;
        xScale(): anychart.scales.ScatterBase;
        xScale(scale?: anychart.scales.Base): anychart.core.scatter.series.BaseWithMarkers;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.scatter.series.BaseWithMarkers;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.scatter.series.BaseWithMarkers;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.scatter.series.BaseWithMarkers;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.scatter.series.BaseWithMarkers;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.scatter.series.BaseWithMarkers;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.scatter.series.BaseWithMarkers;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.scatter.series.BaseWithMarkers {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.scatter.series.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.scatter.series.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.scatter.series.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.scatter.series.Line;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.scatter.series.Line;
        color(): string;
        color(value: string): anychart.core.scatter.series.Line;
        connectMissingPoints(): boolean;
        connectMissingPoints(enabled?: boolean): anychart.core.scatter.series.Line;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.scatter.series.Line;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.scatter.series.Line;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.scatter.series.Line;
        hover(): anychart.core.scatter.series.Line;
        hover(index?: number): anychart.core.scatter.series.Line;
        hover(indexes?: Array<number>): anychart.core.scatter.series.Line;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.scatter.series.Line;
        id(): string | number;
        id(id?: string | number): anychart.core.scatter.series.Line;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.scatter.series.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.scatter.series.Line;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.scatter.series.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.scatter.series.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.scatter.series.Line;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.scatter.series.Line;
        meta(key?: any): any;
        meta(object?: any): anychart.core.scatter.series.Line;
        meta(key?: string, value?: any): anychart.core.scatter.series.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.scatter.series.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.scatter.series.Line;
        name(): string;
        name(value?: string): anychart.core.scatter.series.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.scatter.series.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.scatter.series.Line;
        select(index?: number): anychart.core.scatter.series.Line;
        select(indexes?: number | Array<number>): anychart.core.scatter.series.Line;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.scatter.series.Line;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.scatter.series.Line;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.scatter.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Line;
        stroke(settings?: Object): anychart.core.scatter.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.scatter.series.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.scatter.series.Line;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(): anychart.core.scatter.series.Line;
        unselect(): anychart.core.scatter.series.Line;
        unselect(index?: number): anychart.core.scatter.series.Line;
        unselect(indexes?: Array<number>): anychart.core.scatter.series.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.scatter.series.Line;
        xScale(): anychart.scales.ScatterBase;
        xScale(scale?: anychart.scales.Base): anychart.core.scatter.series.Line;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.scatter.series.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.scatter.series.Line;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.scatter.series.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.scatter.series.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.scatter.series.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.scatter.series.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.scatter.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.scatter.series.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.scatter.series.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.scatter.series.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.scatter.series.Marker;
        clip(): boolean | anychart.math.Rect;
        clip(settings?: boolean | anychart.math.Rect): anychart.core.scatter.series.Marker;
        color(): string;
        color(value: string): anychart.core.scatter.series.Marker;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.scatter.series.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.scatter.series.Marker;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.scatter.series.Marker;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.scatter.series.Marker;
        fill(color: string, opacity?: number): anychart.core.scatter.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.scatter.series.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.scatter.series.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.scatter.series.Marker;
        hatchFill(enabled?: boolean): anychart.core.scatter.series.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.scatter.series.Marker;
        hover(): anychart.core.scatter.series.Marker;
        hover(index?: number): anychart.core.scatter.series.Marker;
        hover(indexes?: Array<number>): anychart.core.scatter.series.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.scatter.series.Marker;
        id(): string | number;
        id(id?: string | number): anychart.core.scatter.series.Marker;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.scatter.series.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.scatter.series.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.scatter.series.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.scatter.series.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.scatter.series.Marker;
        meta(key?: any): any;
        meta(object?: any): anychart.core.scatter.series.Marker;
        meta(key?: string, value?: any): anychart.core.scatter.series.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.scatter.series.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.scatter.series.Marker;
        name(): string;
        name(value?: string): anychart.core.scatter.series.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.scatter.series.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.scatter.series.Marker;
        select(index?: number): anychart.core.scatter.series.Marker;
        select(indexes?: number | Array<number>): anychart.core.scatter.series.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.scatter.series.Marker;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.scatter.series.Marker;
        size(): number;
        size(size?: number): anychart.core.scatter.series.Marker;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.scatter.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Marker;
        stroke(settings?: Object): anychart.core.scatter.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.scatter.series.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.scatter.series.Marker;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.scatter.series.Marker;
        unhover(): anychart.core.scatter.series.Marker;
        unselect(): anychart.core.scatter.series.Marker;
        unselect(index?: number): anychart.core.scatter.series.Marker;
        unselect(indexes?: Array<number>): anychart.core.scatter.series.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.scatter.series.Marker;
        xScale(): anychart.scales.ScatterBase;
        xScale(scale?: anychart.scales.Base): anychart.core.scatter.series.Marker;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.scatter.series.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.scatter.series.Marker;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.scatter.series.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.scatter.series.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.scatter.series.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.scatter.series.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.series {
    interface Cartesian extends anychart.core.series.Base {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.series.Cartesian;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.series.Cartesian;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.series.Cartesian;
        clip(value?: boolean | anychart.math.Rect): anychart.core.series.Cartesian | boolean | anychart.math.Rect;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.series.Cartesian | anychart.data.View;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.series.Cartesian;
        error(value?: Object | boolean | string): anychart.core.utils.Error | anychart.core.series.Cartesian;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.Point;
        height(): number | string;
        height(height?: number | string): anychart.core.series.Cartesian;
        hover(indexOrIndexes?: number | Array<number>): anychart.core.series.Cartesian;
        hoverLabels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Cartesian;
        hoverMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Cartesian;
        hoverOutlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Cartesian;
        id(value?: string): string | anychart.core.series.Cartesian;
        labels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Cartesian;
        left(): number | string;
        left(left?: number | string): anychart.core.series.Cartesian;
        legendItem(value?: Object): anychart.core.utils.LegendItemSettings | anychart.core.series.Cartesian;
        markers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Cartesian;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.series.Cartesian;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.series.Cartesian;
        meta(object_or_key?: any, value?: any): any;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.series.Cartesian;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.series.Cartesian;
        name(value?: string): anychart.core.series.Cartesian | string;
        outlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Cartesian;
        right(): number | string;
        right(right?: number | string): anychart.core.series.Cartesian;
        select(indexOrIndexes?: number | Array<number>): anychart.core.series.Cartesian;
        selectLabels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Cartesian;
        selectMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Cartesian;
        selectOutlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Cartesian;
        selectionMode(value?: string): anychart.core.series.Cartesian | string;
        seriesType(value?: string): anychart.core.series.Cartesian | string;
        tooltip(value?: Object | boolean): anychart.core.series.Cartesian;
        top(): number | string;
        top(top?: number | string): anychart.core.series.Cartesian;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.series.Cartesian;
        unselect(indexOrIndexes?: number | Array<number>): anychart.core.series.Cartesian;
        width(): number | string;
        width(width?: number | string): anychart.core.series.Cartesian;
        xScale(value?: anychart.scales.Base): anychart.scales.Base | anychart.core.series.Cartesian;
        yScale(value?: anychart.scales.Base): anychart.scales.Base | anychart.core.series.Cartesian;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.series.Cartesian;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.series.Cartesian;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.series.Cartesian;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.series.Cartesian;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.series.Base;
        clip(value?: boolean | anychart.math.Rect): anychart.core.series.Base | boolean | anychart.math.Rect;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.series.Base;
        error(value?: Object | boolean | string): anychart.core.utils.Error | anychart.core.series.Base;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        height(): number | string;
        height(height?: number | string): anychart.core.series.Base;
        hoverLabels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Base;
        hoverMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Base;
        hoverOutlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Base;
        id(value?: string): string | anychart.core.series.Base;
        labels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.series.Base;
        legendItem(value?: Object): anychart.core.utils.LegendItemSettings | anychart.core.series.Base;
        markers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.series.Base;
        meta(object_or_key?: any, value?: any): any;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.series.Base;
        name(value?: string): anychart.core.series.Base | string;
        outlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.series.Base;
        selectLabels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Base;
        selectMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Base;
        selectOutlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Base;
        seriesType(value?: string): anychart.core.series.Base | string;
        tooltip(value?: Object | boolean): anychart.core.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.series.Base;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        width(): number | string;
        width(width?: number | string): anychart.core.series.Base;
        yScale(value?: anychart.scales.Base): anychart.scales.Base | anychart.core.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Stock extends anychart.core.series.Base {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.series.Stock;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.series.Stock;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.series.Stock;
        clip(value?: boolean | anychart.math.Rect): anychart.core.series.Stock | boolean | anychart.math.Rect;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number|string,type:string|string,weights:number|string}|number|string}, csvSettings?: Object): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string | anychart.core.series.Stock;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.series.Stock;
        error(value?: Object | boolean | string): anychart.core.utils.Error | anychart.core.series.Stock;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        height(): number | string;
        height(height?: number | string): anychart.core.series.Stock;
        hoverLabels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Stock;
        hoverMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Stock;
        hoverOutlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Stock;
        id(value?: string): string | anychart.core.series.Stock;
        labels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Stock;
        left(): number | string;
        left(left?: number | string): anychart.core.series.Stock;
        legendItem(value?: Object): anychart.core.utils.LegendItemSettings | anychart.core.series.Stock;
        markers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Stock;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.series.Stock;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.series.Stock;
        meta(object_or_key?: any, value?: any): any;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.series.Stock;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.series.Stock;
        name(value?: string): anychart.core.series.Stock | string;
        outlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Stock;
        right(): number | string;
        right(right?: number | string): anychart.core.series.Stock;
        selectLabels(value?: Object | boolean): anychart.core.ui.LabelsFactory | anychart.core.series.Stock;
        selectMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Stock;
        selectOutlierMarkers(value?: Object | boolean | string): anychart.core.ui.MarkersFactory | anychart.core.series.Stock;
        seriesType(value?: string): anychart.core.series.Stock | string;
        tooltip(value?: Object | boolean): anychart.core.series.Stock;
        top(): number | string;
        top(top?: number | string): anychart.core.series.Stock;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        width(): number | string;
        width(width?: number | string): anychart.core.series.Stock;
        yScale(value?: anychart.scales.Base): anychart.scales.Base | anychart.core.series.Stock;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.series.Stock;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.series.Stock;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.series.Stock;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.series.Stock;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RenderingSettings extends anychart.core.Base {
        finish(): (() => void);
        finish(finishFunction?: (() => void)): anychart.core.series.RenderingSettings;
        needsWidth(): boolean;
        needsWidth(enabled?: boolean): anychart.core.series.RenderingSettings;
        needsZero(): boolean;
        needsZero(enabled?: boolean): anychart.core.series.RenderingSettings;
        point(): (() => void);
        point(pointFunction?: (() => void)): anychart.core.series.RenderingSettings;
        shapes(): Array<anychart.core.series.RenderingSettings.ShapeConfig>;
        shapes(config?: Array<anychart.core.series.RenderingSettings.ShapeConfig>): anychart.core.series.RenderingSettings;
        start(): (() => void);
        start(startFunction?: (() => void)): anychart.core.series.RenderingSettings;
        updatePoint(): (() => void);
        updatePoint(pointFunction?: (() => void)): anychart.core.series.RenderingSettings;
        yValues(): Array<string>;
        yValues(value?: Array<string>): anychart.core.series.RenderingSettings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace RenderingSettings {
    type ShapeConfig = {
        canBeHoveredSelected?: boolean;
        fillName?: string;
        isHatchFill?: boolean;
        name?: string;
        scrollerSelected?: boolean;
        shapeType?: string;
        strokeName?: string;
        zIndex?: number;
    }
    }
    module RenderingSettings {
    interface Context {
        getShapesGroup(state?: string, baseZIndex?: number, restrictShapes?: {[prop:string]:string}): {[prop:string]:anychart.graphics.vector.Shape};
        getStat(key?: string): any;
    }
    }
    module RenderingSettings {
    interface PointContext extends anychart.core.series.RenderingSettings.Context {
        getDataValue(name: string): any;
        getShapesGroup(state?: string, baseZIndex?: number, restrictShapes?: {[prop:string]:string}): {[prop:string]:anychart.graphics.vector.Shape};
        getStackedValue(): any;
        getStackedZero(): any;
        getStat(key?: string): any;
    }
    }
}

declare namespace anychart.core.stock {
    interface Scroller extends anychart.core.ui.Scroller {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.stock.scrollerSeries.Base>;
        adl(mapping: anychart.data.TableMapping, seriesType?: string): anychart.core.stock.indicators.ADL;
        allowRangeChange(): boolean;
        allowRangeChange(enabled?: boolean): anychart.core.stock.Scroller;
        ama(mapping: anychart.data.TableMapping, period?: number, fastPeriod?: number, slowPeriod?: number, seriesType?: string): anychart.core.stock.indicators.AMA;
        ao(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string, seriesType?: string): anychart.core.stock.indicators.AO;
        area(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Area;
        aroon(mapping: anychart.data.TableMapping, period?: number, upSeriesType?: string, downSeriesType?: string): anychart.core.stock.indicators.Aroon;
        atr(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.ATR;
        autoHide(): boolean;
        autoHide(enabled?: boolean): anychart.core.stock.Scroller;
        bbands(mapping: anychart.data.TableMapping, period?: number, deviation?: number, middleSeriesType?: string, upperSeriesType?: string, lowerSeriesType?: string): anychart.core.stock.indicators.BBands;
        bbandsB(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: string): anychart.core.stock.indicators.BBandsB;
        bbandsWidth(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: string): anychart.core.stock.indicators.BBandsWidth;
        candlestick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        cci(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.CCI;
        cho(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string, seriesType?: string): anychart.core.stock.indicators.CHO;
        cmf(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.CMF;
        column(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Column;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.core.stock.Scroller;
        dmi(mapping: anychart.data.TableMapping, period?: number, adxPeriod?: number, useWildersSmoothing?: boolean, pdiSeriesType?: string, ndiSeriesType?: string, adxSeriesType?: string): anychart.core.stock.indicators.DMI;
        ema(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.EMA;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.Scroller;
        env(mapping: anychart.data.TableMapping, period?: number, deviation?: number, maType?: string, upperSeriesType?: string, lowerSeriesType?: string): anychart.core.stock.indicators.ENV;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.Scroller;
        fill(color: string, opacity?: number): anychart.core.stock.Scroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.Scroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.Scroller;
        getSeries(id: number | string): anychart.core.stock.scrollerSeries.Base;
        getSeriesAt(index: number): anychart.core.stock.scrollerSeries.Base;
        getSeriesCount(): number;
        ha(mapping: anychart.data.TableMapping, seriesType?: string): anychart.core.stock.indicators.HA;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.core.stock.Scroller;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.Scroller;
        hilo(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Hilo;
        ikh(mapping: anychart.data.TableMapping, conversionPeriod?: number, basePeriod?: number, leadingPeriod?: number, conversionSeriesType?: string, baseSeriesType?: string, leadingSeriesType?: string, laggingSeriesType?: string): anychart.core.stock.indicators.IKH;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.core.stock.Scroller;
        jumpLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.JumpLine;
        kdj(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string, kMultiplier?: number, dMultiplier?: number, kSeriesType?: string, dSeriesType?: string, jSeriesType?: string): anychart.core.stock.indicators.KDJ;
        keltnerChannels(mapping: anychart.data.TableMapping, maPeriod?: number, atrPeriod?: number, maType?: string, multiplier?: number, maSeries?: string): anychart.core.stock.indicators.KeltnerChannels;
        line(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Line;
        macd(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number, macdSeriesType?: string, signalSeriesType?: string, histogramSeriesType?: string): anychart.core.stock.indicators.MACD;
        marker(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.Scroller;
        mfi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.MFI;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.Scroller;
        mma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.MMA;
        momentum(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.Momentum;
        obv(mapping: anychart.data.TableMapping, seriesType?: string): anychart.core.stock.indicators.OBV;
        ohlc(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        orientation(): string;
        orientation(orientation?: string): anychart.core.stock.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.Scroller;
        outlineStroke(settings?: Object): anychart.core.stock.Scroller;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.stock.Scroller;
        ppo(mapping: anychart.data.TableMapping, shortPeriod?: number, longPeriod?: number, smoothingPeriod?: number, ppoSeriesType?: string, signalSeriesType?: string, histogramSeriesType?: string): anychart.core.stock.indicators.PPO;
        priceChannels(mapping: anychart.data.TableMapping, period?: number, middleSeriesType?: string, rangeSeriesType?: string): anychart.core.stock.indicators.PriceChannels;
        psar(mapping: anychart.data.TableMapping, accelerationFactorStart?: number, accelerationFactorIncrement?: number, accelerationFactorMaximum?: number, seriesType?: string): anychart.core.stock.indicators.PSAR;
        psy(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.PSY;
        rangeArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        rangeColumn(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        rangeSplineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        rangeStepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        rat(mapping: anychart.data.TableMapping, baseDate?: any, seriesType?: string): void;
        rci(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.RCI;
        removeAllSeries(): anychart.core.stock.Scroller;
        removeSeries(id: number | string): anychart.core.stock.Scroller;
        removeSeriesAt(index: number): anychart.core.stock.Scroller;
        roc(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.RoC;
        rsi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.RSI;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.stock.Scroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.Scroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.Scroller;
        sma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.SMA;
        spline(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Spline;
        splineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        stepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        stepLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        stick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Stick;
        stochastic(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string, kSeriesType?: string, dSeriesType?: string): anychart.core.stock.indicators.Stochastic;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(settings?: boolean | Object): anychart.core.stock.Scroller;
        trix(mapping: anychart.data.TableMapping, period?: number, signalPeriod?: number, maType?: string, signalMaType?: string, trixSeriesType?: string, signalSeriesType?: string): anychart.core.stock.indicators.TRIX;
        volumeMa(mapping: anychart.data.TableMapping, maPeriod?: number, maType?: string, volumeSeriesType?: string, maSeriesType?: string): anychart.core.stock.indicators.VolumeMA;
        vwap(mapping: anychart.data.TableMapping, vwapSeriesType?: string): anychart.core.stock.indicators.VWAP;
        williamsR(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.WilliamsR;
        xAxis(): anychart.core.axes.StockDateTime;
        xAxis(settings?: Object | boolean): anychart.core.stock.Scroller;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: string | anychart.scales.ScatterBase | Object): anychart.core.stock.Scroller;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.Scroller;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.Scroller;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.Scroller;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.Scroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Plot extends anychart.core.VisualBaseWithBounds {
        addSeries(...var_args: (anychart.data.TableMapping)[]): Array<anychart.core.stock.series.Base>;
        adl(mapping: anychart.data.TableMapping, seriesType?: string): anychart.core.stock.indicators.ADL;
        ama(mapping: anychart.data.TableMapping, period?: number, fastPeriod?: number, slowPeriod?: number, seriesType?: string): anychart.core.stock.indicators.AMA;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.core.stock.Plot;
        ao(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string, seriesType?: string): anychart.core.stock.indicators.AO;
        area(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Area;
        aroon(mapping: anychart.data.TableMapping, period?: number, upSeriesType?: string, downSeriesType?: string): anychart.core.stock.indicators.Aroon;
        atr(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.ATR;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.stock.Plot;
        baseline(): number;
        baseline(value?: number): anychart.core.stock.Plot;
        bbands(mapping: anychart.data.TableMapping, period?: number, deviation?: number, middleSeriesType?: string, upperSeriesType?: string, lowerSeriesType?: string): anychart.core.stock.indicators.BBands;
        bbandsB(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: string): anychart.core.stock.indicators.BBandsB;
        bbandsWidth(mapping: anychart.data.TableMapping, period?: number, deviation?: number, seriesType?: string): anychart.core.stock.indicators.BBandsWidth;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.Plot;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.Plot;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.Plot;
        candlestick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Candlestick;
        cci(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.CCI;
        cho(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string, seriesType?: string): anychart.core.stock.indicators.CHO;
        cmf(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.CMF;
        column(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Column;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(settings?: Object | boolean): anychart.core.stock.Plot;
        dataArea(): anychart.core.ui.DataArea;
        dataArea(settings?: Object | boolean): anychart.core.stock.Plot;
        defaultSeriesType(): string;
        defaultSeriesType(type?: string): anychart.core.stock.Plot;
        dmi(mapping: anychart.data.TableMapping, period?: number, adxPeriod?: number, useWildersSmoothing?: boolean, pdiSeriesType?: string, ndiSeriesType?: string, adxSeriesType?: string): anychart.core.stock.indicators.DMI;
        ema(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.EMA;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.Plot;
        env(mapping: anychart.data.TableMapping, period?: number, deviation?: number, maType?: string, upperSeriesType?: string, lowerSeriesType?: string): anychart.core.stock.indicators.ENV;
        eventMarkers(): anychart.core.stock.eventMarkers.Controller;
        eventMarkers(value?: Object | boolean): anychart.core.stock.Plot;
        getPixelBounds(): anychart.math.Rect;
        getSeries(id: number | string): anychart.core.stock.series.Base;
        getSeriesAt(index: number): anychart.core.stock.series.Base;
        getSeriesCount(): number;
        getStat(key: string): any;
        ha(mapping: anychart.data.TableMapping, seriesType?: string): anychart.core.stock.indicators.HA;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.palettes.HatchFills | anychart.core.stock.Plot;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.Plot;
        hilo(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Hilo;
        ikh(mapping: anychart.data.TableMapping, conversionPeriod?: number, basePeriod?: number, leadingPeriod?: number, conversionSeriesType?: string, baseSeriesType?: string, leadingSeriesType?: string, laggingSeriesType?: string): anychart.core.stock.indicators.IKH;
        isExpanded(): boolean;
        jumpLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.JumpLine;
        kdj(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string, kMultiplier?: number, dMultiplier?: number, kSeriesType?: string, dSeriesType?: string, jSeriesType?: string): anychart.core.stock.indicators.KDJ;
        keltnerChannels(mapping: anychart.data.TableMapping, maPeriod?: number, atrPeriod?: number, maType?: string, multiplier?: number, maSeries?: string): anychart.core.stock.indicators.KeltnerChannels;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.Plot;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.stock.Plot;
        line(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(settings?: Object | boolean): anychart.core.stock.Plot;
        lineMarker(index?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        macd(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number, macdSeriesType?: string, signalSeriesType?: string, histogramSeriesType?: string): anychart.core.stock.indicators.MACD;
        marker(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<string|string>): anychart.core.stock.Plot;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.Plot;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.Plot;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.Plot;
        mfi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.MFI;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.Plot;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.Plot;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.Plot;
        mma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.MMA;
        momentum(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.Momentum;
        moveDown(): anychart.core.stock.Plot;
        moveUp(): anychart.core.stock.Plot;
        noData(): anychart.core.NoDataSettings;
        noData(value?: Object): anychart.core.stock.Plot;
        obv(mapping: anychart.data.TableMapping, seriesType?: string): anychart.core.stock.indicators.OBV;
        ohlc(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.OHLC;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.stock.Plot;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.Plot;
        ppo(mapping: anychart.data.TableMapping, shortPeriod?: number, longPeriod?: number, smoothingPeriod?: number, ppoSeriesType?: string, signalSeriesType?: string, histogramSeriesType?: string): anychart.core.stock.indicators.PPO;
        priceChannels(mapping: anychart.data.TableMapping, period?: number, middleSeriesType?: string, rangeSeriesType?: string): anychart.core.stock.indicators.PriceChannels;
        priceIndicator(index?: number): anychart.core.axisMarkers.CurrentPriceIndicator;
        priceIndicator(value?: Object | boolean): anychart.core.stock.Plot;
        priceIndicator(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        psar(mapping: anychart.data.TableMapping, accelerationFactorStart?: number, accelerationFactorIncrement?: number, accelerationFactorMaximum?: number, seriesType?: string): anychart.core.stock.indicators.PSAR;
        psy(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.PSY;
        rangeArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeArea;
        rangeColumn(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeColumn;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(settings?: Object | boolean): anychart.core.stock.Plot;
        rangeMarker(index?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        rangeSplineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeSplineArea;
        rangeStepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeStepArea;
        rat(mapping: anychart.data.TableMapping, baseDate?: any, seriesType?: string): void;
        rci(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.RCI;
        removeAllSeries(): anychart.core.stock.Plot;
        removeSeries(id: number | string): anychart.core.stock.Plot;
        removeSeriesAt(index: number): anychart.core.stock.Plot;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.Plot;
        roc(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.RoC;
        rsi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.RSI;
        sma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.SMA;
        spline(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Spline;
        splineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.SplineArea;
        stepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.StepArea;
        stepLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.StepLine;
        stick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Stick;
        stochastic(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string, kSeriesType?: string, dSeriesType?: string): anychart.core.stock.indicators.Stochastic;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(settings?: Object | boolean): anychart.core.stock.Plot;
        textMarker(index?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.stock.Plot;
        toggleExpandedState(): anychart.core.stock.Plot;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.Plot;
        trix(mapping: anychart.data.TableMapping, period?: number, signalPeriod?: number, maType?: string, signalMaType?: string, trixSeriesType?: string, signalSeriesType?: string): anychart.core.stock.indicators.TRIX;
        volumeMa(mapping: anychart.data.TableMapping, maPeriod?: number, maType?: string, volumeSeriesType?: string, maSeriesType?: string): anychart.core.stock.indicators.VolumeMA;
        vwap(mapping: anychart.data.TableMapping, vwapSeriesType?: string): anychart.core.stock.indicators.VWAP;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.Plot;
        williamsR(mapping: anychart.data.TableMapping, period?: number, seriesType?: string): anychart.core.stock.indicators.WilliamsR;
        xAxis(): anychart.core.axes.StockDateTime;
        xAxis(settings?: Object | boolean): anychart.core.stock.Plot;
        xGrid(index?: number): anychart.core.grids.Stock;
        xGrid(settings?: Object | boolean): anychart.core.stock.Plot;
        xGrid(index?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        xMinorGrid(index?: number): anychart.core.grids.Stock;
        xMinorGrid(settings?: Object | boolean): anychart.core.stock.Plot;
        xMinorGrid(indexOrValue?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(settings?: Object | boolean): anychart.core.stock.Plot;
        yAxis(index?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        yGrid(index?: number): anychart.core.grids.Stock;
        yGrid(settings?: Object | boolean): anychart.core.stock.Plot;
        yGrid(index?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        yMinorGrid(index?: number): anychart.core.grids.Stock;
        yMinorGrid(settings?: Object | boolean): anychart.core.stock.Plot;
        yMinorGrid(indexOrValue?: number, settings?: Object | boolean): anychart.core.stock.Plot;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: string | anychart.scales.ScatterBase | Object): anychart.core.stock.Plot;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.Plot;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.Plot;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.Plot;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.Plot;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Grouping extends anychart.core.Base {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.Grouping;
        forced(): boolean;
        forced(enabled?: boolean): anychart.core.stock.Grouping;
        getCurrentDataInterval(): anychart.core.stock.Grouping.Level;
        isGrouped(): boolean;
        levels(): Array<anychart.core.stock.Grouping.Level>;
        levels(levelsList?: Array<anychart.core.stock.Grouping.Level|string>): anychart.core.stock.Grouping;
        maxVisiblePoints(): number;
        maxVisiblePoints(count?: number): anychart.core.stock.Grouping;
        minPixPerPoint(): number;
        minPixPerPoint(count?: number): anychart.core.stock.Grouping;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Grouping {
    type Level = {
        count: number;
        unit: string;
    }
    }
}

declare namespace anychart.core.stock.eventMarkers {
    interface Controller extends anychart.core.Base {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.stock.eventMarkers.Controller;
        connector(): anychart.core.utils.Connector;
        connector(settings?: Object): anychart.core.stock.eventMarkers.Controller;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string): anychart.core.stock.eventMarkers.Controller;
        direction(): string;
        direction(direction?: string): anychart.core.stock.eventMarkers.Controller;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.stock.eventMarkers.Controller;
        fieldName(): string;
        fieldName(name: string): anychart.core.stock.eventMarkers.Controller;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.eventMarkers.Controller;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.eventMarkers.Controller;
        fill(color: string, opacity?: number): anychart.core.stock.eventMarkers.Controller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.eventMarkers.Controller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.eventMarkers.Controller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.eventMarkers.Controller;
        fontColor(): string;
        fontColor(color?: string): anychart.core.stock.eventMarkers.Controller;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.stock.eventMarkers.Controller;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.stock.eventMarkers.Controller;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.stock.eventMarkers.Controller;
        fontPadding(): number | string;
        fontPadding(padding?: number | string): anychart.core.stock.eventMarkers.Controller;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.stock.eventMarkers.Controller;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.stock.eventMarkers.Controller;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.stock.eventMarkers.Controller;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.stock.eventMarkers.Controller;
        format(): (() => void) | string;
        format(format?: (() => void) | string): anychart.core.stock.eventMarkers.Controller;
        group(indexOrValue?: number): anychart.core.stock.eventMarkers.Group;
        group(settings?: Object | Array<any> | boolean): anychart.core.stock.eventMarkers.Controller;
        group(index?: number, settings?: Object | Array<any> | boolean): anychart.core.stock.eventMarkers.Controller;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: string | anychart.graphics.vector.Text.HAlign): anychart.core.stock.eventMarkers.Controller;
        height(): string | number;
        height(height?: string | number): anychart.core.stock.eventMarkers.Controller;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.eventMarkers.Controller;
        letterSpacing(): number;
        letterSpacing(spacing?: number): anychart.core.stock.eventMarkers.Controller;
        lineHeight(): number | string;
        lineHeight(height?: number | string): anychart.core.stock.eventMarkers.Controller;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.stock.eventMarkers.Controller;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.stock.eventMarkers.Controller;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.eventMarkers.Controller;
        position(): string;
        position(position?: string): anychart.core.stock.eventMarkers.Controller;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.stock.eventMarkers.Controller;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.eventMarkers.Controller;
        seriesId(): string;
        seriesId(id: string): anychart.core.stock.eventMarkers.Controller;
        stickToLeft(): boolean;
        stickToLeft(enabled?: boolean): anychart.core.stock.eventMarkers.Controller;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        stroke(settings?: Object): anychart.core.stock.eventMarkers.Controller;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: string | anychart.graphics.vector.Text.Direction): anychart.core.stock.eventMarkers.Controller;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.stock.eventMarkers.Controller;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.stock.eventMarkers.Controller;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.stock.eventMarkers.Controller;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.eventMarkers.Controller;
        type(): string;
        type(type: string): anychart.core.stock.eventMarkers.Controller;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.stock.eventMarkers.Controller;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: string | anychart.graphics.vector.Text.VAlign): anychart.core.stock.eventMarkers.Controller;
        width(): string | number;
        width(width?: string | number): anychart.core.stock.eventMarkers.Controller;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.stock.eventMarkers.Controller;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.stock.eventMarkers.Controller;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.eventMarkers.Controller;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Group extends anychart.core.VisualBase {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.stock.eventMarkers.Group;
        connector(): anychart.core.utils.Connector;
        connector(settings?: Object): anychart.core.stock.eventMarkers.Group;
        data(): Array<Object>;
        data(data?: any | anychart.core.stock.eventMarkers.Group.DataFormat): anychart.core.stock.eventMarkers.Group;
        direction(): string;
        direction(direction?: string): anychart.core.stock.eventMarkers.Group;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.stock.eventMarkers.Group;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.eventMarkers.Group;
        fieldName(): string;
        fieldName(name: string): anychart.core.stock.eventMarkers.Group;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.eventMarkers.Group;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.eventMarkers.Group;
        fill(color: string, opacity?: number): anychart.core.stock.eventMarkers.Group;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.eventMarkers.Group;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.eventMarkers.Group;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.eventMarkers.Group;
        fontColor(): string;
        fontColor(color?: string): anychart.core.stock.eventMarkers.Group;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.stock.eventMarkers.Group;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.stock.eventMarkers.Group;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.stock.eventMarkers.Group;
        fontPadding(): number | string;
        fontPadding(padding?: number | string): anychart.core.stock.eventMarkers.Group;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.stock.eventMarkers.Group;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.stock.eventMarkers.Group;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.stock.eventMarkers.Group;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.stock.eventMarkers.Group;
        format(): (() => void) | string;
        format(format?: (() => void) | string): anychart.core.stock.eventMarkers.Group;
        getMarker(index: number): anychart.format.Context;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: string | anychart.graphics.vector.Text.HAlign): anychart.core.stock.eventMarkers.Group;
        height(): string | number;
        height(height?: string | number): anychart.core.stock.eventMarkers.Group;
        hovered(): anychart.core.stock.eventMarkers.Group;
        hovered(settings?: Object): anychart.core.stock.eventMarkers.Group;
        letterSpacing(): number;
        letterSpacing(spacing?: number): anychart.core.stock.eventMarkers.Group;
        lineHeight(): number | string;
        lineHeight(height?: number | string): anychart.core.stock.eventMarkers.Group;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.stock.eventMarkers.Group;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.stock.eventMarkers.Group;
        normal(): anychart.core.stock.eventMarkers.Group;
        normal(settings?: Object): anychart.core.stock.eventMarkers.Group;
        position(): string;
        position(position?: string): anychart.core.stock.eventMarkers.Group;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.stock.eventMarkers.Group;
        selected(): anychart.core.stock.eventMarkers.Group;
        selected(settings?: Object): anychart.core.stock.eventMarkers.Group;
        seriesId(): string;
        seriesId(id: string): anychart.core.stock.eventMarkers.Group;
        stickToLeft(): boolean;
        stickToLeft(enabled?: boolean): anychart.core.stock.eventMarkers.Group;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        stroke(settings?: Object): anychart.core.stock.eventMarkers.Group;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: string | anychart.graphics.vector.Text.Direction): anychart.core.stock.eventMarkers.Group;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.stock.eventMarkers.Group;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.stock.eventMarkers.Group;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.stock.eventMarkers.Group;
        tooltip(): anychart.core.stock.eventMarkers.Group;
        tooltip(settings?: Object | boolean): anychart.core.stock.eventMarkers.Group;
        type(): string;
        type(type: string): anychart.core.stock.eventMarkers.Group;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.stock.eventMarkers.Group;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: string | anychart.graphics.vector.Text.VAlign): anychart.core.stock.eventMarkers.Group;
        width(): string | number;
        width(width?: string | number): anychart.core.stock.eventMarkers.Group;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.stock.eventMarkers.Group;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.stock.eventMarkers.Group;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.eventMarkers.Group;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.eventMarkers.Group;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.eventMarkers.Group;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.eventMarkers.Group;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Group {
    type DataFormat = {
        baseDate: number | Date;
        data: Array<number|Date|{date:number|Date}>;
        dateTimePattern: string;
        locale: string | anychart.format.Locale;
        timeOffset: number;
    }
    }
}

declare namespace anychart.core.stock.indicators {
    interface AO extends anychart.core.stock.indicators.Base {
        fastPeriod(): number;
        fastPeriod(period?: number): anychart.core.stock.indicators.AO;
        maType(): string;
        maType(type?: string): anychart.core.stock.indicators.AO;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.AO;
        slowPeriod(): number;
        slowPeriod(period?: number): anychart.core.stock.indicators.AO;
    }
    interface PriceChannels {
        middleSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        middleSeries(type?: string): anychart.core.stock.indicators.PriceChannels;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.PriceChannels;
        rangeSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        rangeSeries(type?: string): anychart.core.stock.indicators.PriceChannels;
    }
    interface Stochastic {
        dMAType(): string;
        dMAType(type?: string): anychart.core.stock.indicators.Stochastic;
        dPeriod(): number;
        dPeriod(period?: number): anychart.core.stock.indicators.Stochastic;
        dSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        dSeries(type?: string): anychart.core.stock.indicators.Stochastic;
        kMAPeriod(): number;
        kMAPeriod(period?: number): anychart.core.stock.indicators.Stochastic;
        kMAType(): string;
        kMAType(type?: string): anychart.core.stock.indicators.Stochastic;
        kPeriod(): number;
        kPeriod(period?: number): anychart.core.stock.indicators.Stochastic;
        kSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        kSeries(type?: string): anychart.core.stock.indicators.Stochastic;
    }
    interface PSY {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.PSY;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.PSY;
    }
    interface AMA {
        fastPeriod(): number;
        fastPeriod(period?: number): anychart.core.stock.indicators.AMA;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.AMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.AMA;
        slowPeriod(): number;
        slowPeriod(period?: number): anychart.core.stock.indicators.AMA;
    }
    interface RoC {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.RoC;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.RoC;
    }
    interface PPO {
        histogramSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        histogramSeries(type?: string): anychart.core.stock.indicators.PPO;
        longPeriod(): number;
        longPeriod(period?: number): anychart.core.stock.indicators.PPO;
        ppoSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        ppoSeries(type?: string): anychart.core.stock.indicators.PPO;
        shortPeriod(): number;
        shortPeriod(period?: number): anychart.core.stock.indicators.PPO;
        signalSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        signalSeries(type?: string): anychart.core.stock.indicators.PPO;
        smoothingPeriod(): number;
        smoothingPeriod(period?: number): anychart.core.stock.indicators.PPO;
    }
    interface HA extends anychart.core.stock.indicators.Base {
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.HA;
    }
    interface BBandsWidth {
        deviation(): number;
        deviation(deviation?: number): anychart.core.stock.indicators.BBandsWidth;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.BBandsWidth;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.BBandsWidth;
    }
    interface ENV {
        deviation(): number;
        deviation(deviation?: number): anychart.core.stock.indicators.ENV;
        lowerSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        lowerSeries(type?: string): anychart.core.stock.indicators.ENV;
        maType(): string;
        maType(maType?: string): anychart.core.stock.indicators.ENV;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.ENV;
        upperSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        upperSeries(type?: string): anychart.core.stock.indicators.ENV;
    }
    interface MACD {
        fastPeriod(): number;
        fastPeriod(period?: number): anychart.core.stock.indicators.MACD;
        histogramSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        histogramSeries(type?: string): anychart.core.stock.indicators.MACD;
        macdSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        macdSeries(type?: string): anychart.core.stock.indicators.MACD;
        signalPeriod(): number;
        signalPeriod(period?: number): anychart.core.stock.indicators.MACD;
        signalSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        signalSeries(type?: string): anychart.core.stock.indicators.MACD;
        slowPeriod(): number;
        slowPeriod(period?: number): anychart.core.stock.indicators.MACD;
    }
    interface PSAR {
        accelerationFactorIncrement(): number;
        accelerationFactorIncrement(factor?: number): anychart.core.stock.indicators.PSAR;
        accelerationFactorMaximum(): number;
        accelerationFactorMaximum(factor?: number): anychart.core.stock.indicators.PSAR;
        accelerationFactorStart(): number;
        accelerationFactorStart(factor?: number): anychart.core.stock.indicators.PSAR;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.PSAR;
    }
    interface KDJ {
        dMAType(): string;
        dMAType(type?: string): anychart.core.stock.indicators.KDJ;
        dMultiplier(): number;
        dMultiplier(multiplier?: number): anychart.core.stock.indicators.KDJ;
        dPeriod(): number;
        dPeriod(period?: number): anychart.core.stock.indicators.KDJ;
        dSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        dSeries(type?: string): anychart.core.stock.indicators.KDJ;
        jSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        jSeries(type?: string): anychart.core.stock.indicators.KDJ;
        kMAPeriod(): number;
        kMAPeriod(period?: number): anychart.core.stock.indicators.KDJ;
        kMAType(): string;
        kMAType(period?: string): anychart.core.stock.indicators.KDJ;
        kMultiplier(): number;
        kMultiplier(multiplier?: number): anychart.core.stock.indicators.KDJ;
        kPeriod(): number;
        kPeriod(period?: number): anychart.core.stock.indicators.KDJ;
        kSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        kSeries(type?: string): anychart.core.stock.indicators.KDJ;
    }
    interface BBandsB {
        deviation(): number;
        deviation(deviation?: number): number | anychart.core.stock.indicators.BBandsB;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.BBandsB;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.BBandsB;
    }
    interface Momentum {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.MFI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.MFI;
    }
    interface ATR {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.ATR;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.ATR;
    }
    interface Base {

    }
    interface KeltnerChannels {
        atrPeriod(): number;
        atrPeriod(period?: number): anychart.core.stock.indicators.KeltnerChannels;
        maPeriod(): number;
        maPeriod(period?: number): anychart.core.stock.indicators.KeltnerChannels;
        maSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        maSeries(type?: string): anychart.core.stock.indicators.KeltnerChannels;
        multiplier(): number;
        multiplier(multiplier?: number): anychart.core.stock.indicators.KeltnerChannels;
        rangeSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        rangeSeries(type?: string): anychart.core.stock.indicators.KeltnerChannels;
    }
    interface SMA {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.SMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.SMA;
    }
    interface WilliamsR {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.MFI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.WilliamsR;
    }
    interface CHO {
        fastPeriod(): number;
        fastPeriod(period?: number): anychart.core.stock.indicators.CHO;
        maType(): string;
        maType(type?: string): anychart.core.stock.indicators.CHO;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.CHO;
        slowPeriod(): number;
        slowPeriod(period?: number): anychart.core.stock.indicators.CHO;
    }
    interface OBV {
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.OBV;
    }
    interface Aroon {
        downSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        downSeries(type?: string): anychart.core.stock.indicators.Aroon;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.Aroon;
        rangeSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        rangeSeries(type?: string): anychart.core.stock.indicators.Aroon;
        upSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        upSeries(type?: string): anychart.core.stock.indicators.Aroon;
    }
    interface TRIX {
        maType(): string;
        maType(type?: string): anychart.core.stock.indicators.TRIX;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.TRIX;
        signalMaType(): string;
        signalMaType(type?: string): anychart.core.stock.indicators.TRIX;
        signalPeriod(): number;
        signalPeriod(period?: number): anychart.core.stock.indicators.TRIX;
        signalSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        signalSeries(type?: string): anychart.core.stock.indicators.TRIX;
        trixSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        trixSeries(type?: string): anychart.core.stock.indicators.TRIX;
    }
    interface RAT {
        baseDate(): any;
        baseDate(baseDate?: any): anychart.core.stock.indicators.RAT;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.RAT;
    }
    interface IKH {
        basePeriod(): number;
        basePeriod(period?: number): anychart.core.stock.indicators.IKH;
        baseSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        baseSeries(type?: string): anychart.core.stock.indicators.KDJ;
        conversionPeriod(): number;
        conversionPeriod(period?: number): anychart.core.stock.indicators.IKH;
        conversionSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        conversionSeries(type?: string): anychart.core.stock.indicators.IKH;
        laggingSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        laggingSeries(type?: string): anychart.core.stock.indicators.IKH;
        leadingPeriod(): number;
        leadingPeriod(period?: number): anychart.core.stock.indicators.IKH;
        leadingSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        leadingSeries(type?: string): anychart.core.stock.indicators.IKH;
    }
    interface VolumeMA {
        maPeriod(): number;
        maPeriod(period?: number): anychart.core.stock.indicators.VolumeMA;
        maSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        maSeries(type?: string): anychart.core.stock.indicators.Base;
        maType(): string;
        maType(type?: string): anychart.core.stock.indicators.VolumeMA;
        volumeSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        volumeSeries(type?: string): anychart.core.stock.indicators.VolumeMA;
    }
    interface RCI {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.RCI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.RCI;
    }
    interface RSI {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.RSI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.RSI;
    }
    interface CCI {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.CCI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.CCI;
    }
    interface MMA {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.MMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.MMA;
    }
    interface EMA {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.EMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.EMA;
    }
    interface ADL {
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.ADL;
    }
    interface MFI {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.MFI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.MFI;
    }
    interface CMF {
        period(): number;
        period(period?: number): anychart.core.stock.indicators.CMF;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.CMF;
    }
    interface VWAP {
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string): anychart.core.stock.indicators.VWAP;
    }
    interface DMI {
        adxPeriod(): number;
        adxPeriod(period?: number): anychart.core.stock.indicators.DMI;
        adxSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        adxSeries(type?: string): anychart.core.stock.indicators.DMI;
        ndiSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        ndiSeries(type?: string): anychart.core.stock.indicators.DMI;
        pdiSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        pdiSeries(type?: string): anychart.core.stock.indicators.DMI;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.DMI;
        useWildersSmoothing(): boolean;
        useWildersSmoothing(enabled?: boolean): anychart.core.stock.indicators.DMI;
    }
    interface BBands {
        deviation(): number;
        deviation(deviation?: number): anychart.core.stock.indicators.BBands;
        lowerSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        lowerSeries(type?: string): anychart.core.stock.indicators.BBands;
        middleSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        middleSeries(type?: string): anychart.core.stock.indicators.BBands;
        period(): number;
        period(period?: number): anychart.core.stock.indicators.BBands;
        rangeSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        rangeSeries(type?: string): anychart.core.stock.indicators.BBands;
        upperSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        upperSeries(type?: string): anychart.core.stock.indicators.BBands;
    }
}

declare namespace anychart.core.stock.scrollerSeries {
    interface SplineArea extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.SplineArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.SplineArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.SplineArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.SplineArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.SplineArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.SplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.SplineArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.SplineArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.SplineArea;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.SplineArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.SplineArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.SplineArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.SplineArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.SplineArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.SplineArea;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.SplineArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.SplineArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.SplineArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.SplineArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.SplineArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.SplineArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Spline extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Spline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Spline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Spline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Spline;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Spline;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Spline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Spline;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Spline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Spline;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Spline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Spline;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Spline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Spline;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Spline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Spline;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Spline;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Spline;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Spline;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Spline;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Spline;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.Spline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Spline;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Spline;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Spline;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Spline;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Spline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Spline;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Spline;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Spline;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Spline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Spline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Spline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Spline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DiscreteBase extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.DiscreteBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.DiscreteBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.DiscreteBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.DiscreteBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.DiscreteBase;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.DiscreteBase;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.DiscreteBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.DiscreteBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.DiscreteBase;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.DiscreteBase;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.DiscreteBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.DiscreteBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.DiscreteBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeStepArea extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeStepArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.RangeStepArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.RangeStepArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.RangeStepArea;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeStepArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeStepArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        highStroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeStepArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeStepArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        lowStroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeStepArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.RangeStepArea;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.stock.scrollerSeries.RangeStepArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeStepArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.RangeStepArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.RangeStepArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StepArea extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.StepArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.StepArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.StepArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.StepArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.StepArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.StepArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.StepArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.StepArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.StepArea;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.StepArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.StepArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.StepArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.StepArea;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.stock.scrollerSeries.StepArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.StepArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepArea;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.StepArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.StepArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.StepArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.StepArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.StepArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Base;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Base;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Base;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Base;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Base;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Base;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Base;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Base;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Area extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Area;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Area;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Area;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Area;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Area;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Area;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Area;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Area;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.Area;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Area;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.Area;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.Area;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.Area;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Area;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Area;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Area;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Area;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Area;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Area;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Area;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Area;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Area;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Area;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Area;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Area;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Area;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Area;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Area;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Area;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Area;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Area;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Area;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Area;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Area;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Area;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Area;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Area;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Area;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Stick extends anychart.core.stock.scrollerSeries.DiscreteBase {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Stick;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Stick;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Stick;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Stick;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Stick;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Stick;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Stick;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Stick;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Stick;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Stick;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Stick;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Stick;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Stick;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Stick;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Stick;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Stick;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Stick;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Stick;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Stick;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Stick;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Stick;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Stick;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Stick;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Stick;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Stick;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Stick;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Stick;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Stick;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Stick;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Stick;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Stick;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Stick;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OHLC extends anychart.core.stock.scrollerSeries.DiscreteBase {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.OHLC;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.OHLC;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.OHLC;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.OHLC;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        fallingStroke(settings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.OHLC;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.OHLC;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.OHLC;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        risingStroke(settings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.OHLC;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.OHLC;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.OHLC;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.OHLC;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.OHLC;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.OHLC;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.OHLC;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Candlestick extends anychart.core.stock.scrollerSeries.OHLC {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Candlestick;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Candlestick;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Candlestick;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(): anychart.graphics.vector.Fill | (() => void);
        fallingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(fallingHatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.Candlestick;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Candlestick;
        fallingStroke(settings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Candlestick;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Candlestick;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(risingHatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.Candlestick;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Candlestick;
        risingStroke(settings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Candlestick;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Candlestick;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Candlestick;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Candlestick;
        getIndex(): number;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Candlestick;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Candlestick;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Candlestick;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Column extends anychart.core.stock.scrollerSeries.DiscreteBase {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Column;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Column;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Column;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Column;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Column;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Column;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Column;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Column;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Column;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Column;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.Column;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.Column;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.Column;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Column;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Column;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Column;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Column;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Column;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Column;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Column;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Column;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Column;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Column;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Column;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Column;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Column;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Column;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Column;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Column;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Column;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Column;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Column;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Column;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Column;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Column;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Column;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Column;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeArea extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.RangeArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.RangeArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.RangeArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.RangeArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.RangeArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.RangeArea;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        highStroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        lowStroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.RangeArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.RangeArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.RangeArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.RangeArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.RangeArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.RangeArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface JumpLine extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.JumpLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.JumpLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.JumpLine;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.JumpLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.JumpLine;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.JumpLine;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.JumpLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.JumpLine;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.JumpLine;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.JumpLine;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.JumpLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.JumpLine;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.JumpLine;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.JumpLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.JumpLine;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.JumpLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.JumpLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.JumpLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.JumpLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StepLine extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.StepLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.StepLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.StepLine;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.StepLine;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.StepLine;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.StepLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.StepLine;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.StepLine;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.stock.scrollerSeries.StepLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.StepLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepLine;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.StepLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.StepLine;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.StepLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.StepLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.StepLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.StepLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Line;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Line;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Line;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Line;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Line;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Line;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Line;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Line;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Line;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Line;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Line;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Line;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Line;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Line;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColumn extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeColumn;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.RangeColumn;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.RangeColumn;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.RangeColumn;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.RangeColumn;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeColumn;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeColumn;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeColumn;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.RangeColumn;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeColumn;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.RangeColumn;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.RangeColumn;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.RangeColumn;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.RangeColumn;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeSplineArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.RangeSplineArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeSplineArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        highStroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeSplineArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        lowStroke(settings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.RangeSplineArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.RangeSplineArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.RangeSplineArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.RangeSplineArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Hilo extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Hilo;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Hilo;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Hilo;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Hilo;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Hilo;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Hilo;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Hilo;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Hilo;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Hilo;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Hilo;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Hilo;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Hilo;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Hilo;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Hilo;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Hilo;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Hilo;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Hilo;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Hilo;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Hilo;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.stock.scrollerSeries.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.scrollerSeries.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.scrollerSeries.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.scrollerSeries.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.scrollerSeries.Marker;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.scrollerSeries.Marker;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.scrollerSeries.Marker;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.scrollerSeries.Marker;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.scrollerSeries.Marker;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.scrollerSeries.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.scrollerSeries.Marker;
        hatchFill(enabled?: boolean): anychart.core.stock.scrollerSeries.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.scrollerSeries.Marker;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.scrollerSeries.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.scrollerSeries.Marker;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base | anychart.core.ui.LabelsFactory;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.scrollerSeries.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.scrollerSeries.Marker;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.scrollerSeries.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.scrollerSeries.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.scrollerSeries.Marker;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.scrollerSeries.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.scrollerSeries.Marker;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.stock.scrollerSeries.Marker;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.scrollerSeries.Marker;
        size(): number;
        size(size?: number): anychart.core.stock.scrollerSeries.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.scrollerSeries.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Marker;
        stroke(settings?: Object): anychart.core.stock.scrollerSeries.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.scrollerSeries.Marker;
        type(): string | (() => void);
        type(value?: string | (() => void)): anychart.core.stock.scrollerSeries.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.scrollerSeries.Marker;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.scrollerSeries.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.scrollerSeries.Marker;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Marker;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.scrollerSeries.Marker;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.scrollerSeries.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.scrollerSeries.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.scrollerSeries.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.scrollerSeries.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.stock.series {
    interface SplineArea extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.SplineArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.SplineArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.SplineArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.SplineArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.SplineArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.SplineArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.SplineArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.SplineArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.SplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.SplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.SplineArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.SplineArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.SplineArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.SplineArea;
        hatchFill(enabled?: boolean): anychart.core.stock.series.SplineArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.SplineArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.SplineArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.SplineArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.SplineArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.SplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.SplineArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.SplineArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.SplineArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.SplineArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.SplineArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.SplineArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.SplineArea;
        name(): string;
        name(name?: string): anychart.core.stock.series.SplineArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.SplineArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.SplineArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.SplineArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.SplineArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.SplineArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.SplineArea;
        stroke(settings?: Object): anychart.core.stock.series.SplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.SplineArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.SplineArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.SplineArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.SplineArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.SplineArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.SplineArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.SplineArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.SplineArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.SplineArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.SplineArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.SplineArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Spline extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Spline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Spline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Spline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Spline;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Spline;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Spline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Spline;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Spline;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Spline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Spline;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Spline;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Spline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Spline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Spline;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Spline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Spline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Spline;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Spline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Spline;
        name(): string;
        name(name?: string): anychart.core.stock.series.Spline;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Spline;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Spline;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Spline;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Spline;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.Spline;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Spline;
        stroke(settings?: Object): anychart.core.stock.series.Spline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Spline;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Spline;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Spline;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Spline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Spline;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Spline;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Spline;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Spline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Spline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Spline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Spline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DiscreteBase extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.DiscreteBase;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.DiscreteBase;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.DiscreteBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.DiscreteBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.DiscreteBase;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.DiscreteBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.DiscreteBase;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.DiscreteBase;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.DiscreteBase;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.DiscreteBase;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.DiscreteBase;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.DiscreteBase;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.DiscreteBase;
        name(): string;
        name(name?: string): anychart.core.stock.series.DiscreteBase;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.DiscreteBase;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.DiscreteBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.DiscreteBase;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.DiscreteBase;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.DiscreteBase;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.DiscreteBase;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.DiscreteBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.DiscreteBase;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.DiscreteBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.DiscreteBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.DiscreteBase;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.DiscreteBase;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.DiscreteBase;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.DiscreteBase;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.DiscreteBase;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.DiscreteBase;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.DiscreteBase;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.DiscreteBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.DiscreteBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.DiscreteBase;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.DiscreteBase;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeStepArea extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.RangeStepArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.RangeStepArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.RangeStepArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.RangeStepArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.RangeStepArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeStepArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.RangeStepArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.RangeStepArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeStepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeStepArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.RangeStepArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.RangeStepArea;
        hatchFill(enabled?: boolean): anychart.core.stock.series.RangeStepArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.RangeStepArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeStepArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.RangeStepArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.RangeStepArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.RangeStepArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.RangeStepArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeStepArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        lowStroke(settings?: Object): anychart.core.stock.series.RangeStepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.RangeStepArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.RangeStepArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.RangeStepArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.RangeStepArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.RangeStepArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.RangeStepArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.RangeStepArea;
        name(): string;
        name(name?: string): anychart.core.stock.series.RangeStepArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.RangeStepArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.RangeStepArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.RangeStepArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.RangeStepArea;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.stock.series.RangeStepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.RangeStepArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.RangeStepArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.RangeStepArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.RangeStepArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.RangeStepArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.RangeStepArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.RangeStepArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.RangeStepArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.RangeStepArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.RangeStepArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.RangeStepArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StepArea extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.StepArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.StepArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.StepArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.StepArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.StepArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.StepArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.StepArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.StepArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.StepArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.StepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.StepArea;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.StepArea;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.series.StepArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.StepArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.StepArea;
        hatchFill(enabled?: boolean): anychart.core.stock.series.StepArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.StepArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.StepArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.StepArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.StepArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.StepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.StepArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.StepArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.StepArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.StepArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.StepArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.StepArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.StepArea;
        name(): string;
        name(name?: string): anychart.core.stock.series.StepArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.StepArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.StepArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.StepArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.StepArea;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.stock.series.StepArea;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.StepArea;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepArea;
        stroke(settings?: Object): anychart.core.stock.series.StepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.StepArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.StepArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.StepArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.StepArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.StepArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.StepArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.StepArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.StepArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.StepArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.StepArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.StepArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Base;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Base;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Base;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Base;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Base;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Base;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Base;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Base;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Base;
        name(): string;
        name(name?: string): anychart.core.stock.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Base;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Base;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Base;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Area extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Area;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Area;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Area;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Area;
        color(): string;
        color(color: string): anychart.core.SeriesBase;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Area;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Area;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Area;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.Area;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.Area;
        fill(color: string, opacity?: number): anychart.core.stock.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Area;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Area;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.series.Area;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.Area;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.Area;
        hatchFill(enabled?: boolean): anychart.core.stock.series.Area;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Area;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Area;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Area;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Area;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Area;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Area;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Area;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Area;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Area;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Area;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Area;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Area;
        name(): string;
        name(name?: string): anychart.core.stock.series.Area;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Area;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Area;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Area;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Area;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.Area;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Area;
        stroke(settings?: Object): anychart.core.stock.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Area;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Area;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Area;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Area;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Area;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Area;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Area;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Area;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Area;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Area;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Area;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Stick extends anychart.core.stock.series.DiscreteBase {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Stick;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Stick;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Stick;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Stick;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Stick;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Stick;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Stick;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Stick;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Stick;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Stick;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Stick;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Stick;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Stick;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Stick;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Stick;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Stick;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Stick;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Stick;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Stick;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Stick;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Stick;
        name(): string;
        name(name?: string): anychart.core.stock.series.Stick;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Stick;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Stick;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Stick;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Stick;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Stick;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Stick;
        stroke(settings?: Object): anychart.core.stock.series.Stick;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Stick;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Stick;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Stick;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Stick;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Stick;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Stick;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Stick;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Stick;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OHLC extends anychart.core.stock.series.DiscreteBase {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.OHLC;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.OHLC;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.OHLC;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.OHLC;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.OHLC;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.OHLC;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.OHLC;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        fallingStroke(settings?: Object): anychart.core.stock.series.OHLC;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.OHLC;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.OHLC;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.OHLC;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.OHLC;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.OHLC;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.OHLC;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.OHLC;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.OHLC;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.OHLC;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.OHLC;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.OHLC;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.OHLC;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.OHLC;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.OHLC;
        name(): string;
        name(name?: string): anychart.core.stock.series.OHLC;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.OHLC;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.OHLC;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.OHLC;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.OHLC;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.OHLC;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        risingStroke(settings?: Object): anychart.core.stock.series.OHLC;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.OHLC;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.OHLC;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.OHLC;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.OHLC;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.OHLC;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.OHLC;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.OHLC;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.OHLC;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.OHLC;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Candlestick extends anychart.core.stock.series.OHLC {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Candlestick;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Candlestick;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Candlestick;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Candlestick;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Candlestick;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Candlestick;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Candlestick;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.Candlestick;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Candlestick;
        fallingHatchFill(fallingHatchFillFunction?: (() => void)): anychart.core.stock.series.Candlestick;
        fallingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.Candlestick;
        fallingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.Candlestick;
        fallingHatchFill(enabled?: boolean): anychart.core.stock.series.Candlestick;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Candlestick;
        fallingStroke(settings?: Object): anychart.core.stock.series.Candlestick;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Candlestick;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Candlestick;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Candlestick;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Candlestick;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Candlestick;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Candlestick;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Candlestick;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Candlestick;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Candlestick;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Candlestick;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Candlestick;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Candlestick;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Candlestick;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Candlestick;
        name(): string;
        name(name?: string): anychart.core.stock.series.Candlestick;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Candlestick;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Candlestick;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Candlestick;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Candlestick;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.Candlestick;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Candlestick;
        risingHatchFill(risingHatchFillFunction?: (() => void)): anychart.core.stock.series.Candlestick;
        risingHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.Candlestick;
        risingHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.Candlestick;
        risingHatchFill(enabled?: boolean): anychart.core.stock.series.Candlestick;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.Candlestick;
        risingStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Candlestick;
        risingStroke(settings?: Object): anychart.core.stock.series.Candlestick;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Candlestick;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Candlestick;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Candlestick;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Candlestick;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Candlestick;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Candlestick;
        getIndex(): number;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Candlestick;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Candlestick;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Candlestick;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Column extends anychart.core.stock.series.DiscreteBase {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Column;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Column;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Column;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Column;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Column;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Column;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Column;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.Column;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.Column;
        fill(color: string, opacity?: number): anychart.core.stock.series.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Column;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Column;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.series.Column;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.Column;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.Column;
        hatchFill(enabled?: boolean): anychart.core.stock.series.Column;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Column;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Column;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Column;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Column;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Column;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Column;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Column;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Column;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Column;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Column;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Column;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Column;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Column;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Column;
        name(): string;
        name(name?: string): anychart.core.stock.series.Column;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Column;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Column;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Column;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Column;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Column;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Column;
        stroke(settings?: Object): anychart.core.stock.series.Column;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Column;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Column;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Column;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Column;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Column;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Column;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Column;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeArea extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.RangeArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.RangeArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.RangeArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.RangeArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.RangeArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.RangeArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.RangeArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.RangeArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.RangeArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.RangeArea;
        hatchFill(enabled?: boolean): anychart.core.stock.series.RangeArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.RangeArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.RangeArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.RangeArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.RangeArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.RangeArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        lowStroke(settings?: Object): anychart.core.stock.series.RangeArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.RangeArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.RangeArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.RangeArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.RangeArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.RangeArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.RangeArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.RangeArea;
        name(): string;
        name(name?: string): anychart.core.stock.series.RangeArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.RangeArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.RangeArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.RangeArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.RangeArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.RangeArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.RangeArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.RangeArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.RangeArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.RangeArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.RangeArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.RangeArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.RangeArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.RangeArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.RangeArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.RangeArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface JumpLine extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.JumpLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.JumpLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.JumpLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.JumpLine;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.JumpLine;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.JumpLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.JumpLine;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.JumpLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.JumpLine;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.JumpLine;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.JumpLine;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.JumpLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.JumpLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.JumpLine;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.JumpLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.JumpLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.JumpLine;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.JumpLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.JumpLine;
        name(): string;
        name(name?: string): anychart.core.stock.series.JumpLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.JumpLine;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.JumpLine;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.JumpLine;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.JumpLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.JumpLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.JumpLine;
        stroke(settings?: Object): anychart.core.stock.series.JumpLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.JumpLine;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.JumpLine;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.JumpLine;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.JumpLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.JumpLine;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.JumpLine;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.JumpLine;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.JumpLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.JumpLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.JumpLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.JumpLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StepLine extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.StepLine;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.StepLine;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.StepLine;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.StepLine;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.StepLine;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.StepLine;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.StepLine;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.StepLine;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.StepLine;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.StepLine;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.StepLine;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.StepLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.StepLine;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.StepLine;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.StepLine;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.StepLine;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.StepLine;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.StepLine;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.StepLine;
        name(): string;
        name(name?: string): anychart.core.stock.series.StepLine;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.StepLine;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.StepLine;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.StepLine;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.StepLine;
        stepDirection(): string;
        stepDirection(direction?: string): anychart.core.stock.series.StepLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.StepLine;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepLine;
        stroke(settings?: Object): anychart.core.stock.series.StepLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.StepLine;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.StepLine;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.StepLine;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.StepLine;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.StepLine;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.StepLine;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.StepLine;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.StepLine;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.StepLine;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.StepLine;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.StepLine;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Line;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Line;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Line;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Line;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Line;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Line;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Line;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Line;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Line;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Line;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Line;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Line;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Line;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Line;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Line;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Line;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Line;
        name(): string;
        name(name?: string): anychart.core.stock.series.Line;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Line;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Line;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Line;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.Line;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Line;
        stroke(settings?: Object): anychart.core.stock.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Line;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Line;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Line;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Line;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Line;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Line;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColumn extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.RangeColumn;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.RangeColumn;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.RangeColumn;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.RangeColumn;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.RangeColumn;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeColumn;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.RangeColumn;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.RangeColumn;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeColumn;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.RangeColumn;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.RangeColumn;
        hatchFill(enabled?: boolean): anychart.core.stock.series.RangeColumn;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.RangeColumn;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.RangeColumn;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.RangeColumn;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.RangeColumn;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.RangeColumn;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.RangeColumn;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.RangeColumn;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.RangeColumn;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.RangeColumn;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.RangeColumn;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.RangeColumn;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.RangeColumn;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.RangeColumn;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.RangeColumn;
        name(): string;
        name(name?: string): anychart.core.stock.series.RangeColumn;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.RangeColumn;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.RangeColumn;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.RangeColumn;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.RangeColumn;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.RangeColumn;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeColumn;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeColumn;
        stroke(settings?: Object): anychart.core.stock.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.RangeColumn;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.RangeColumn;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.RangeColumn;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.RangeColumn;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.RangeColumn;
        getIndex(): number;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.RangeColumn;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.RangeColumn;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.RangeColumn;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeSplineArea extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.RangeSplineArea;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.RangeSplineArea;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.RangeSplineArea;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.RangeSplineArea;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.RangeSplineArea;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.RangeSplineArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.RangeSplineArea;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.RangeSplineArea;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.stock.series.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeSplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeSplineArea;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.RangeSplineArea;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.RangeSplineArea;
        hatchFill(enabled?: boolean): anychart.core.stock.series.RangeSplineArea;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.RangeSplineArea;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeSplineArea;
        highStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.RangeSplineArea;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.RangeSplineArea;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.RangeSplineArea;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.RangeSplineArea;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.RangeSplineArea;
        lowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        lowStroke(settings?: Object): anychart.core.stock.series.RangeSplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.RangeSplineArea;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.RangeSplineArea;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.RangeSplineArea;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.RangeSplineArea;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.RangeSplineArea;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.RangeSplineArea;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.RangeSplineArea;
        name(): string;
        name(name?: string): anychart.core.stock.series.RangeSplineArea;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.RangeSplineArea;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.RangeSplineArea;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.RangeSplineArea;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.RangeSplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.RangeSplineArea;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.RangeSplineArea;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.RangeSplineArea;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.RangeSplineArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.RangeSplineArea;
        getIndex(): number;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.RangeSplineArea;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.RangeSplineArea;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.RangeSplineArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.RangeSplineArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.RangeSplineArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.RangeSplineArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Hilo extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Hilo;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Hilo;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Hilo;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Hilo;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Hilo;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Hilo;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Hilo;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Hilo;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Hilo;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Hilo;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Hilo;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Hilo;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Hilo;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Hilo;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Hilo;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Hilo;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Hilo;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Hilo;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Hilo;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Hilo;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Hilo;
        name(): string;
        name(name?: string): anychart.core.stock.series.Hilo;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Hilo;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Hilo;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Hilo;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Hilo;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.Hilo;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Hilo;
        stroke(settings?: Object): anychart.core.stock.series.Hilo;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Hilo;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Hilo;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Hilo;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Hilo;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Hilo;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Hilo;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Hilo;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Hilo;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Hilo;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Marker extends anychart.core.stock.series.Base {
        allowPointSettings(): boolean;
        allowPointSettings(enabled?: boolean): anychart.core.stock.series.Marker;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.stock.series.Marker;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.stock.series.Marker;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.stock.series.Marker;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.stock.series.Marker;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop:string]:{column:number,type:string|string,weights:number}|number}, csvSettings?: Object): anychart.core.stock.series.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.series.Marker;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.stock.series.Marker;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Marker;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.stock.series.Marker;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.stock.series.Marker;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.stock.series.Marker;
        hatchFill(enabled?: boolean): anychart.core.stock.series.Marker;
        height(): number | string;
        height(height?: number | string): anychart.core.stock.series.Marker;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.stock.series.Marker;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.stock.series.Marker;
        left(): number | string;
        left(left?: number | string): anychart.core.stock.series.Marker;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(settings?: Object): anychart.core.stock.series.Marker;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.stock.series.Marker;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.stock.series.Marker;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.stock.series.Marker;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.stock.series.Marker;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.stock.series.Marker;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.stock.series.Marker;
        name(): string;
        name(name?: string): anychart.core.stock.series.Marker;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.stock.series.Marker;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.stock.series.Marker;
        right(): number | string;
        right(right?: number | string): anychart.core.stock.series.Marker;
        seriesType(): string;
        seriesType(type?: string): anychart.core.stock.series.Marker;
        size(): number;
        size(size?: number): anychart.core.stock.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.stock.series.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Marker;
        stroke(settings?: Object): anychart.core.stock.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.stock.series.Marker;
        top(): number | string;
        top(top?: number | string): anychart.core.stock.series.Marker;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.stock.series.Marker;
        width(): number | string;
        width(width?: number | string): anychart.core.stock.series.Marker;
        yScale(): anychart.scales.ScatterBase;
        yScale(settings?: anychart.scales.ScatterBase | Object | string): anychart.core.stock.series.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.stock.series.Marker;
        getIndex(): number;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.stock.series.Marker;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.stock.series.Marker;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.stock.series.Marker;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.stock.series.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.stock.series.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.stock.series.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.stock.series.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.stock.splitters {
    interface Settings extends anychart.core.Base {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.stock.splitters.Settings;
        hovered(): anychart.core.stock.splitters.Hovered;
        hovered(value: Object): anychart.core.stock.splitters.Settings;
        normal(): anychart.core.stock.splitters.Normal;
        normal(value: Object): anychart.core.stock.splitters.Settings;
        preview(): anychart.core.stock.splitters.Preview;
        preview(value: Object): anychart.core.stock.splitters.Settings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Normal extends anychart.core.Base {
        stroke(): anychart.graphics.vector.Stroke;
        stroke(stroke: anychart.graphics.vector.Stroke): anychart.core.stock.splitters.Normal;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Preview extends anychart.core.Base {
        fill(): anychart.graphics.vector.Fill;
        fill(fill: anychart.graphics.vector.Fill): anychart.core.stock.splitters.Preview;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Hovered extends anychart.core.Base {
        stroke(): anychart.graphics.vector.Stroke;
        stroke(stroke: anychart.graphics.vector.Stroke): anychart.core.stock.splitters.Hovered;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.sunburst {
    interface Level extends anychart.core.Base {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.sunburst.Level;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.sunburst.Level;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.sunburst.Level;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.sunburst.Level;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.sunburst.Level;
        thickness(): string | number;
        thickness(thickness?: string | number): anychart.core.sunburst.Level;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.surface {
}

declare namespace anychart.core.surface.markers {
    type Config = {
        data: Object;
        droplines: anychart.core.surface.markers.droplines.Config;
        enabled: boolean;
        fill: anychart.graphics.vector.Fill;
        size: number;
        stroke: anychart.graphics.vector.Stroke;
        type: string;
    }
    interface Controller extends anychart.core.Base {
        data(): anychart.data.View;
        data(data?: anychart.data.Set | Array<Array<number>> | string): anychart.core.surface.markers.Controller;
        droplines(): anychart.core.surface.markers.droplines.Controller;
        droplines(value: anychart.core.surface.markers.droplines.Config): anychart.core.surface.markers.Controller;
        enabled(): boolean;
        enabled(value: boolean): anychart.core.surface.markers.Controller;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.surface.markers.Controller;
        size(): number;
        size(value: number): anychart.core.surface.markers.Controller;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke): void;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value: object): anychart.core.surface.markers.Controller;
        type(value: string): anychart.core.surface.markers.Controller;
        type(): anychart.core.surface.markers.Controller;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.surface.markers.droplines {
    type Config = {
        enabled: boolean;
        stroke: anychart.graphics.vector.Stroke;
    }
    interface Controller extends anychart.core.Base {
        enabled(): boolean;
        enabled(value: boolean): anychart.core.surface.markers.Controller;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke): anychart.core.surface.markers.droplines.Controller;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.timeline {
}

declare namespace anychart.core.timeline.series {
    interface Moment extends anychart.core.timeline.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.timeline.series.Moment;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.timeline.series.Moment;
        direction(): string;
        direction(direction: string): anychart.core.timeline.series.Moment;
        getPoint(index: number): anychart.core.SeriesPoint;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.timeline.series.Moment;
        id(): string | number;
        id(id?: string | number): anychart.core.timeline.series.Moment;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.timeline.series.Moment;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.timeline.series.Moment;
        name(): string;
        name(value?: string): anychart.core.timeline.series.Moment;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.timeline.series.Moment;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.timeline.series.Moment;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.timeline.series.Moment;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.timeline.series.Moment;
        unselect(): anychart.core.timeline.series.Moment;
        unselect(index?: number): anychart.core.timeline.series.Moment;
        unselect(indexes?: Array<number>): anychart.core.timeline.series.Moment;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.timeline.series.Moment;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.timeline.series.Moment;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.timeline.series.Moment;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.timeline.series.Moment;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.timeline.series.Moment;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.timeline.series.Moment;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.timeline.series.Moment;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.timeline.series.Moment;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.timeline.series.Moment;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(left?: number | string): anychart.core.timeline.series.Moment;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.timeline.series.Moment;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.timeline.series.Moment;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.timeline.series.Moment;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.timeline.series.Moment;
        meta(key?: any): any;
        meta(object?: any): anychart.core.timeline.series.Moment;
        meta(key?: string, value?: any): anychart.core.timeline.series.Moment;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.timeline.series.Moment;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.timeline.series.Moment;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.timeline.series.Moment;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.timeline.series.Moment;
        right(): number | string;
        right(right?: number | string): anychart.core.timeline.series.Moment;
        select(index?: number): anychart.core.timeline.series.Moment;
        select(indexes?: Array<number>): anychart.core.timeline.series.Moment;
        seriesType(): string;
        seriesType(type?: string): anychart.core.timeline.series.Moment;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.timeline.series.Moment;
        top(): number | string;
        top(top?: number | string): anychart.core.timeline.series.Moment;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        width(): number | string;
        width(width?: number | string): anychart.core.timeline.series.Moment;
        xMode(): string;
        xMode(xMode?: string): anychart.core.timeline.series.Moment;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.timeline.series.Moment;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.timeline.series.Moment;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.timeline.series.Moment;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.timeline.series.Moment;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.timeline.series.Moment;
        hover(): anychart.core.timeline.series.Moment;
        hover(index?: number): anychart.core.timeline.series.Moment;
        hover(indexes?: Array<number>): anychart.core.timeline.series.Moment;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.timeline.series.Moment;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.timeline.series.Moment;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.timeline.series.Moment;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.cartesian.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.timeline.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.timeline.series.Base;
        direction(): string;
        direction(direction: string): anychart.core.timeline.series.Base;
        getPoint(index: number): anychart.core.SeriesPoint;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.timeline.series.Base;
        id(): string | number;
        id(id?: string | number): anychart.core.timeline.series.Base;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.timeline.series.Base;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.timeline.series.Base;
        name(): string;
        name(value?: string): anychart.core.timeline.series.Base;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.timeline.series.Base;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.timeline.series.Base;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.timeline.series.Base;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.timeline.series.Base;
        unselect(): anychart.core.timeline.series.Base;
        unselect(index?: number): anychart.core.timeline.series.Base;
        unselect(indexes?: Array<number>): anychart.core.timeline.series.Base;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.timeline.series.Base;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.timeline.series.Base;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.timeline.series.Base;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.timeline.series.Base;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.timeline.series.Base;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.timeline.series.Base;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.timeline.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getStat(key: string): any;
        height(): number | string;
        height(height?: number | string): anychart.core.timeline.series.Base;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.timeline.series.Base;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(left?: number | string): anychart.core.timeline.series.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.timeline.series.Base;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.timeline.series.Base;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.timeline.series.Base;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.timeline.series.Base;
        meta(key?: any): any;
        meta(object?: any): anychart.core.timeline.series.Base;
        meta(key?: string, value?: any): anychart.core.timeline.series.Base;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.timeline.series.Base;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.timeline.series.Base;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.timeline.series.Base;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.timeline.series.Base;
        right(): number | string;
        right(right?: number | string): anychart.core.timeline.series.Base;
        select(index?: number): anychart.core.timeline.series.Base;
        select(indexes?: Array<number>): anychart.core.timeline.series.Base;
        seriesType(): string;
        seriesType(type?: string): anychart.core.timeline.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.timeline.series.Base;
        top(): number | string;
        top(top?: number | string): anychart.core.timeline.series.Base;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        width(): number | string;
        width(width?: number | string): anychart.core.timeline.series.Base;
        xMode(): string;
        xMode(xMode?: string): anychart.core.timeline.series.Base;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.timeline.series.Base;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.timeline.series.Base;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.timeline.series.Base;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.timeline.series.Base;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.timeline.series.Base;
        hover(): anychart.core.timeline.series.Base;
        hover(index?: number): anychart.core.timeline.series.Base;
        hover(indexes?: Array<number>): anychart.core.timeline.series.Base;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.timeline.series.Base;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.timeline.series.Base;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.timeline.series.Base;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Range extends anychart.core.timeline.series.Base {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.timeline.series.Range;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.timeline.series.Range;
        direction(): string;
        direction(direction: string): anychart.core.timeline.series.Range;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value: number | string): anychart.core.timeline.series.Range;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.timeline.series.Range;
        id(): string | number;
        id(id?: string | number): anychart.core.timeline.series.Range;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.timeline.series.Range;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.timeline.series.Range;
        name(): string;
        name(value?: string): anychart.core.timeline.series.Range;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.timeline.series.Range;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.timeline.series.Range;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.timeline.series.Range;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.timeline.series.Range;
        unselect(): anychart.core.timeline.series.Range;
        unselect(index?: number): anychart.core.timeline.series.Range;
        unselect(indexes?: Array<number>): anychart.core.timeline.series.Range;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.timeline.series.Range;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.timeline.series.Range;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.timeline.series.Range;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.timeline.series.Range;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.timeline.series.Range;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.timeline.series.Range;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.timeline.series.Range;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getStat(key: string): any;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.timeline.series.Range;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(left?: number | string): anychart.core.timeline.series.Range;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.timeline.series.Range;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.timeline.series.Range;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.timeline.series.Range;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.timeline.series.Range;
        meta(key?: any): any;
        meta(object?: any): anychart.core.timeline.series.Range;
        meta(key?: string, value?: any): anychart.core.timeline.series.Range;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.timeline.series.Range;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.timeline.series.Range;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.timeline.series.Range;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.timeline.series.Range;
        right(): number | string;
        right(right?: number | string): anychart.core.timeline.series.Range;
        select(index?: number): anychart.core.timeline.series.Range;
        select(indexes?: Array<number>): anychart.core.timeline.series.Range;
        seriesType(): string;
        seriesType(type?: string): anychart.core.timeline.series.Range;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.timeline.series.Range;
        top(): number | string;
        top(top?: number | string): anychart.core.timeline.series.Range;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        width(): number | string;
        width(width?: number | string): anychart.core.timeline.series.Range;
        xMode(): string;
        xMode(xMode?: string): anychart.core.timeline.series.Range;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.timeline.series.Range;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.timeline.series.Range;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.timeline.series.Range;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.timeline.series.Range;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.timeline.series.Range;
        hover(): anychart.core.timeline.series.Range;
        hover(index?: number): anychart.core.timeline.series.Range;
        hover(indexes?: Array<number>): anychart.core.timeline.series.Range;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.timeline.series.Range;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.timeline.series.Range;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.timeline.series.Range;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.ui {
    interface Timeline extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineMilestones(): anychart.core.gantt.elements.BaselineMilestonesElement;
        baselineMilestones(settings?: Object): anychart.core.ui.Timeline;
        baselines(): anychart.core.gantt.elements.BaselinesElement;
        baselines(settings?: Object): anychart.core.ui.Timeline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.ui.Timeline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.ui.Timeline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Timeline;
        columnStroke(settings?: Object): anychart.core.ui.Timeline;
        connectors(): anychart.core.gantt.elements.ConnectorElement;
        connectors(settings?: Object): anychart.core.ui.Timeline;
        cropLabels(): boolean;
        cropLabels(value?: boolean): anychart.core.ui.Timeline;
        edit(): anychart.core.gantt.edit.StructureEdit;
        edit(settings?: Object | boolean): anychart.core.ui.Timeline;
        elements(): anychart.core.gantt.elements.TimelineElement;
        elements(settings?: Object): anychart.core.ui.Timeline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Timeline;
        getPixelBounds(): anychart.math.Rect;
        groupingTasks(): anychart.core.gantt.elements.GroupingTasksElement;
        groupingTasks(settings?: Object): anychart.core.ui.Timeline;
        header(): anychart.core.gantt.TimeLineHeader;
        header(value?: Object): anychart.core.ui.Timeline;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Timeline;
        holidaysFill(): anychart.graphics.vector.Fill;
        holidaysFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(value?: Object): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        left(): number | string;
        left(left?: number | string): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | string): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.Timeline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.ui.Timeline;
        milestones(): anychart.core.gantt.elements.MilestonesElement;
        milestones(settings?: Object): anychart.core.ui.Timeline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.Timeline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.ui.Timeline;
        notWorkingFill(): anychart.graphics.vector.Fill;
        notWorkingFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        periods(): anychart.core.gantt.elements.PeriodsElement;
        periods(settings?: Object): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | string): anychart.core.ui.Timeline;
        right(): number | string;
        right(right?: number | string): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: Object): anychart.core.ui.Timeline;
        tasks(): anychart.core.gantt.elements.TasksElement;
        tasks(settings?: Object): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | string): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
        top(): number | string;
        top(top?: number | string): anychart.core.ui.Timeline;
        verticalScrollBar(): anychart.core.ui.ScrollBar;
        verticalScrollBar(value?: Object): anychart.core.ui.Timeline;
        weekendsFill(): anychart.graphics.vector.Fill;
        weekendsFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Timeline;
        workingFill(): anychart.graphics.vector.Fill;
        workingFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Timeline;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(isEnabled?: boolean): anychart.core.ui.Timeline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Timeline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Timeline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Timeline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DataGrid extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.ui.DataGrid;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.ui.DataGrid;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.ui.DataGrid;
        buttons(): anychart.core.gantt.DataGridButton;
        buttons(settings?: Object): anychart.core.ui.DataGrid;
        column(index?: number): anychart.core.ui.DataGrid.Column;
        column(settings?: anychart.core.ui.DataGrid.Column | Object): anychart.core.ui.DataGrid;
        column(index?: number, settings?: anychart.core.ui.DataGrid.Column | Object): anychart.core.ui.DataGrid;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(color?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        columnStroke(settings?: Object): anychart.core.ui.DataGrid;
        data(): anychart.data.Tree;
        data(data?: anychart.data.Tree): anychart.core.ui.DataGrid;
        draw(): anychart.core.ui.DataGrid;
        edit(): anychart.core.gantt.edit.StructureEdit;
        edit(settings?: Object | boolean): anychart.core.ui.DataGrid;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.DataGrid;
        endIndex(): number;
        endIndex(index?: number): anychart.core.ui.DataGrid;
        fixedColumns(): boolean;
        fixedColumns(value?: boolean): anychart.core.ui.DataGrid;
        getPixelBounds(): anychart.math.Rect;
        getVisibleItems(): Array<anychart.data.Tree.DataItem>;
        headerFill(): anychart.graphics.vector.Fill | string;
        headerFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        headerFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        headerFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        headerFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        headerFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.DataGrid;
        horizontalOffset(): number;
        horizontalOffset(offset?: number): anychart.core.ui.DataGrid;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(settings?: Object): anychart.core.ui.DataGrid;
        left(): number | string;
        left(left?: number | string): anychart.core.ui.DataGrid;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.DataGrid;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.ui.DataGrid;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.DataGrid;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.ui.DataGrid;
        onEditEnd(): (()=>Object);
        onEditEnd(onEditEndFunction?: (()=>Object)): anychart.core.ui.DataGrid;
        onEditStart(): (()=>Object);
        onEditStart(onEditStartFunction?: (()=>Object)): anychart.core.ui.DataGrid;
        right(): number | string;
        right(right?: number | string): anychart.core.ui.DataGrid;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        rowFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowHoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.DataGrid;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        startIndex(): number;
        startIndex(index?: number): anychart.core.ui.DataGrid;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.ui.DataGrid;
        top(): number | string;
        top(top?: number | string): anychart.core.ui.DataGrid;
        verticalOffset(): number;
        verticalOffset(offset?: number): anychart.core.ui.DataGrid;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.DataGrid;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.DataGrid;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.DataGrid;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.DataGrid;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.DataGrid;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module DataGrid {
    interface Column extends anychart.core.VisualBase {
        collapseExpandButtons(): boolean;
        collapseExpandButtons(enabled?: boolean): anychart.core.ui.DataGrid.Column;
        defaultWidth(): number;
        defaultWidth(width?: number): anychart.core.ui.DataGrid.Column;
        depthPaddingMultiplier(): number;
        depthPaddingMultiplier(padding?: number): anychart.core.ui.DataGrid.Column;
        draw(): anychart.core.ui.DataGrid.Column;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.DataGrid.Column;
        labels(): anychart.core.ui.LabelsFactory;
        labelsOverrider(): ((label:anychart.core.ui.LabelsFactory.Label,item:anychart.data.Tree.DataItem)=>void);
        labelsOverrider(overriderFunction?: ((label:anychart.core.ui.LabelsFactory.Label,item:anychart.data.Tree.DataItem)=>void)): anychart.core.ui.DataGrid.Column;
        setColumnFormat(fieldName: string, presetValue: string): anychart.core.ui.DataGrid.Column;
        setColumnFormat(fieldName: string, settings: Object): anychart.core.ui.DataGrid.Column;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.ui.DataGrid.Column;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.DataGrid.Column;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.DataGrid.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.DataGrid.Column;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.DataGrid.Column;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.DataGrid.Column;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    }
    interface MarkersFactory extends anychart.core.VisualBase {
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.MarkersFactory;
        disablePointerEvents(value?: boolean): anychart.core.ui.MarkersFactory | boolean;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.MarkersFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.MarkersFactory;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.MarkersFactory;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.MarkersFactory;
        position(): string;
        position(position?: string): anychart.core.ui.MarkersFactory;
        positionFormatter(): (() => void);
        positionFormatter(formatter?: ((positionProvider:any,index:number)=>anychart.math.CoordinateObject)): anychart.core.ui.MarkersFactory;
        rotation(): number;
        rotation(rotation?: number): anychart.core.ui.MarkersFactory;
        size(): number;
        size(size?: number): anychart.core.ui.MarkersFactory;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.MarkersFactory;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory;
        stroke(settings?: Object): anychart.core.ui.MarkersFactory;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.ui.MarkersFactory;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.MarkersFactory;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.MarkersFactory;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.MarkersFactory;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.MarkersFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module MarkersFactory {
    interface Marker extends anychart.core.VisualBase {
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.MarkersFactory.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.MarkersFactory.Marker;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.MarkersFactory.Marker;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory.Marker;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.MarkersFactory.Marker;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.MarkersFactory.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.MarkersFactory.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.MarkersFactory.Marker;
        position(): string;
        position(position?: string): anychart.core.ui.MarkersFactory.Marker;
        positionFormatter(): any;
        positionFormatter(formatter?: any): any;
        rotation(): number;
        rotation(angle?: number): anychart.core.ui.MarkersFactory.Marker;
        size(): number;
        size(size?: number): anychart.core.ui.MarkersFactory.Marker;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.MarkersFactory.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory.Marker;
        stroke(settings?: Object): anychart.core.ui.MarkersFactory.Marker;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.core.ui.MarkersFactory.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.MarkersFactory.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.MarkersFactory.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    }
    interface Scroller extends anychart.core.VisualBase {
        allowRangeChange(): boolean;
        allowRangeChange(enabled?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(enabled?: boolean): anychart.core.ui.Scroller;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Scroller;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Scroller;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.core.ui.Scroller;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.Scroller;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        outlineStroke(settings?: Object): anychart.core.ui.Scroller;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(settings?: boolean | Object): anychart.core.ui.Scroller;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Scroller;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Scroller;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Scroller;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Scroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module Scroller {
    interface Thumbs {
        autoHide(): boolean;
        autoHide(enabled?: boolean): anychart.core.ui.Scroller.Thumbs;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Scroller.Thumbs;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Scroller.Thumbs;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller.Thumbs;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.ui.Scroller.Thumbs;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.ui.Scroller.Thumbs;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller.Thumbs;
        stroke(settings?: Object): anychart.core.ui.Scroller.Thumbs;
    }
    }
    interface ColorRange extends anychart.core.axes.Linear {
        align(): string;
        align(align?: string): anychart.core.ui.ColorRange;
        colorLineSize(): number;
        colorLineSize(size?: number): anychart.core.ui.ColorRange;
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.core.ui.ColorRange;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.core.ui.ColorRange;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.ColorRange;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.ui.ColorRange;
        length(): number | string;
        length(length?: string | number): anychart.core.ui.ColorRange;
        marker(): anychart.core.ui.MarkersFactory.Marker;
        marker(settings?: anychart.core.ui.MarkersFactory.Marker | Object): anychart.core.ui.ColorRange;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.core.ui.ColorRange;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.core.ui.ColorRange;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.ColorRange;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.core.ui.ColorRange;
        padding(): anychart.core.ui.table.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.ui.ColorRange;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.ColorRange;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.core.ui.ColorRange;
        staggerLines(): number;
        staggerLines(count?: number): anychart.core.ui.ColorRange;
        staggerMaxLines(): number;
        staggerMaxLines(count?: number): anychart.core.ui.ColorRange;
        staggerMode(): boolean;
        staggerMode(enabled?: boolean): anychart.core.ui.ColorRange;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.ColorRange;
        stroke(settings?: Object): anychart.core.ui.ColorRange;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.core.ui.ColorRange;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.ui.ColorRange;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.ColorRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.ColorRange;
        value(): number;
        value(value?: number): anychart.core.ui.ColorRange;
        valueTarget(): anychart.core.ui.ColorRange;
        valueTarget(target?: anychart.core.axes.Linear): anychart.core.ui.ColorRange;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.ColorRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.ColorRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.ColorRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Label extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.Label;
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.Label;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Label;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Label;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.Label;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Label;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.Label;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.Label;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.Label;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Label;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Label;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.Label;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Label;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Label;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.Label;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.Label;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.Label;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.Label;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.Label;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.Label;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.ui.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Label;
        position(): string;
        position(position?: string): anychart.core.ui.Label;
        rotation(): number;
        rotation(rotation?: number): anychart.core.ui.Label;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.Label;
        text(): string;
        text(text?: string): anychart.core.ui.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Label;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.Label;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Label;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.Label;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.Label;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.Label;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.Label;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Label;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Label;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.Label;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.Label;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Label;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Outline extends anychart.core.Base {
        enabled(): boolean;
        enabled(enabled: boolean): anychart.core.ui.Outline;
        fill(): anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill);
        fill(func?: anychart.graphics.vector.Fill | (()=>anychart.graphics.vector.Fill)): anychart.core.ui.Outline;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Outline;
        fill(color: string, opacity?: number): anychart.core.ui.Outline;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Outline;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Outline;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Outline;
        offset(): string | number;
        offset(offset?: string | number): anychart.core.ui.Outline;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        stroke(settings?: Object): anychart.core.ui.Outline;
        width(): string | number;
        width(width?: string | number): anychart.core.ui.Outline;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface CrosshairLabel extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.CrosshairLabel;
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.CrosshairLabel;
        axisIndex(): number;
        axisIndex(value?: number): anychart.core.ui.CrosshairLabel;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.CrosshairLabel;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.CrosshairLabel;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.CrosshairLabel;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.CrosshairLabel;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.CrosshairLabel;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.CrosshairLabel;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.CrosshairLabel;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.CrosshairLabel;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.CrosshairLabel;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.CrosshairLabel;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.CrosshairLabel;
        format(): (() => void);
        format(token?: string): anychart.core.ui.CrosshairLabel;
        format(func?: (() => void)): anychart.core.ui.CrosshairLabel;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.CrosshairLabel;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.CrosshairLabel;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.CrosshairLabel;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.CrosshairLabel;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.CrosshairLabel;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.CrosshairLabel;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.CrosshairLabel;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.CrosshairLabel;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.ui.CrosshairLabel;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.CrosshairLabel;
        position(): string;
        position(value?: string): anychart.core.ui.CrosshairLabel;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.CrosshairLabel;
        rotation(): number;
        rotation(angle?: number): anychart.core.ui.CrosshairLabel;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.CrosshairLabel;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.CrosshairLabel;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.CrosshairLabel;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.CrosshairLabel;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.CrosshairLabel;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.CrosshairLabel;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.CrosshairLabel;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.CrosshairLabel;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.CrosshairLabel;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.CrosshairLabel;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.CrosshairLabel;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.CrosshairLabel;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.CrosshairLabel;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.CrosshairLabel;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.CrosshairLabel;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.CrosshairLabel;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StageCredits {
        alt(): string;
        alt(text?: string): anychart.core.ui.StageCredits;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.StageCredits;
        imgAlt(): string;
        imgAlt(alt?: string): anychart.core.ui.StageCredits;
        logoSrc(): string;
        logoSrc(logoSrc?: string): anychart.core.ui.StageCredits;
        text(): string;
        text(text?: string): anychart.core.ui.StageCredits;
        url(): string;
        url(url?: string): anychart.core.ui.StageCredits;
    }
    interface Center extends anychart.core.Base {
        content(): anychart.graphics.vector.Element | anychart.core.VisualBase;
        content(contentSettings?: anychart.graphics.vector.Element | anychart.core.VisualBase | Object): anychart.core.ui.Center;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Center;
        fill(color: string, opacity?: number): anychart.core.ui.Center;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Center;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Center;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Center;
        getBounds(): anychart.math.Rect;
        getPoint(): anychart.math.CoordinateObject;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        stroke(settings?: Object): anychart.core.ui.Center;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Tooltip extends anychart.core.VisualBase {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.ui.Tooltip;
        allowLeaveChart(): boolean;
        allowLeaveChart(enabled?: boolean): anychart.core.ui.Tooltip;
        allowLeaveScreen(): boolean;
        allowLeaveScreen(enabled?: boolean): anychart.core.ui.Tooltip;
        allowLeaveStage(): boolean;
        allowLeaveStage(enabled?: boolean): anychart.core.ui.Tooltip;
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.Tooltip;
        background(): anychart.core.ui.Background;
        background(settings?: boolean | Object | string): anychart.core.ui.Tooltip;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Tooltip;
        displayMode(): string;
        displayMode(value?: string): anychart.core.ui.Tooltip;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Tooltip;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.Tooltip;
        fontDecoration(): anychart.graphics.vector.Text.Decoration;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Tooltip;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.Tooltip;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.Tooltip;
        fontSize(): number;
        fontSize(size?: number | string): anychart.core.ui.Tooltip;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(style?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.ui.Tooltip;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.ui.Tooltip;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.Tooltip;
        format(): (() => void) | string;
        format(format?: (() => void) | string): anychart.core.ui.Tooltip;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(align?: string | anychart.graphics.vector.Text.HAlign): anychart.core.ui.Tooltip;
        height(): string | number;
        height(height?: string | number): anychart.core.ui.Tooltip;
        hide(force?: boolean, event?: anychart.core.MouseEvent): boolean;
        hideDelay(): number;
        hideDelay(delay?: number): anychart.core.ui.Tooltip;
        letterSpacing(): number;
        letterSpacing(spacing?: number): anychart.core.ui.Tooltip;
        lineHeight(): number | string;
        lineHeight(height?: number | string): anychart.core.ui.Tooltip;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.Tooltip;
        maxLength(): number;
        maxLength(maxLength?: number): anychart.core.ui.Tooltip;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.Tooltip;
        offsetX(): number;
        offsetX(offset?: number): anychart.core.ui.Tooltip;
        offsetY(): number;
        offsetY(offset?: number): anychart.core.ui.Tooltip;
        onBeforeContentChange(): (()=>boolean);
        onBeforeContentChange(handler: (()=>boolean)): anychart.core.ui.Tooltip;
        onBeforeTitleChange(): (()=>boolean);
        onBeforeTitleChange(handler: (()=>boolean)): anychart.core.ui.Tooltip;
        onContentChanged(): (() => void);
        onContentChanged(handler: (() => void)): anychart.core.ui.Tooltip;
        onDomReady(): (() => void);
        onDomReady(handler: (() => void)): anychart.core.ui.Tooltip;
        onTitleChanged(): (() => void);
        onTitleChanged(handler: (() => void)): anychart.core.ui.Tooltip;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.ui.Tooltip;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Tooltip;
        position(): string;
        position(position?: string): anychart.core.ui.Tooltip;
        positionMode(): string;
        positionMode(mode?: string): anychart.core.ui.Tooltip;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.Tooltip;
        separator(): anychart.core.ui.Separator;
        separator(settings?: boolean | Object): anychart.core.ui.Tooltip;
        textDirection(): anychart.graphics.vector.Text.Direction;
        textDirection(value?: string | anychart.graphics.vector.Text.Direction): anychart.core.ui.Tooltip;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.Tooltip;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Tooltip;
        textSettings(): Object | string | number | boolean;
        textSettings(settings?: Object): anychart.core.ui.Tooltip;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.ui.Tooltip;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.Tooltip;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object): anychart.core.ui.Tooltip;
        titleFormat(): (() => void) | string;
        titleFormat(format?: (() => void) | string): anychart.core.ui.Tooltip;
        unionFormat(): (()=>string) | string;
        unionFormat(unionFormat?: (()=>string) | string): anychart.core.ui.Tooltip;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.Tooltip;
        vAlign(): anychart.graphics.vector.Text.VAlign;
        vAlign(align?: string | anychart.graphics.vector.Text.VAlign): anychart.core.ui.Tooltip;
        valuePostfix(): string;
        valuePostfix(value?: string): anychart.core.ui.Tooltip;
        valuePrefix(): string;
        valuePrefix(value?: string): anychart.core.ui.Tooltip;
        width(): string | number;
        width(width?: string | number): anychart.core.ui.Tooltip;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.Tooltip;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.Tooltip;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Tooltip;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Tooltip;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Tooltip;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Tooltip;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DataArea extends anychart.core.VisualBase {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.DataArea;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.DataArea;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.DataArea;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.DataArea;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.DataArea;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.DataArea;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Background extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.ui.Background;
        bottomStroke(): anychart.graphics.vector.Stroke;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.ui.Background;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.ui.Background;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.ui.Background;
        cornerType(): string;
        cornerType(type?: string): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(corners?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Background;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Background;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Background;
        left(): number | string;
        left(left?: number | string): anychart.core.ui.Background;
        leftStroke(): anychart.graphics.vector.Stroke;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.ui.Background;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.Background;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.ui.Background;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.Background;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.ui.Background;
        right(): number | string;
        right(right?: number | string): anychart.core.ui.Background;
        rightStroke(): anychart.graphics.vector.Stroke;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.ui.Background;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.ui.Background;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        top(): number | string;
        top(top?: number | string): anychart.core.ui.Background;
        topStroke(): anychart.graphics.vector.Stroke;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.ui.Background;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Background;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Background;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Background;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Background;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Background;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Legend extends anychart.core.Text {
        align(): string;
        align(align?: string): anychart.core.ui.Legend;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.Legend;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Legend;
        drag(): boolean;
        drag(enabled?: boolean): anychart.core.ui.Legend;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Legend;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.Legend;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Legend;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.Legend;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.Legend;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.Legend;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Legend;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Legend;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.Legend;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Legend;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Legend;
        hoverCursor(): string;
        hoverCursor(cursorTypr?: string): anychart.core.ui.Legend;
        iconSize(): number;
        iconSize(size?: number | string): anychart.core.ui.Legend;
        iconTextSpacing(): number;
        iconTextSpacing(spacing?: string | number): anychart.core.ui.Legend;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.core.ui.Legend;
        items(): Array<anychart.core.ui.Legend.LegendItemProvider>;
        items(itemsList?: Array<anychart.core.ui.Legend.LegendItemProvider>): anychart.core.ui.Legend;
        itemsFormat(): (() => void);
        itemsFormat(format?: ((value:Object)=>string) | string): anychart.core.ui.Legend;
        itemsFormatter(): ((items:Array<anychart.core.ui.Legend.LegendItemProvider>)=>Array<anychart.core.ui.Legend.LegendItemProvider>);
        itemsFormatter(formatterFunction?: ((items:Array<anychart.core.ui.Legend.LegendItemProvider>)=>Array<anychart.core.ui.Legend.LegendItemProvider>)): anychart.core.ui.Legend;
        itemsHAlign(): string;
        itemsHAlign(hAlign?: string): anychart.core.ui.Legend;
        itemsLayout(): string;
        itemsLayout(layout?: string): anychart.core.ui.Legend;
        itemsSourceMode(): string;
        itemsSourceMode(mode?: string): anychart.core.ui.Legend;
        itemsSpacing(): string | number;
        itemsSpacing(spacing?: string | number): anychart.core.ui.Legend;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.Legend;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.Legend;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object | number | string): anychart.core.ui.Legend;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.Legend;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.ui.Legend;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.core.ui.Legend;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        paginator(): anychart.core.ui.Paginator;
        paginator(settings?: Object | boolean): anychart.core.ui.Legend;
        position(): string;
        position(position?: string): anychart.core.ui.Legend;
        positionMode(): string;
        positionMode(mode?: string): anychart.core.ui.Legend;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.Legend;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Legend;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.Legend;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Legend;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.Legend;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.Legend;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.Legend;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.ui.Legend;
        titleFormat(): string | (() => void);
        titleFormat(format?: string | (() => void)): anychart.core.ui.Legend;
        titleSeparator(): anychart.core.ui.Separator;
        titleSeparator(settings?: Object | boolean): anychart.core.ui.Legend;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.ui.Legend;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.Legend;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Legend;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Legend;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.Legend;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.Legend;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Legend;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Legend;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Legend;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Legend;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Legend {
    type LegendItemProvider = {
        disabled?: boolean;
        iconEnabled?: boolean;
        iconFill?: anychart.graphics.vector.Fill;
        iconHatchFill?: anychart.graphics.vector.HatchFill.HatchFillType | anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill;
        iconMarkerFill?: anychart.graphics.vector.Fill;
        iconMarkerStroke?: anychart.graphics.vector.Stroke;
        iconMarkerType?: string;
        iconStroke?: anychart.graphics.vector.Stroke;
        iconTextSpacing?: number;
        iconType?: string;
        index?: number;
        meta?: Object;
        text?: string;
    }
    }
    interface Separator extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Separator;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string> | string): anychart.core.ui.Separator;
        fill(color: string, opacity?: number): anychart.core.ui.Separator;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Separator;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Separator;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Separator;
        getRemainingBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Separator;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.ui.Separator;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Separator;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.Separator;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Separator;
        stroke(settings?: Object): anychart.core.grids.Radar;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Separator;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Separator;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Separator;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Separator;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Separator;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Title extends anychart.core.Text {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.core.ui.Title;
        align(): string;
        align(align?: string): anychart.core.ui.Title;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.Title;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Title;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Title;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.Title;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Title;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.Title;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.Title;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.Title;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Title;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Title;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.Title;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Title;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Title;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.Title;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.Title;
        margin(): anychart.core.utils.Margin;
        margin(allValues?: string | number | Array<number|string> | Object): anychart.core.ui.Title;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.Title;
        maxLength(): number;
        maxLength(maxLength?: number): anychart.core.ui.Title;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.Title;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.Title;
        padding(): anychart.core.utils.Padding;
        padding(paddinge?: string | number | Array<number|string> | Object): anychart.core.ui.Title;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        rotation(): number;
        rotation(rotation?: number): anychart.core.ui.Title;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.Title;
        text(): string;
        text(text?: string): anychart.core.ui.Title;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Title;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.Title;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Title;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.Title;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.Title;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.Title;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.Title;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Title;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Title;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.Title;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.Title;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Title;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Title;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Title;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Title;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Paginator extends anychart.core.Text {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.Paginator;
        currentPage(): number;
        currentPage(pageNumber?: number | string): anychart.core.ui.Paginator;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Paginator;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Paginator;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.Paginator;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Paginator;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.Paginator;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.Paginator;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.Paginator;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Paginator;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Paginator;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.Paginator;
        getPagesCount(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Paginator;
        layout(): string;
        layout(value?: string): anychart.core.ui.Paginator;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.Paginator;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.Paginator;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.ui.Paginator;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Paginator;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.Paginator;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.core.ui.Paginator;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Paginator;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.Paginator;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Paginator;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.Paginator;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Paginator;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.Paginator;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.Paginator;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.Paginator;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Paginator;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.Paginator;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.Paginator;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Paginator;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.Paginator;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Paginator;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Paginator;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Paginator;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ChartScroller extends anychart.core.ui.Scroller {
        allowRangeChange(): boolean;
        allowRangeChange(enabled?: boolean): anychart.core.ui.ChartScroller;
        autoHide(): boolean;
        autoHide(enabled?: boolean): anychart.core.ui.ChartScroller;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.ChartScroller;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.ChartScroller;
        fill(color: string, opacity?: number): anychart.core.ui.ChartScroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.ChartScroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.ChartScroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.ChartScroller;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.ChartScroller;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.core.ui.ChartScroller;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.ChartScroller;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.ChartScroller;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.ChartScroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.ChartScroller;
        outlineStroke(settings?: Object): anychart.core.ui.ChartScroller;
        position(): string;
        position(position?: string): anychart.core.ui.ChartScroller;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.ChartScroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.ChartScroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.ChartScroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.ChartScroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.ChartScroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(settings?: boolean | Object): anychart.core.ui.ChartScroller;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.ChartScroller;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.ChartScroller;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.ChartScroller;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.ChartScroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ScrollBar extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.ScrollBar;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.ScrollBar;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.ScrollBar;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.ScrollBar;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.ScrollBar;
        backgroundStroke(): anychart.graphics.vector.Stroke | string;
        backgroundStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.ScrollBar;
        barSize(): number;
        barSize(size?: number): anychart.core.ui.ScrollBar;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.ui.ScrollBar;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.ui.ScrollBar;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.ui.ScrollBar;
        buttonsVisible(): boolean;
        buttonsVisible(enabled?: boolean): boolean | anychart.core.ui.ScrollBar;
        cornersRadius(): number;
        cornersRadius(radius?: number): anychart.core.ui.ScrollBar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.ScrollBar;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.ScrollBar;
        left(): number | string;
        left(left?: number | string): anychart.core.ui.ScrollBar;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.ScrollBar;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.ui.ScrollBar;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.ScrollBar;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.ui.ScrollBar;
        mouseOutOpacity(): number;
        mouseOutOpacity(opacity?: number): anychart.core.ui.ScrollBar;
        mouseOverOpacity(): number;
        mouseOverOpacity(opacity?: number): anychart.core.ui.ScrollBar;
        right(): number | string;
        right(right?: number | string): anychart.core.ui.ScrollBar;
        sliderFill(): anychart.graphics.vector.Fill | string;
        sliderFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.ScrollBar;
        sliderFill(color: string, opacity?: number): anychart.core.ui.ScrollBar;
        sliderFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.ScrollBar;
        sliderFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.ScrollBar;
        sliderFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.ScrollBar;
        sliderStroke(): anychart.graphics.vector.Stroke | string;
        sliderStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.ScrollBar;
        top(): number | string;
        top(top?: number | string): anychart.core.ui.ScrollBar;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.ScrollBar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.ScrollBar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.ScrollBar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.ScrollBar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.ScrollBar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface CircularLabelsFactory extends anychart.core.ui.LabelsFactory {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.CircularLabelsFactory;
        adjustFontSize(settings?: Object | Array<boolean> | boolean): anychart.core.ui.CircularLabelsFactory;
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.CircularLabelsFactory;
        autoRotate(): boolean;
        autoRotate(enabled?: boolean): anychart.core.ui.CircularLabelsFactory;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.CircularLabelsFactory;
        clip(): anychart.graphics.vector.Shape | string | anychart.graphics.vector.Clip | anychart.math.Rect;
        clip(clipSettings?: anychart.graphics.vector.Shape | string | anychart.graphics.vector.Clip | anychart.math.Rect): anychart.core.ui.CircularLabelsFactory;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.CircularLabelsFactory;
        connectorStroke(settings?: Object): anychart.core.ui.CircularLabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.CircularLabelsFactory;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.CircularLabelsFactory;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.CircularLabelsFactory;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.CircularLabelsFactory;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.CircularLabelsFactory;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.CircularLabelsFactory;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.CircularLabelsFactory;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.CircularLabelsFactory;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.CircularLabelsFactory;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.CircularLabelsFactory;
        format(): (() => void) | string;
        format(token?: string): anychart.core.ui.CircularLabelsFactory;
        format(func?: (() => void)): anychart.core.ui.CircularLabelsFactory;
        getLabel(index: number): anychart.core.ui.LabelsFactory.Label;
        getLabelsCount(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.CircularLabelsFactory;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.CircularLabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.CircularLabelsFactory;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.CircularLabelsFactory;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.CircularLabelsFactory;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.CircularLabelsFactory;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.CircularLabelsFactory;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.CircularLabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.core.ui.CircularLabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.CircularLabelsFactory;
        position(): string;
        position(position?: string): anychart.core.ui.CircularLabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(formatter?: (() => void)): anychart.core.ui.CircularLabelsFactory;
        rotation(): number;
        rotation(angle?: number): anychart.core.ui.CircularLabelsFactory;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.CircularLabelsFactory;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.CircularLabelsFactory;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.CircularLabelsFactory;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.CircularLabelsFactory;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.CircularLabelsFactory;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.CircularLabelsFactory;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.CircularLabelsFactory;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.CircularLabelsFactory;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.CircularLabelsFactory;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.CircularLabelsFactory;
        maxLength(): number;
        maxLength(maxLength?: number): anychart.core.ui.CircularLabelsFactory;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.CircularLabelsFactory;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.CircularLabelsFactory;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.CircularLabelsFactory;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.CircularLabelsFactory;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.CircularLabelsFactory;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.CircularLabelsFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module CircularLabelsFactory {
    interface Label extends anychart.core.ui.LabelsFactory.Label {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.CircularLabelsFactory.Label;
        anchor(): string;
        anchor(anchor?: string): string;
        autoRotate(): boolean;
        autoRotate(enabled?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.CircularLabelsFactory.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.CircularLabelsFactory.Label;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.CircularLabelsFactory.Label;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.CircularLabelsFactory.Label;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.CircularLabelsFactory.Label;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.CircularLabelsFactory.Label;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.CircularLabelsFactory.Label;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.CircularLabelsFactory.Label;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.CircularLabelsFactory.Label;
        getIndex(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.CircularLabelsFactory.Label;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.CircularLabelsFactory.Label;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.CircularLabelsFactory.Label;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.CircularLabelsFactory.Label;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.CircularLabelsFactory.Label;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.CircularLabelsFactory.Label;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.CircularLabelsFactory.Label;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.CircularLabelsFactory.Label;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.core.ui.CircularLabelsFactory.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.CircularLabelsFactory.Label;
        position(): string;
        position(position?: string): anychart.core.ui.CircularLabelsFactory.Label;
        positionFormatter(): any;
        positionFormatter(formatter?: any): any;
        rotation(): number;
        rotation(angle?: number): anychart.core.ui.CircularLabelsFactory.Label;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.CircularLabelsFactory.Label;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.CircularLabelsFactory.Label;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.CircularLabelsFactory.Label;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.CircularLabelsFactory.Label;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.CircularLabelsFactory.Label;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.CircularLabelsFactory.Label;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.CircularLabelsFactory.Label;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.CircularLabelsFactory.Label;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.CircularLabelsFactory.Label;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.CircularLabelsFactory.Label;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.CircularLabelsFactory.Label;
        draw(): anychart.core.ui.CircularLabelsFactory.Label;
        format(): any;
        format(value?: any): any;
        measureWithText(text: string): anychart.math.Rect;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.CircularLabelsFactory.Label;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.CircularLabelsFactory.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.CircularLabelsFactory.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.CircularLabelsFactory.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    }
    interface Crosshair extends anychart.core.VisualBase {
        displayMode(): string;
        displayMode(mode?: string): anychart.core.ui.Crosshair;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Crosshair;
        xLabel(index?: number): anychart.core.ui.CrosshairLabel;
        xLabel(settings?: Object | boolean): anychart.core.ui.Crosshair;
        xLabel(index?: number, settings?: Object | boolean): anychart.core.ui.Crosshair;
        xStroke(): anychart.graphics.vector.Stroke;
        xStroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Crosshair;
        yLabel(index?: number): anychart.core.ui.CrosshairLabel;
        yLabel(settings?: Object | boolean): anychart.core.ui.Crosshair;
        yLabel(index?: number, settings?: Object | boolean): anychart.core.ui.Crosshair;
        yStroke(): anychart.graphics.vector.Stroke;
        yStroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Crosshair;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Crosshair;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Crosshair;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Crosshair;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Crosshair;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Table extends anychart.core.VisualBaseWithBounds {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.ui.Table;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.ui.Table;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.ui.Table;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(colorSettings?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Table;
        cellFill(color: string, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(padding?: Array<number|string> | Object): anychart.core.ui.Table;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Table;
        colsCount(): number;
        colsCount(count?: number): anychart.core.ui.Table;
        colsMaxWidth(): string | number;
        colsMaxWidth(width?: string | number): anychart.core.ui.Table;
        colsMinWidth(): string | number;
        colsMinWidth(width?: string | number): anychart.core.ui.Table;
        colsWidth(): string | number;
        colsWidth(width?: string | number): anychart.core.ui.Table;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Table;
        contents(): Array<Array<anychart.core.VisualBase>>;
        contents(tableValues?: Array<Array<anychart.core.VisualBase|string|number>>, demergeCells?: boolean): anychart.core.ui.Table;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.core.ui.Table;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.Table;
        dispose(): void;
        draw(): anychart.core.ui.Table;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Table;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.core.ui.Table;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.Table;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Table;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.Table;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.Table;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.Table;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Table;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Table;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.Table;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.core.ui.Table;
        getCell(row: number, col: number): anychart.core.ui.table.Cell;
        getCol(col: number): anychart.core.ui.table.Column;
        getJpgBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getRow(row: number): anychart.core.ui.table.Row;
        getSvgBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Table;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.Table;
        isFullScreenAvailable(): boolean;
        left(): number | string;
        left(left?: number | string): anychart.core.ui.Table;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.Table;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.Table;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.ui.Table;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.ui.Table;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.ui.Table;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.ui.Table;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Table;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Table;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.core.ui.Table;
        rowEvenFill(): anychart.graphics.vector.Fill;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Table;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(): anychart.graphics.vector.Fill;
        rowOddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.Table;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowsCount(): number;
        rowsCount(count?: number): anychart.core.ui.Table;
        rowsHeight(): string | number;
        rowsHeight(height?: string | number): anychart.core.ui.Table;
        rowsMaxHeight(): string | number;
        rowsMaxHeight(height?: string | number): anychart.core.ui.Table;
        rowsMinHeight(): string | number;
        rowsMinHeight(height?: string | number): anychart.core.ui.Table;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(filename?: string): void;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.Table;
        shareAsJpg(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Table;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.Table;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Table;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.Table;
        toCsv(csvSettings?: {[prop:string]:string|boolean}): string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        top(): number | string;
        top(top?: number | string): anychart.core.ui.Table;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.Table;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Table;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Table;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.Table;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.Table;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Table;
    }
    interface LegendItem extends anychart.core.Text {
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.LegendItem;
        draw(): anychart.core.ui.LegendItem;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.LegendItem;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.LegendItem;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.LegendItem;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.LegendItem;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.LegendItem;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.LegendItem;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.LegendItem;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.LegendItem;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.LegendItem;
        getContentBounds(): anychart.math.Rect;
        getHeight(): number;
        getTextElement(): anychart.graphics.vector.Text;
        getWidth(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.LegendItem;
        iconFill(value?: anychart.graphics.vector.Fill): anychart.graphics.vector.Fill | anychart.core.ui.LegendItem;
        iconHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        iconHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.ui.LegendItem;
        iconStroke(value?: anychart.graphics.vector.Stroke): anychart.graphics.vector.Stroke | anychart.core.ui.LegendItem;
        iconTextSpacing(value?: number): anychart.core.ui.LegendItem | number;
        iconType(value?: string | (() => void)): string | (() => void) | anychart.core.ui.LegendItem;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.LegendItem;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.LegendItem;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.LegendItem;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.ui.LegendItem;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.LegendItem;
        text(value?: string): string | anychart.core.ui.LegendItem;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.LegendItem;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.LegendItem;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.LegendItem;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.LegendItem;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.LegendItem;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.LegendItem;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.LegendItem;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.LegendItem;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.LegendItem;
        x(value?: number | string): number | string | anychart.core.ui.LegendItem;
        y(value?: number | string): number | string | anychart.core.ui.LegendItem;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.LegendItem;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.LegendItem;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.LegendItem;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.LegendItem;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.LegendItem;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Callout extends anychart.core.VisualBase {
        align(): string;
        align(align?: string): anychart.core.ui.Callout;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.Callout;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.Callout;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.ui.Callout;
        items(): Array<string>;
        items(itemsList?: Array<string>): anychart.core.ui.Callout;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.ui.Callout;
        length(): number | string;
        length(length?: string | number): anychart.core.ui.Callout;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.ui.Callout;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Callout;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.ui.Callout;
        orientation(): string;
        orientation(orientation?: string): anychart.core.ui.Callout;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.ui.Callout;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Callout;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.ui.Callout;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.ui.Callout;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.Callout;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.Callout;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.Callout;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.Callout;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.Callout;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface LabelsFactory extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(settings?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): string;
        anchor(anchor?: string): anychart.core.ui.LabelsFactory;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        clip(): anychart.graphics.vector.Shape | string | anychart.graphics.vector.Clip | anychart.math.Rect;
        clip(clipSettings?: anychart.graphics.vector.Shape | string | anychart.graphics.vector.Clip | anychart.math.Rect): anychart.core.ui.LabelsFactory;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.LabelsFactory;
        connectorStroke(settings?: Object): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.LabelsFactory;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.LabelsFactory;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.LabelsFactory;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.LabelsFactory;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.LabelsFactory;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.LabelsFactory;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.LabelsFactory;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.LabelsFactory;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.LabelsFactory;
        format(): (() => void) | string;
        format(token?: string): anychart.core.ui.LabelsFactory;
        format(func?: (() => void)): anychart.core.ui.LabelsFactory;
        getLabel(index: number): anychart.core.ui.LabelsFactory.Label;
        getLabelsCount(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.LabelsFactory;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.LabelsFactory;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.LabelsFactory;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.LabelsFactory;
        maxLength(): number;
        maxLength(maxLength?: number): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(position?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(formatter?: (() => void)): anychart.core.ui.LabelsFactory;
        rotation(): number;
        rotation(angle?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.LabelsFactory;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.LabelsFactory;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.LabelsFactory;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.LabelsFactory;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.LabelsFactory;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.LabelsFactory;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.LabelsFactory;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.LabelsFactory;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.LabelsFactory;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.LabelsFactory;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.LabelsFactory;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.LabelsFactory;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.LabelsFactory;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.LabelsFactory;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.LabelsFactory;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.LabelsFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module LabelsFactory {
    interface Label extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory.Label;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory.Label;
        anchor(): string;
        anchor(anchor?: string): string;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.core.ui.LabelsFactory.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.LabelsFactory.Label;
        draw(): anychart.core.ui.LabelsFactory.Label;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.LabelsFactory.Label;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.LabelsFactory.Label;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.LabelsFactory.Label;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.LabelsFactory.Label;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.LabelsFactory.Label;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.LabelsFactory.Label;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.LabelsFactory.Label;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.LabelsFactory.Label;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.LabelsFactory.Label;
        format(): any;
        format(value?: any): any;
        getIndex(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.LabelsFactory.Label;
        height(): number | string;
        height(height?: number | string): anychart.core.ui.LabelsFactory.Label;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.LabelsFactory.Label;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.LabelsFactory.Label;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.core.ui.LabelsFactory.Label;
        measureWithText(text: string): anychart.math.Rect;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.core.ui.LabelsFactory.Label;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.core.ui.LabelsFactory.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory.Label;
        position(): string;
        position(position?: string): anychart.core.ui.LabelsFactory.Label;
        positionFormatter(): any;
        positionFormatter(formatter?: any): any;
        rotation(): number;
        rotation(angle?: number): anychart.core.ui.LabelsFactory.Label;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.LabelsFactory.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.LabelsFactory.Label;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.LabelsFactory.Label;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.LabelsFactory.Label;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.ui.LabelsFactory.Label;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.ui.LabelsFactory.Label;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.LabelsFactory.Label;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.LabelsFactory.Label;
        width(): number | string;
        width(width?: number | string): anychart.core.ui.LabelsFactory.Label;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.LabelsFactory.Label;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.LabelsFactory.Label;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.ui.LabelsFactory.Label;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.LabelsFactory.Label;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.ui.LabelsFactory.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.ui.LabelsFactory.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.ui.LabelsFactory.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    }
    interface ChartCredits extends anychart.core.Base {
        alt(): string;
        alt(text?: string): anychart.core.ui.ChartCredits;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.ui.ChartCredits;
        imgAlt(): string;
        imgAlt(text?: string): anychart.core.ui.ChartCredits;
        logoSrc(): string;
        logoSrc(logoSrc?: string): anychart.core.ui.ChartCredits;
        text(): string;
        text(text?: string): anychart.core.ui.ChartCredits;
        url(): string;
        url(url?: string): anychart.core.ui.ChartCredits;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.ui.table {
    interface Border {
        bottom(): anychart.graphics.vector.Stroke;
        bottom(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        left(): anychart.graphics.vector.Stroke;
        left(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        right(): anychart.graphics.vector.Stroke;
        right(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        top(): anychart.graphics.vector.Stroke;
        top(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
    }
    interface Cell extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Cell;
        colSpan(): number;
        colSpan(count?: number): anychart.core.ui.table.Cell;
        content(): anychart.graphics.vector.Element | anychart.core.VisualBase | string | number;
        content(settings?: anychart.graphics.vector.Element | anychart.core.VisualBase | string | number): anychart.core.ui.table.Cell;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.table.Cell;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.table.Cell;
        fill(color: string, opacity?: number): anychart.core.ui.table.Cell;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Cell;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Cell;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Cell;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.table.Cell;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Cell;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.table.Cell;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.table.Cell;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.table.Cell;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Cell;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Cell;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.table.Cell;
        getBounds(): anychart.math.Rect;
        getCol(): anychart.core.ui.table.Column;
        getColNum(): number;
        getRow(): anychart.core.ui.table.Row;
        getRowNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Cell;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.table.Cell;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.table.Cell;
        padding(): anychart.core.ui.table.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.ui.table.Cell;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Cell;
        rowSpan(): number;
        rowSpan(count?: number): anychart.core.ui.table.Cell;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.table.Cell;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Cell;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.table.Cell;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Cell;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.table.Cell;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.table.Cell;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Cell;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.table.Cell;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.table.Cell;
    }
    interface Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.table.Base;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.table.Base;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.table.Base;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.table.Base;
    }
    interface Row extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Row;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Row;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.table.Row;
        cellFill(color: string, opacity?: number): anychart.core.ui.table.Row;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Row;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Row;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Row;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(padding?: Array<number|string> | Object): anychart.core.ui.table.Row;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Row;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.table.Row;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.table.Row;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Row;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.table.Row;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.table.Row;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.table.Row;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Row;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Row;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.table.Row;
        getCell(col: number): anychart.core.ui.table.Cell;
        getRowNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Row;
        height(): string | number;
        height(height?: string | number): anychart.core.ui.table.Row;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.table.Row;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.table.Row;
        maxHeight(): string | number;
        maxHeight(height?: string | number): anychart.core.ui.table.Row;
        minHeight(): string | number;
        minHeight(height?: string | number): anychart.core.ui.table.Row;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.table.Row;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Row;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.table.Row;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Row;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.table.Row;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Row;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.table.Row;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.table.Row;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.table.Row;
    }
    interface Column extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Column;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Column;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.ui.table.Column;
        cellFill(color: string, opacity?: number): anychart.core.ui.table.Column;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Column;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Column;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Column;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(padding?: Array<number|string> | Object): anychart.core.ui.table.Column;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Column;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.ui.table.Column;
        fontColor(): string;
        fontColor(color?: string): anychart.core.ui.table.Column;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(type?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Column;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.ui.table.Column;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.ui.table.Column;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.ui.table.Column;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Column;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(type?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Column;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.ui.table.Column;
        getCell(row: number): anychart.core.ui.table.Cell;
        getColNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Column;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.ui.table.Column;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.ui.table.Column;
        maxWidth(): string | number;
        maxWidth(width?: string | number): anychart.core.ui.table.Column;
        minWidth(): string | number;
        minWidth(width?: string | number): anychart.core.ui.table.Column;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.ui.table.Column;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(type?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Column;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.ui.table.Column;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Column;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.ui.table.Column;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Column;
        width(): string | number;
        width(width?: string | number): anychart.core.ui.table.Column;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.ui.table.Column;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.ui.table.Column;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.ui.table.Column;
    }
    interface Padding {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.ui.table.Padding;
        left(): number | string;
        left(left?: number | string): anychart.core.ui.table.Padding;
        right(): number | string;
        right(right?: number | string): anychart.core.ui.table.Padding;
        top(): number | string;
        top(top?: number | string): anychart.core.ui.table.Padding;
    }
}

declare namespace anychart.core.utils {
    interface LegendItemSettings extends anychart.core.Text {
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.utils.LegendItemSettings;
        disabled(): boolean;
        disabled(enabled?: boolean): anychart.core.utils.LegendItemSettings;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.utils.LegendItemSettings;
        fontColor(): string;
        fontColor(color?: string): anychart.core.utils.LegendItemSettings;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.utils.LegendItemSettings;
        fontFamily(): string;
        fontFamily(family?: string): anychart.core.utils.LegendItemSettings;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.core.utils.LegendItemSettings;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.core.utils.LegendItemSettings;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.utils.LegendItemSettings;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.utils.LegendItemSettings;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.core.utils.LegendItemSettings;
        format(): string;
        format(format: string | (() => void)): anychart.core.utils.LegendItemSettings;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.core.utils.LegendItemSettings;
        iconEnabled(): boolean;
        iconEnabled(enabled?: boolean): anychart.core.utils.LegendItemSettings;
        iconFill(): anychart.graphics.vector.Fill | (() => void);
        iconFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.utils.LegendItemSettings;
        iconFill(color: string, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.LegendItemSettings;
        iconHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        iconHatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.utils.LegendItemSettings;
        iconHatchFill(iconHatchFillFunction?: (() => void)): anychart.core.utils.LegendItemSettings;
        iconHatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.utils.LegendItemSettings;
        iconHatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(): anychart.graphics.vector.Fill | string;
        iconMarkerFill(color: anychart.graphics.vector.Fill): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(color: string, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.utils.LegendItemSettings;
        iconMarkerStroke(): anychart.graphics.vector.Stroke | string;
        iconMarkerStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.LegendItemSettings;
        iconMarkerType(): string | (() => void);
        iconMarkerType(type?: string | (() => void)): anychart.core.utils.LegendItemSettings;
        iconSize(): number;
        iconSize(size?: number | string): anychart.core.utils.LegendItemSettings;
        iconStroke(): (() => void) | anychart.graphics.vector.Stroke;
        iconStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.utils.LegendItemSettings;
        iconStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.LegendItemSettings;
        iconStroke(settings?: Object): anychart.core.utils.LegendItemSettings;
        iconTextSpacing(): number;
        iconTextSpacing(spacing?: number): anychart.core.utils.LegendItemSettings;
        iconType(): string | (() => void);
        iconType(type?: string | ((path:anychart.graphics.vector.Path,size:number)=>void)): anychart.core.utils.LegendItemSettings;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.core.utils.LegendItemSettings;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.core.utils.LegendItemSettings;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.core.utils.LegendItemSettings;
        text(): string;
        text(text?: string | (() => void)): anychart.core.utils.LegendItemSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.core.utils.LegendItemSettings;
        textIndent(): number;
        textIndent(indent?: number): anychart.core.utils.LegendItemSettings;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.utils.LegendItemSettings;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.utils.LegendItemSettings;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.core.utils.LegendItemSettings;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.core.utils.LegendItemSettings;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.core.utils.LegendItemSettings;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.core.utils.LegendItemSettings;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.core.utils.LegendItemSettings;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.utils.LegendItemSettings;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.core.utils.LegendItemSettings;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.utils.LegendItemSettings;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.utils.LegendItemSettings;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.utils.LegendItemSettings;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface UnboundRegionsSettings {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.utils.UnboundRegionsSettings;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.utils.UnboundRegionsSettings;
        fill(color: string, opacity?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.utils.UnboundRegionsSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.UnboundRegionsSettings;
        stroke(settings?: Object): anychart.core.utils.UnboundRegionsSettings;
    }
    interface StockInteractivity extends anychart.core.utils.Interactivity {
        allowPlotDrag(): boolean;
        allowPlotDrag(enabled?: boolean): anychart.core.utils.StockInteractivity;
        multiSelectOnClick(): boolean;
        multiSelectOnClick(enabled?: boolean): anychart.core.utils.StockInteractivity;
        scrollOnMouseWheel(): boolean;
        scrollOnMouseWheel(enabled?: boolean): anychart.core.utils.StockInteractivity;
        unselectOnClickOutOfPoint(): boolean;
        unselectOnClickOutOfPoint(enabled?: boolean): anychart.core.utils.StockInteractivity;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(enabled?: boolean): anychart.core.utils.StockInteractivity;
        allowMultiSeriesSelection(value?: boolean): anychart.core.utils.StockInteractivity | boolean;
        hoverMode(): string;
        hoverMode(mode?: string): anychart.core.utils.StockInteractivity;
        selectionMode(): string;
        selectionMode(mode?: string): anychart.core.utils.StockInteractivity;
        spotRadius(): number;
        spotRadius(radius?: number): anychart.core.utils.StockInteractivity;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Exports {
        clientside(): anychart.exports.ClientsideConfiguration;
        clientside(configuration: anychart.exports.ClientsideConfiguration): anychart.core.utils.Exports;
        facebook(): Object;
        facebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string, width?: string, height?: string, appId?: string): Object;
        filename(name?: string): string;
        image(): Object;
        image(widthOrOptions?: string | Object, height?: string): Object;
        linkedin(): Object;
        linkedin(captionOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
        pinterest(): Object;
        pinterest(linkOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
        twitter(): Object;
        twitter(urlOrOptions?: string | Object, width?: string, height?: string): Object;
    }
    interface Margin extends anychart.core.Base {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.utils.Margin;
        left(): number | string;
        left(left?: number | string): anychart.core.utils.Margin;
        right(): number | string;
        right(right?: number | string): anychart.core.utils.Margin;
        set(value1?: string | number | Array<number|string> | Object, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Margin;
        top(): number | string;
        top(top?: number | string): anychart.core.utils.Margin;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MapInteractivity extends anychart.core.utils.Interactivity {
        allowMultiSeriesSelection(value?: boolean): anychart.core.utils.MapInteractivity | boolean;
        copyFormat(): (() => void);
        copyFormat(formatFunction?: (() => void)): anychart.core.utils.MapInteractivity;
        drag(): boolean;
        drag(enabled?: boolean): anychart.core.utils.MapInteractivity;
        hoverMode(): string;
        hoverMode(mode?: string): anychart.core.utils.MapInteractivity;
        keyboardZoomAndMove(): boolean;
        keyboardZoomAndMove(enabled?: boolean): anychart.core.utils.MapInteractivity;
        mouseWheel(): boolean;
        mouseWheel(value?: boolean): anychart.core.utils.MapInteractivity;
        multiSelectOnClick(): boolean;
        multiSelectOnClick(enabled?: boolean): anychart.core.utils.MapInteractivity;
        selectionMode(): string;
        selectionMode(mode?: string): anychart.core.utils.MapInteractivity;
        spotRadius(): number;
        spotRadius(radius?: number): anychart.core.utils.MapInteractivity;
        unselectOnClickOutOfPoint(): boolean;
        unselectOnClickOutOfPoint(enabled?: boolean): anychart.core.utils.MapInteractivity;
        zoomOnDoubleClick(): boolean;
        zoomOnDoubleClick(enabled?: boolean): anychart.core.utils.MapInteractivity;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(enabled?: boolean): anychart.core.utils.MapInteractivity;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Error extends anychart.core.Base {
        mode(): string;
        mode(mode?: string): anychart.core.utils.Error;
        valueError(): string | number;
        valueError(valueError?: string | number): anychart.core.utils.Error;
        valueErrorStroke(): anychart.graphics.vector.Stroke;
        valueErrorStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.utils.Error;
        valueErrorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Error;
        valueErrorWidth(): number;
        valueErrorWidth(width?: number): anychart.core.utils.Error;
        valueLowerError(): string | number;
        valueLowerError(valueLowerError?: string | number): anychart.core.utils.Error;
        valueUpperError(): string | number;
        valueUpperError(valueUpperError?: string | number): anychart.core.utils.Error;
        xError(): string | number;
        xError(xError?: string | number): anychart.core.utils.Error;
        xErrorStroke(): anychart.graphics.vector.Stroke;
        xErrorStroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.utils.Error;
        xErrorStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Error;
        xErrorWidth(): number;
        xErrorWidth(width?: number): anychart.core.utils.Error;
        xLowerError(): string | number;
        xLowerError(xLowerError?: string | number): anychart.core.utils.Error;
        xUpperError(): string | number;
        xUpperError(xUpperError?: string | number): anychart.core.utils.Error;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface QuarterSettings extends anychart.core.Base {
        leftBottom(): anychart.core.utils.Quarter;
        leftBottom(settings?: Object): anychart.core.utils.QuarterSettings;
        leftTop(): anychart.core.utils.Quarter;
        leftTop(settings?: Object): anychart.core.utils.QuarterSettings;
        rightBottom(): anychart.core.utils.Quarter;
        rightBottom(settings?: Object): anychart.core.utils.QuarterSettings;
        rightTop(): anychart.core.utils.Quarter;
        rightTop(settings?: Object): anychart.core.utils.QuarterSettings;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DrawingPlanIterator extends anychart.data.Iterator {
        advance(): boolean;
        get(fieldName: string): any;
        getIndex(): number;
        getRowsCount(): number;
        meta(name: string): any;
        meta(name: string, value?: any): anychart.core.utils.DrawingPlanIterator;
        reset(): anychart.core.utils.DrawingPlanIterator;
        select(index: number): boolean;
    }
    interface Interactivity extends anychart.core.Base {
        allowMultiSeriesSelection(value?: boolean): anychart.core.utils.Interactivity | boolean;
        hoverMode(): string;
        hoverMode(mode?: string): anychart.core.utils.Interactivity;
        multiSelectOnClick(): boolean;
        multiSelectOnClick(enabled?: boolean): anychart.core.utils.Interactivity;
        selectionMode(): string;
        selectionMode(mode?: string): anychart.core.utils.Interactivity;
        spotRadius(): number;
        spotRadius(radius?: number): anychart.core.utils.Interactivity;
        unselectOnClickOutOfPoint(): boolean;
        unselectOnClickOutOfPoint(enabled?: boolean): anychart.core.utils.Interactivity;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface A11y extends anychart.core.Base {
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ChartA11y extends anychart.core.utils.A11y {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.utils.ChartA11y;
        mode(): string;
        mode(mode?: string): anychart.core.utils.ChartA11y;
        titleFormat(): (() => void) | string;
        titleFormat(formatSettings?: (() => void) | string): anychart.core.utils.ChartA11y;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeriesA11y extends anychart.core.utils.A11y {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.utils.SeriesA11y;
        titleFormat(): (() => void) | string;
        titleFormat(formatSettings?: (() => void) | string): anychart.core.utils.SeriesA11y;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Quarter extends anychart.core.ui.Background {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.utils.Quarter;
        bottomStroke(): anychart.graphics.vector.Stroke;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.utils.Quarter;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Quarter;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.utils.Quarter;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.utils.Quarter;
        cornerType(): string;
        cornerType(type?: string): anychart.core.utils.Quarter;
        corners(): Array<number>;
        corners(corners?: number | string | Array<number>): anychart.core.utils.Quarter;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.utils.Quarter;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.core.utils.Quarter;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.utils.Quarter;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.utils.Quarter;
        fill(color: string, opacity?: number): anychart.core.utils.Quarter;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.Quarter;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.Quarter;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.core.utils.Quarter;
        label(index?: string | number): anychart.core.ui.Label;
        label(settings?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, settings?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(left?: number | string): anychart.core.utils.Quarter;
        leftStroke(): anychart.graphics.vector.Stroke;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.utils.Quarter;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Quarter;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object): anychart.core.utils.Quarter;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Quarter;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.utils.Quarter;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.utils.Quarter;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.utils.Quarter;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.utils.Quarter;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        right(): number | string;
        right(right?: number | string): anychart.core.utils.Quarter;
        rightStroke(): anychart.graphics.vector.Stroke;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.utils.Quarter;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Quarter;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.utils.Quarter;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Quarter;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.core.utils.Quarter;
        top(): number | string;
        top(top?: number | string): anychart.core.utils.Quarter;
        topStroke(): anychart.graphics.vector.Stroke;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.core.utils.Quarter;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Quarter;
        width(): number | string;
        width(width?: number | string): anychart.core.utils.Quarter;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.utils.Quarter;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.utils.Quarter;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.utils.Quarter;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.utils.Quarter;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Crossing extends anychart.core.Base {
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Crossing;
        stroke(settings?: Object): anychart.core.utils.Crossing;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OrdinalZoom {
        continuous(): boolean;
        continuous(enabled?: boolean): anychart.core.utils.OrdinalZoom;
        getEndRatio(): number;
        getStartRatio(): number;
        setTo(startRatio: number, endRatio: number): anychart.core.utils.OrdinalZoom;
        setToPointsCount(pointsCount: number, fromEnd?: boolean, scale?: anychart.scales.Base): anychart.core.utils.OrdinalZoom;
        setToValues(startValue: any, endValue: any, scale?: anychart.scales.Base): anychart.core.utils.OrdinalZoom;
    }
    interface Animation extends anychart.core.Base {
        duration(): number;
        duration(duration: number): anychart.core.utils.Animation;
        enabled(): boolean;
        enabled(enabled: boolean): anychart.core.utils.Animation;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Connector extends anychart.core.Base {
        length(): string;
        length(length?: number | string): anychart.core.utils.Connector;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.map.series.Base;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Connector;
        stroke(settings?: Object): anychart.core.utils.Connector;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Padding extends anychart.core.Base {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.utils.Padding;
        left(): number | string;
        left(left?: number | string): anychart.core.utils.Padding;
        right(): number | string;
        right(right?: number | string): anychart.core.utils.Padding;
        set(value1?: string | number | Array<number|string> | Object, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Padding;
        top(): number | string;
        top(top?: number | string): anychart.core.utils.Padding;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bounds extends anychart.core.Base {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.utils.Bounds;
        height(): number | string;
        height(height?: number | string): anychart.core.utils.Bounds;
        left(): number | string;
        left(left?: number | string): anychart.core.utils.Bounds;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.utils.Bounds;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.utils.Bounds;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.utils.Bounds;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.utils.Bounds;
        right(): number | string;
        right(right?: number | string): anychart.core.utils.Bounds;
        set(xOrRect?: number | string | Array<number> | anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds, y?: number | string, width?: number | string, height?: number | string): anychart.core.utils.Bounds;
        toRect(parentLeftOrRect?: number | anychart.math.Rect | Object, parentTop?: number, parentWidth?: number, parentHeight?: number): anychart.math.Rect;
        top(): number | string;
        top(top?: number | string): anychart.core.utils.Bounds;
        width(): number | string;
        width(width?: number | string): anychart.core.utils.Bounds;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.venn {
    interface Intersections extends anychart.core.Base {
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.venn.Intersections;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.venn.Intersections;
        fill(color: string, opacity?: number): anychart.core.venn.Intersections;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.venn.Intersections;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.venn.Intersections;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.venn.Intersections;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.venn.Intersections;
        hatchFill(hatchFillFunction?: (() => void)): anychart.core.venn.Intersections;
        hatchFill(patternFill?: anychart.graphics.vector.PatternFill): anychart.core.venn.Intersections;
        hatchFill(settings?: anychart.graphics.vector.HatchFill): anychart.core.venn.Intersections;
        hatchFill(enabled?: boolean): anychart.core.venn.Intersections;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.venn.Intersections;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.venn.Intersections;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.venn.Intersections;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.venn.Intersections;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.venn.Intersections;
        stroke(): anychart.graphics.vector.Stroke | (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill);
        stroke(strokeFunction?: (()=>anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill)): anychart.core.venn.Intersections;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.venn.Intersections;
        stroke(settings?: Object): anychart.core.venn.Intersections;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.core.venn.Intersections;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.waterfall {
    type TotalConfig = {
        fill: string;
        hatchFill: string;
        label: Object | string;
        name: string;
        stroke: string;
        x: string;
    }
    type SplitConfig = {
        fill: string;
        label: Object | string;
        name: string;
        stroke: string;
        value: number;
    }
    interface Total {
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.core.waterfall.Total;
        hatchFill(): anychart.graphics.vector.HatchFill;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType | string): anychart.core.waterfall.Total;
        label(): anychart.core.ui.LabelsFactory;
        label(config: Object): anychart.core.waterfall.Total;
        label(enabled: boolean): anychart.core.waterfall.Total;
        name(): string;
        name(value: string): anychart.core.waterfall.Total;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings?: anychart.graphics.vector.Stroke): anychart.core.waterfall.Total;
        x(): string;
        x(value: string): anychart.core.waterfall.Total;
    }
    interface ArrowConnector {
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.waterfall.ArrowConnector;
        stroke(settings?: Object): anychart.core.waterfall.ArrowConnector;
    }
    interface Connectors {
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings: Object): anychart.core.waterfall.Connectors;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.waterfall.Connectors;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings?: Object): anychart.core.waterfall.Connectors;
    }
    interface Arrow {
        connector(settings?: Object): anychart.core.waterfall.Arrow;
        connector(): anychart.core.waterfall.ArrowConnector;
        from(value: string): anychart.core.waterfall.Arrow;
        from(): string;
        label(): anychart.core.ui.LabelsFactory;
        label(settings: Object): anychart.core.waterfall.Arrow;
        to(value: string): anychart.core.waterfall.Arrow;
        to(): string;
    }
}

declare namespace anychart.core.waterfall.series {
    interface Waterfall extends anychart.core.cartesian.series.WidthBased {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.waterfall.series.Waterfall;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.core.waterfall.series.Waterfall;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.waterfall.series.Waterfall;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.waterfall.series.Waterfall;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.waterfall.series.Waterfall;
        color(): string;
        color(value: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(settings?: anychart.scales.LinearColor | anychart.scales.OrdinalColor | Object | string): anychart.core.waterfall.series.Waterfall;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.core.waterfall.series.Waterfall;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.core.waterfall.series.Waterfall;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.waterfall.series.Waterfall;
        fallingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.waterfall.series.Waterfall;
        fallingFill(color: string, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fallingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.waterfall.series.Waterfall;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.waterfall.series.Waterfall;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.waterfall.series.Waterfall;
        fill(color: string, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.waterfall.series.Waterfall;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.waterfall.series.Waterfall;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        getExcludedPoints(): Array<anychart.core.Point>;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string): any;
        getType(): string;
        height(): number | string;
        height(height?: number | string): anychart.core.waterfall.series.Waterfall;
        hover(): anychart.core.waterfall.series.Waterfall;
        hover(index?: number): anychart.core.waterfall.series.Waterfall;
        hover(indexes?: Array<number>): anychart.core.waterfall.series.Waterfall;
        hovered(): anychart.core.StateSettings;
        hovered(settings?: Object): anychart.core.waterfall.series.Waterfall;
        id(): string | number;
        id(id?: string | number): anychart.core.waterfall.series.Waterfall;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        isVertical(): boolean;
        isVertical(enabled?: boolean): anychart.core.waterfall.series.Waterfall;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.core.waterfall.series.Waterfall;
        left(): number | string;
        left(left?: number | string): anychart.core.waterfall.series.Waterfall;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.waterfall.series.Waterfall;
        markers(): anychart.core.ui.MarkersFactory;
        markers(settings?: Object | boolean | string): anychart.core.waterfall.series.Waterfall;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.core.waterfall.series.Waterfall;
        maxLabels(): anychart.core.ui.LabelsFactory;
        maxLabels(settings?: Object | boolean): anychart.core.waterfall.series.Waterfall;
        maxPointWidth(): string | number;
        maxPointWidth(width?: number | string): anychart.core.waterfall.series.Waterfall;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.core.waterfall.series.Waterfall;
        meta(key?: any): any;
        meta(object?: any): anychart.core.waterfall.series.Waterfall;
        meta(key?: string, value?: any): anychart.core.waterfall.series.Waterfall;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.core.waterfall.series.Waterfall;
        minLabels(): anychart.core.ui.LabelsFactory;
        minLabels(settings?: Object | boolean): anychart.core.waterfall.series.Waterfall;
        minPointLength(): string | number;
        minPointLength(length?: number | string): anychart.core.waterfall.series.Waterfall;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.core.waterfall.series.Waterfall;
        name(): string;
        name(value?: string): anychart.core.waterfall.series.Waterfall;
        normal(): anychart.core.StateSettings;
        normal(settings?: Object): anychart.core.waterfall.series.Waterfall;
        pointWidth(): string | number;
        pointWidth(width?: number | string): anychart.core.waterfall.series.Waterfall;
        rendering(): anychart.core.series.RenderingSettings;
        rendering(settings?: Object | (() => void)): anychart.core.waterfall.series.Waterfall;
        right(): number | string;
        right(right?: number | string): anychart.core.waterfall.series.Waterfall;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.core.waterfall.series.Waterfall;
        risingFill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.waterfall.series.Waterfall;
        risingFill(color: string, opacity?: number): anychart.core.waterfall.series.Waterfall;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.waterfall.series.Waterfall;
        risingFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.waterfall.series.Waterfall;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.waterfall.series.Waterfall;
        select(index?: number): anychart.core.waterfall.series.Waterfall;
        select(indexes?: Array<number>): anychart.core.waterfall.series.Waterfall;
        selected(): anychart.core.StateSettings;
        selected(settings?: Object): anychart.core.waterfall.series.Waterfall;
        selectionMode(): string;
        selectionMode(value?: string): anychart.core.waterfall.series.Waterfall;
        seriesType(): string;
        seriesType(type?: string): anychart.core.waterfall.series.Waterfall;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.waterfall.series.Waterfall;
        top(): number | string;
        top(top?: number | string): anychart.core.waterfall.series.Waterfall;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.waterfall.series.Waterfall;
        unselect(): anychart.core.waterfall.series.Waterfall;
        unselect(index?: number): anychart.core.waterfall.series.Waterfall;
        unselect(indexes?: Array<number>): anychart.core.waterfall.series.Waterfall;
        width(): number | string;
        width(width?: number | string): anychart.core.waterfall.series.Waterfall;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.waterfall.series.Waterfall;
        xScale(): anychart.scales.Ordinal;
        xScale(settings?: anychart.scales.Base | Object | string): anychart.core.waterfall.series.Waterfall;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | Object | string): anychart.core.waterfall.series.Waterfall;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.core.waterfall.series.Waterfall;
        error(): anychart.core.utils.Error;
        error(settings?: Object | boolean | string | number): anychart.core.waterfall.series.Waterfall;
        xMode(): string;
        xMode(xMode?: string): anychart.core.waterfall.series.Waterfall;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.waterfall.series.Waterfall;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.core.waterfall.series.Waterfall;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.core.waterfall.series.Waterfall;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.wordtree {
    interface Connectors extends anychart.core.Base {
        curveFactor(): number;
        curveFactor(padding?: number): anychart.core.wordtree.Connectors;
        length(): string;
        length(length?: number | string): anychart.core.wordtree.Connectors;
        offset(): number;
        offset(offset?: number): anychart.core.wordtree.Connectors;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.core.wordtree.Connectors;
        stroke(settings?: Object): anychart.core.wordtree.Connectors;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.data {
    function buildMapping(dataSet: anychart.data.Set, fromIndex: number, toIndex: number, names: Array<string>, keys?: Array<string>): anychart.data.Mapping;
    function loadCsvFile(url: string, onSuccess: ((data:Array<string>)=>void), onError?: ((errorCode:number,exceptionOrMessage:Object|string)=>void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function loadGoogleSpreadsheet(key: string | Object, onSuccess: ((data:anychart.data.DataSettings,settings:Object)=>void), onError?: (() => void), timeoutInterval?: number, context?: any): void;
    function loadJsonFile(url: string, onSuccess: ((data:Array<Object|string|number|boolean>)=>void), onError?: ((errorCode:number,errorMessage:string)=>void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function loadXmlFile(url: string, onSuccess: ((data:Object)=>void), onError?: ((errorCode:number,exceptionOrMessage:Object|string)=>void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function mapAsTable(data: Array<Array<any>>, mode?: string, seriesCount?: number): Array<anychart.data.Mapping>;
    function parseHtmlTable(tableSelector?: string, rowsSelector?: string, cellsSelector?: string, headersSelector?: string, captionSelector?: string, valueProcessor?: (() => void)): anychart.data.DataSettings;
    function parseText(text: string, settings?: string | anychart.data.TextParsingSettings): Array<Array<string|number>>;
    function set(data?: Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.data.Set;
    function table(keyColumnIndex?: number | string, dateTimePattern?: string, timeOffset?: number, baseDate?: number | Date, locale?: string | anychart.format.Locale): anychart.data.Table;
    function tree(data?: Array<Object> | string, fillMethodOrCsvMapping?: string | Object, csvSettings?: string | anychart.data.TextParsingSettings, fieldsMapping?: Object): anychart.data.Tree;
    type TextParsingSettings = {
        columnsSeparator?: string;
        cutLength?: number;
        ignoreFirstRow?: boolean;
        ignoreItems?: Array<string>;
        ignoreTrailingSpaces?: boolean;
        maxItems?: number;
        maxLength?: number;
        minLength?: number;
        mode?: string;
        rowsSeparator?: string;
    }
    type DataSettings = {
        caption?: string;
        header?: Array<string>;
        rows?: Array<any>;
        text?: string;
        textSettings?: string | anychart.data.TextParsingSettings;
    }
    interface Tree extends anychart.core.Base {
        addChild(child: Object): anychart.data.Tree.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.Tree.DataItem;
        addData(data: Array<Object> | string, fillingMethod?: string, csvSettingsOrDeps?: Object | Array<anychart.data.Tree.Dependency>): anychart.data.Tree;
        createIndexOn(field: string, asString?: boolean, comparisonFn?: ((value1:any,value2:any)=>void)): anychart.data.Tree;
        dispatchEvents(): boolean;
        dispatchEvents(enabled?: boolean): anychart.data.Tree;
        filter(filterFunction: ((item:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)=>void)): Array<anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem>;
        getChildAt(index: number): anychart.data.Tree.DataItem;
        getChildren(): Array<anychart.data.Tree.DataItem>;
        getTraverser(): anychart.data.Traverser;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(mapping?: Object): anychart.data.TreeView;
        numChildren(): number;
        removeAllListeners(type?: string): number;
        removeChild(child: anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        removeChildAt(index: number): anychart.data.Tree.DataItem;
        removeChildren(): anychart.data.Tree;
        removeIndexOn(field: string): anychart.data.Tree;
        search(field: string, value: any, comparisonFn?: ((value1:any,value2:any)=>void)): anychart.data.Tree.DataItem | Array<anychart.data.Tree.DataItem>;
        searchItems(field: string, value: any, comparisonFn?: ((value1:any,value2:any)=>void)): Array<anychart.data.Tree.DataItem>;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Tree {
    type Dependency = {
        from: string | number;
        to: string | number;
    }
    }
    module Tree {
    interface DataItem {
        addChild(child: Object | anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.Tree.DataItem;
        del(...var_args: (any)[]): anychart.data.Tree.DataItem;
        get(key: string): any;
        getChildAt(index: number): anychart.data.Tree.DataItem;
        getChildren(): Array<anychart.data.Tree.DataItem>;
        getParent(): anychart.data.Tree.DataItem;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        numChildren(): number;
        remove(): anychart.data.Tree.DataItem;
        removeChild(child: anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        removeChildAt(index: number): anychart.data.Tree.DataItem;
        removeChildren(): anychart.data.Tree.DataItem;
        set(...var_args: (any)[]): anychart.data.Tree.DataItem;
    }
    }
    interface Traverser {
        advance(): boolean;
        current(): anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem;
        get(key: string): any;
        getDepth(): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        nodeYieldCondition(): (() => void);
        nodeYieldCondition(conditionFunction?: ((dataItem:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)=>boolean)): (() => void) | anychart.data.Traverser;
        reset(): anychart.data.Traverser;
        set(key: string, value: any): anychart.data.Traverser;
        toArray(): Array<anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem>;
        traverseChildrenCondition(): (() => void);
        traverseChildrenCondition(conditionFunction?: ((dataItem:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)=>boolean)): (() => void) | anychart.data.Traverser;
    }
    interface TableIterator {
        advance(): boolean;
        get(field: string): any;
        getIndex(): number;
        getKey(): number;
        reset(): void;
    }
    interface Mapping extends anychart.data.View {
        concat(otherView: anychart.data.View | Array<any>): anychart.data.Mapping;
        derive(): anychart.data.Mapping;
        filter(fieldName: string, filterFunction: ((val:any)=>void)): anychart.data.Mapping;
        find(fieldName: string, fieldValue: any): number;
        get(rowIndex: number, fieldName: string): any;
        getDataSets(): Array<anychart.data.Set>;
        getIterator(): anychart.data.Iterator;
        getMapping(): {[prop:string]:Array<number|string>};
        getRowsCount(): number;
        meta(index: number, name: string): any;
        meta(index: number, name: string, value?: any): anychart.data.Mapping;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        set(rowIndex: number, fieldName: string, value: any): anychart.data.Mapping;
        sort(fieldName: string, comparator?: ((value1:any,value2:any)=>number)): anychart.data.Mapping;
        sort(fieldName: string, order?: string): anychart.data.Mapping;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TreeView extends anychart.core.Base {
        addChild(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.TreeView.DataItem;
        addData(data: Array<Object> | string, fillMethodOrCsvMapping?: string | Object, csvSettingsOrDeps?: Object | Array<anychart.data.Tree.Dependency>): anychart.data.TreeView;
        filter(filterFunction: ((item:anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem)=>void)): Array<anychart.data.Tree.DataItem|anychart.data.TreeView.DataItem>;
        getChildAt(index: number): anychart.data.TreeView.DataItem;
        getChildren(): Array<anychart.data.TreeView.DataItem>;
        getTraverser(): anychart.data.Traverser;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        numChildren(): number;
        removeChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        removeChildAt(index: number): anychart.data.TreeView.DataItem;
        removeChildren(): anychart.data.TreeView;
        search(field: string, value: any, comparisonFn?: ((value1:any,value2:any)=>void)): anychart.data.Tree.DataItem | Array<anychart.data.Tree.DataItem>;
        searchItems(field: string, value: any, comparisonFn?: ((value1:any,value2:any)=>void)): Array<anychart.data.Tree.DataItem>;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module TreeView {
    interface DataItem {
        addChild(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem, index: number): anychart.data.TreeView.DataItem;
        del(...var_args: (any)[]): anychart.data.TreeView.DataItem;
        get(...var_args: (any)[]): any;
        getChildAt(index: number): anychart.data.TreeView.DataItem;
        getChildren(): Array<anychart.data.TreeView.DataItem>;
        getParent(): anychart.data.TreeView.DataItem;
        indexOfChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        numChildren(): number;
        remove(): anychart.data.TreeView.DataItem;
        removeChild(child: anychart.data.Tree.DataItem | anychart.data.TreeView.DataItem): anychart.data.TreeView.DataItem;
        removeChildAt(index: number): anychart.data.TreeView.DataItem;
        removeChildren(): anychart.data.TreeView.DataItem;
        set(...var_args: (any)[]): anychart.data.TreeView.DataItem;
    }
    }
    interface View extends anychart.core.Base {
        concat(otherView: anychart.data.View | Array<any>): anychart.data.View;
        derive(): anychart.data.View;
        filter(fieldName: string, filterFunction: ((val:any)=>void)): anychart.data.View;
        find(fieldName: string, fieldValue: any): number;
        get(rowIndex: number, fieldName: string): any;
        getDataSets(): Array<anychart.data.Set>;
        getIterator(): anychart.data.Iterator;
        getRowsCount(): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        meta(index: number, name: string): any;
        meta(index: number, name: string, value?: any): anychart.data.View;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, row?: any): any;
        set(rowIndex: number, fieldName: string, value: any): anychart.data.View;
        sort(fieldName: string, comparator?: ((value1:any,value2:any)=>number)): anychart.data.View;
        sort(fieldName: string, order?: string): anychart.data.View;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Set extends anychart.core.Base {
        append(...var_args: (any)[]): anychart.data.Set;
        data(): Array<any>;
        data(data?: Array<any> | string, settings?: string | anychart.data.TextParsingSettings): anychart.data.Set;
        getRowsCount(): number;
        insert(row: any, index?: number): anychart.data.Set;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(mapping?: Object): anychart.data.Mapping;
        remove(index: number): anychart.data.Set;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, row?: any): any;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TableSelectable {
        getIterator(): anychart.data.TableIterator;
        search(key: number | string | Date, mode?: string): anychart.data.TableSelectable.RowProxy;
        select(startDate: number | string | Date, endDate: number | string | Date, intervalUnit?: string, intervalCount?: number): anychart.data.TableSelectable;
        selectAll(intervalUnit?: string, intervalCount?: number): anychart.data.TableSelectable;
    }
    module TableSelectable {
    interface RowProxy {
        get(field: string): any;
        getColumn(column: number): any;
        getIndex(): number;
        getKey(): number;
    }
    }
    interface TableComputer {
        addOutputField(name: string, uid?: string): number;
        getFieldIndex(name: string): number;
        setCalculationFunction(calculationFunction: ((rowProxy:anychart.data.TableComputer.RowProxy,context:Object)=>void)): void;
        setContext(value: Object): void;
        setStartFunction(startFunction: ((context:Object)=>void)): void;
    }
    module TableComputer {
    interface RowProxy extends anychart.data.TableSelectable.RowProxy {
        get(field: string): any;
        getColumn(column: number): any;
        getIndex(): number;
        getKey(): number;
        set(name: string, value: any): boolean;
        setColumn(index: number, value: any): boolean;
    }
    }
    interface TableMapping extends anychart.core.Base {
        addField(name: string, column: number, type?: string, weightsColumn?: number): anychart.data.TableMapping;
        createSelectable(): anychart.data.TableSelectable;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Table extends anychart.core.Base {
        addData(rawData: Array<any> | string, removeFromStart?: boolean | number, csvSettings?: string | anychart.data.TextParsingSettings): anychart.data.Table;
        createComputer(mappingSettingsOrMapping?: anychart.data.TableMapping | {[prop:string]:{column:number|string,type:string|string,weights:number|string}|number|string}): anychart.data.TableComputer;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(fields?: {[prop:string]:{column:number|string,type:string,weights:number|string}|number|string}): anychart.data.TableMapping;
        remove(startKey?: number | string | Date, endKey?: number | string | Date): anychart.data.Table;
        removeAllListeners(type?: string): number;
        removeFirst(count?: number): anychart.data.Table;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Iterator {
        advance(): boolean;
        get(fieldName: string): any;
        getIndex(): number;
        getRowsCount(): number;
        meta(name: string): any;
        meta(name: string, value?: any): anychart.data.Iterator;
        reset(): anychart.data.Iterator;
        select(index: number): boolean;
    }
}

declare namespace anychart.editor {
    type JavascriptOptions = {
        addData: boolean;
        addGeoData: boolean;
        addMarkers: boolean;
        container: string;
        minify: boolean;
        wrapper: string;
    }
    interface Editor {
        addClassName(className: string): void;
        data(data: Array<Object> | Object): void;
        decorate(element: Element): void;
        dialogRender(): void;
        dialogRender(className?: string): void;
        dialogVisible(): boolean;
        dialogVisible(enabled?: boolean): anychart.editor.Editor;
        dispose(): void;
        getJavascript(): string;
        getJavascript(outputOptions?: anychart.editor.JavascriptOptions): string;
        getJson(): string;
        getXml(): string;
        hide(hide?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        localization(settings: Object): anychart.editor.Editor;
        removeAllListeners(type?: string): number;
        removeClassName(className: string): void;
        render(parentElement?: Element): void;
        show(show?: boolean): void;
        step(stepName: string): anychart.editor.Step;
        step(stepName: string, value?: boolean | {enabled:boolean}): anychart.editor.Step | anychart.editor.Editor;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        version(): string;
    }
    interface Step {
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.editor.Step;
        tab(tabName: string, value: boolean | {enabled:boolean}): anychart.editor.Step;
    }
}

declare namespace anychart.exports {
    function clientside(): anychart.exports.ClientsideConfiguration;
    function clientside(configuration: anychart.exports.ClientsideConfiguration): anychart.core.utils.Exports;
    function facebook(): Object;
    function facebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string, width?: string, height?: string, appId?: string): Object;
    function filename(fileName?: string): string;
    function image(): Object;
    function image(widthOrOptions?: string | Object, height?: string): Object;
    function linkedin(): Object;
    function linkedin(captionOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
    function pinterest(): Object;
    function pinterest(linkOrOptions?: string | Object, description?: string, width?: string, height?: string): Object;
    function server(address?: string): string;
    function twitter(): Object;
    function twitter(urlOrOptions?: string | Object, width?: string, height?: string): Object;
    type ClientsideConfiguration = {
        enabled: boolean;
        fallback: boolean;
        path: string;
    }
}

declare namespace anychart.format {
    const locales: {[prop:string]:anychart.format.Locale};
    function date(date: number | Date, timeZone?: number, locale?: string | anychart.format.Locale): string;
    function dateTime(date: number | Date, format?: string, timeZone?: number, locale?: string | anychart.format.Locale): string;
    function getDateTimeFormat(identifier: string, index?: number, locale?: anychart.format.Locale): string;
    function getDateTimeFormats(identifier: string, locale?: anychart.format.Locale): string;
    function getIntervalIdentifier(intervalUnit: string, parentIntervalUnit?: string): string;
    function getMessage(keyword: string): string;
    function inputBaseDate(): Date;
    function inputBaseDate(date: Date | number): Date;
    function inputDateTimeFormat(): string;
    function inputDateTimeFormat(format?: string): string;
    function inputLocale(): string | anychart.format.Locale;
    function inputLocale(settings?: string | anychart.format.Locale): string | anychart.format.Locale;
    function number(number: number, decimalsCountOrLocal?: number | anychart.format.NumberLocale | string, decimalPoint?: string, groupsSeparator?: string, scale?: Object | boolean, zeroFillDecimals?: boolean, scaleSuffixSeparator?: string, useBracketsForNegative?: boolean): string;
    function number(number: number, settings?: anychart.format.NumberLocale): string;
    function outputDateFormat(): string;
    function outputDateFormat(format?: string): void;
    function outputDateTimeFormat(): string;
    function outputDateTimeFormat(format?: string): void;
    function outputLocale(): string | anychart.format.Locale;
    function outputLocale(settings?: string | anychart.format.Locale): string | anychart.format.Locale;
    function outputTimeFormat(): string;
    function outputTimeFormat(format?: string): void;
    function outputTimezone(): number;
    function outputTimezone(value?: number): number;
    function parseDateTime(value: any, format?: string, baseDate?: Date, locale?: string | anychart.format.Locale): Date;
    function parseNumber(value: any, locale?: anychart.format.NumberLocale | string): number;
    function subs(string: string, ...var_args: (any)[]): string;
    function time(date: number | Date, timeZone?: number, locale?: string | anychart.format.Locale): string;
    type NumberLocale = {
        decimalPoint?: string;
        decimalsCount?: number;
        groupsSeparator?: string;
        scale?: Object | boolean;
        scaleSuffixSeparator?: string;
        useBracketsForNegative?: boolean;
        zeroFillDecimals?: boolean;
    }
    type DateTimeLocale = {
        ampms: Array<string>;
        dateFormats: string;
        dateTimeFormats: string;
        eras: Array<string>;
        erasNames: Array<string>;
        firstDayOfWeek: number;
        firstWeekCutOfDay: number;
        formats: {[prop:string]:string|Array<string>};
        months: Array<string>;
        narrowMonths: Array<string>;
        narrowWeekdays: Array<string>;
        quarters: Array<string>;
        shortMonths: Array<string>;
        shortQuarters: Array<string>;
        shortWeekdays: Array<string>;
        standaloneMonths: Array<string>;
        standaloneNarrowMonths: Array<string>;
        standaloneNarrowWeekdays: Array<string>;
        standaloneShortMonths: Array<string>;
        standaloneShortWeekdays: Array<string>;
        standaloneWeekdays: Array<string>;
        timeFormats: string;
        weekdays: Array<string>;
        weekendRange: Array<number>;
    }
    type Locale = {
        dateTimeLocale: anychart.format.DateTimeLocale;
        messages: {[prop:string]:string};
        numberLocale: anychart.format.NumberLocale;
    }
    interface Context {
        getData(fieldPath: any): any;
        getData(...var_args: (any)[]): any;
        getMeta(name: string): any;
        getStat(key: string): any;
    }
}

declare namespace anychart.gauges {
    function circular(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.CircularGauge;
    function led(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
    function linear(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
    function tank(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
    function thermometer(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.charts.LinearGauge;
}

declare namespace anychart.graphics {
    function circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
    function clip(leftorRect?: number | Array<number> | anychart.graphics.math.Rect | Object, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
    function create(container?: Element | string, width?: string | number, height?: string | number): anychart.graphics.vector.Stage;
    function ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
    function getStage(id: string): anychart.graphics.vector.Stage;
    function hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType, color?: string, thickness?: number, size?: number): anychart.graphics.vector.HatchFill;
    function image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
    function layer(): anychart.graphics.vector.Layer;
    function path(): anychart.graphics.vector.Path;
    function patternFill(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
    function rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
    function server(address?: string): string;
    function text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
    function type(): anychart.graphics.StageType;
    function updateReferences(): void;
    function useAbsoluteReferences(enabled?: boolean): boolean;
    enum StageType {
        SVG,
        VML
    }
}

declare namespace anychart.graphics.events {
    function listen(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capture?: boolean, handler?: Object): Object;
    function listenOnce(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capture?: boolean, handler?: Object): Object;
    function removeAll(target: anychart.graphics.vector.Element, type?: string): number;
    function unlisten(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capture?: boolean, handler?: Object): boolean;
    function unlistenByKey(key: Object): boolean;
    enum EventType {
        CLICK,
        CONTEXTMENU,
        DBLCLICK,
        DRAG,
        DRAG_BEFORE,
        DRAG_EARLY_CANCEL,
        DRAG_END,
        DRAG_START,
        MOUSEDOWN,
        MOUSEMOVE,
        MOUSEOUT,
        MOUSEOVER,
        MOUSEUP,
        TAP,
        TOUCHCANCEL,
        TOUCHEND,
        TOUCHMOVE,
        TOUCHSTART
    }
    interface BrowserEvent {
        preventDefault(): void;
        stopPropagation(): void;
        stopWrapperPropagation(): void;
    }
}

declare namespace anychart.graphics.math {
    function coordinate(x?: number, y?: number): anychart.graphics.math.Coordinate;
    interface Coordinate {
        getX(): number;
        getY(): number;
    }
    interface Rect {
        getBottom(): number;
        getHeight(): number;
        getLeft(): number;
        getRight(): number;
        getTop(): number;
        getWidth(): number;
    }
}

declare namespace anychart.graphics.vector {
    function normalizeFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Fill;
    function normalizeHatchFill(patternFillOrType?: anychart.graphics.vector.HatchFill | anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill.HatchFillType | string | Object, color?: string, thickness?: string | number, size?: string | number): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill;
    function normalizeStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Stroke;
    type GradientKey = {
        color: string;
        offset: number;
        opacity: number;
    }
    type SolidFill = {
        color: string;
        opacity: number;
    }
    type LinearGradientFill = {
        angle?: number;
        keys: Array<anychart.graphics.vector.GradientKey|string>;
        mode?: boolean | anychart.graphics.vector.Rect;
        opacity?: number;
    }
    type RadialGradientFill = {
        cx: number;
        cy: number;
        fx: number;
        fy: number;
        keys: Array<anychart.graphics.vector.GradientKey|string>;
        mode: anychart.graphics.math.Rect;
        opacity: number;
    }
    type ImageFill = {
        mode?: anychart.graphics.vector.ImageFillMode | string;
        opacity?: number;
        src?: string;
    }
    type ColoredFill = string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill;
    type Fill = string | anychart.graphics.vector.ImageFill | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | anychart.graphics.vector.PatternFill;
    type SolidStroke = {
        color: string;
        dash: string;
        lineCap: string;
        lineJoin: string;
        opacity: number;
        thickness: number;
    }
    type LinearGradientStroke = {
        angle: number;
        dash: string;
        keys: Array<anychart.graphics.vector.GradientKey|string>;
        lineCap: string;
        lineJoin: string;
        mode: boolean | anychart.graphics.math.Rect;
        opacity: number;
        thickness: number;
    }
    type RadialGradientStroke = {
        cx?: number;
        cy?: number;
        dash?: string;
        fx?: number;
        fy?: number;
        keys?: Array<anychart.graphics.vector.GradientKey|string>;
        lineCap?: string;
        lineJoin?: string;
        mode?: anychart.graphics.math.Rect;
        opacity?: number;
        thickness?: number;
    }
    type Stroke = string | anychart.graphics.vector.SolidStroke | anychart.graphics.vector.LinearGradientStroke | anychart.graphics.vector.RadialGradientStroke;
    type AnyColor = anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke | anychart.graphics.vector.PatternFill;
    type TextStyle = {
        color?: string;
        decoration?: anychart.graphics.vector.Text.Decoration | string;
        direction?: anychart.graphics.vector.Text.Direction | string;
        fontFamily?: string;
        fontSize?: string | number;
        fontStyle?: anychart.graphics.vector.Text.FontStyle | string;
        fontVariant?: anychart.graphics.vector.Text.FontVariant | string;
        fontWeight?: number | string;
        hAlign?: anychart.graphics.vector.Text.HAlign | string;
        height?: number | string;
        letterSpacing?: string;
        lineHeight?: string | number;
        opacity?: number;
        selectable?: boolean;
        textIndent?: number;
        textOverflow?: anychart.graphics.vector.Text.TextOverflow;
        vAlign?: anychart.graphics.vector.Text.VAlign | string;
        width?: number | string;
        wordBreak?: string;
        wordWrap?: string;
    }
    type TextSegmentStyle = {
        color: string;
        decoration: string;
        fontFamily: string;
        fontSize: string | number;
        fontStyle: string;
        fontVariant: string;
        fontWeight: number | string;
        letterSpacing: string;
        opacity: number;
    }
    type TextShadow = {
        color: string;
        offsetX: string;
        offsetY: string;
        radius: string;
    }
    enum Anchor {
        AUTO,
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Cursor {
        CROSSHAIR,
        DEFAULT,
        EW_RESIZE,
        E_RESIZE,
        HELP,
        MOVE,
        NESW_RESIZE,
        NE_RESIZE,
        NS_RESIZE,
        NWSE_RESIZE,
        NW_RESIZE,
        N_RESIZE,
        POINTER,
        SE_RESIZE,
        SW_RESIZE,
        S_RESIZE,
        TEXT,
        WAIT,
        W_RESIZE
    }
    enum StrokeLineJoin {
        BEVEL,
        MITER,
        ROUND
    }
    enum StrokeLineCap {
        BUTT,
        ROUND,
        SQUARE
    }
    enum ImageFillMode {
        FIT,
        FIT_MAX,
        STRETCH,
        TILE
    }
    enum PaperSize {
        A0,
        A1,
        A2,
        A3,
        A4,
        A5,
        A6,
        US_LETTER
    }
    interface LinearGradient {
        dispose(): void;
    }
    interface Shape extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Shape;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Shape;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Shape;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Shape;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Shape;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Shape;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Shape;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Shape;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.Shape;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Shape;
        remove(): anychart.graphics.vector.Shape;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Shape;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Shape;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Shape;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Shape;
        setPosition(x: number, y: number): anychart.graphics.vector.Shape;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Shape;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Shape;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Shape;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.graphics.vector.Shape;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(thickness?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Shape;
        translate(tx: number, ty: number): anychart.graphics.vector.Shape;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Shape;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Shape;
        unlistenByKey(key: Object): boolean;
    }
    interface Stage {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Stage;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Stage;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Stage;
        asyncMode(): boolean;
        asyncMode(async?: boolean): anychart.graphics.vector.Stage;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(rect?: anychart.graphics.math.Rect): anychart.graphics.vector.Stage;
        container(): Element;
        container(element?: Element): anychart.graphics.vector.Stage;
        createClip(rect?: Array<number> | anychart.graphics.math.Rect | Object): anychart.graphics.vector.Clip;
        createClip(left?: number, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
        credits(): anychart.core.ui.StageCredits;
        credits(settings?: Object | boolean): anychart.graphics.vector.Stage;
        cross(): void;
        data(): Object;
        data(settings?: Object): anychart.graphics.vector.Stage;
        desc(): string;
        desc(text?: string): anychart.graphics.vector.Stage;
        diagonalCross(): void;
        diamond(): void;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void), obj?: Object): anychart.graphics.vector.Stage;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.graphics.vector.Stage;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getContainerElement(): Element;
        getDomWrapper(): Element;
        getJpgBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPngBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getSvgBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getTransformationMatrix(): Array<number>;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType, color?: string, thickness?: number, size?: number): anychart.graphics.vector.HatchFill;
        height(): number;
        height(height?: string | number): anychart.graphics.vector.Stage;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(id?: string): anychart.graphics.vector.Stage;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        isFullScreenAvailable(): boolean;
        isRendering(): boolean;
        isSuspended(): boolean;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string | anychart.graphics.vector.Stage.EventType, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string | anychart.graphics.vector.Stage.EventType, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        maxResizeDelay(): number;
        maxResizeDelay(delay?: number): anychart.graphics.vector.Stage;
        numChildren(): number;
        parent(): anychart.graphics.vector.Stage;
        path(): anychart.graphics.vector.Path;
        pattern(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
        pie(): void;
        print(paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Stage;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        resize(width: number | string, height: number | string): void;
        resume(force?: boolean): anychart.graphics.vector.Stage;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        roundedInnerRect(): void;
        roundedRect(): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        setPosition(x: number, y: number): anychart.graphics.vector.Stage;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Stage;
        shareAsJpg(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        suspend(): anychart.graphics.vector.Stage;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Stage;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Stage;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(text?: string): anychart.graphics.vector.Stage;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        translate(tx: number, ty: number): anychart.graphics.vector.Stage;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string | anychart.graphics.vector.Stage.EventType, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useAnychartExporting(value?: boolean): anychart.graphics.vector.Stage;
        useAnychartExporting(): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Stage;
        width(): number;
        width(width?: string | number): anychart.graphics.vector.Stage;
    }
    namespace Stage {
    enum EventType {
        RENDER_FINISH,
        RENDER_START,
        STAGE_RENDERED,
        STAGE_RESIZE
    }
    }
    interface PatternFill extends anychart.graphics.vector.Layer {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.PatternFill;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.PatternFill;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.PatternFill;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.PatternFill;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.PatternFill;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.PatternFill;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.PatternFill;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.PatternFill;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.PatternFill;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void)): anychart.graphics.vector.PatternFill;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void), obj?: Object): anychart.graphics.vector.PatternFill;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.PatternFill;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(id?: string): anychart.graphics.vector.PatternFill;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.PatternFill;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.PatternFill;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.PatternFill;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.PatternFill;
        removeChildAt(index: number): anychart.graphics.vector.PatternFill;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.PatternFill;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.PatternFill;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.PatternFill;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.PatternFill;
        setPosition(x: number, y: number): anychart.graphics.vector.PatternFill;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.PatternFill;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.PatternFill;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.PatternFill;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.PatternFill;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.PatternFill;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.PatternFill;
        translate(tx: number, ty: number): anychart.graphics.vector.PatternFill;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.PatternFill;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.PatternFill;
        unlistenByKey(key: Object): boolean;
    }
    interface RadialGradient {
        dispose(): void;
    }
    interface Circle extends anychart.graphics.vector.Ellipse {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Circle;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Circle;
        center(): anychart.graphics.math.Coordinate;
        center(center?: anychart.graphics.math.Coordinate): anychart.graphics.vector.Circle;
        centerX(): number;
        centerX(centerX?: number): anychart.graphics.vector.Circle;
        centerY(): number;
        centerY(centerY?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Circle;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Circle;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Circle;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Circle;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Circle;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Circle;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.graphics.vector.Circle;
        fill(color: string, opacity?: number): anychart.graphics.vector.Circle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Circle;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Circle;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.Circle;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Circle;
        radius(): number;
        radius(radius?: number): anychart.graphics.vector.Circle;
        radiusX(): number;
        radiusX(radiusX?: number): anychart.graphics.vector.Circle;
        radiusY(): number;
        radiusY(value?: number): anychart.graphics.vector.Circle;
        remove(): anychart.graphics.vector.Circle;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Circle;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Circle;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Circle;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Circle;
        setPosition(x: number, y: number): anychart.graphics.vector.Circle;
        setRadius(rx: number, ry: number): anychart.graphics.vector.Circle;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Circle;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Circle;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Circle;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.graphics.vector.Circle;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Circle;
        strokeThickness(): number;
        strokeThickness(thickness?: number): anychart.graphics.vector.Circle;
        title(): string;
        title(value?: string): anychart.graphics.vector.Circle;
        translate(tx: number, ty: number): anychart.graphics.vector.Circle;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Circle;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Circle;
        unlistenByKey(key: Object): boolean;
    }
    interface UnmanagedLayer extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.UnmanagedLayer;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.UnmanagedLayer;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.UnmanagedLayer;
        content(): Element | string;
        content(value?: string | Element): anychart.graphics.vector.UnmanagedLayer;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.UnmanagedLayer;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.UnmanagedLayer;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.UnmanagedLayer;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.UnmanagedLayer;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.UnmanagedLayer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.UnmanagedLayer;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.UnmanagedLayer;
        remove(): anychart.graphics.vector.UnmanagedLayer;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.UnmanagedLayer;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.UnmanagedLayer;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.UnmanagedLayer;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.UnmanagedLayer;
        setPosition(x: number, y: number): anychart.graphics.vector.UnmanagedLayer;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.UnmanagedLayer;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.UnmanagedLayer;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.UnmanagedLayer;
        title(): string;
        title(value?: string): anychart.graphics.vector.UnmanagedLayer;
        translate(tx: number, ty: number): anychart.graphics.vector.UnmanagedLayer;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.UnmanagedLayer;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.UnmanagedLayer;
        unlistenByKey(key: Object): boolean;
    }
    interface Rect extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Rect;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Rect;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Rect;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Rect;
        cut(radiusAll: string | number): anychart.graphics.vector.Rect;
        cut(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Rect;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Rect;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Rect;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Rect;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.graphics.vector.Rect;
        fill(color: string, opacity?: number): anychart.graphics.vector.Rect;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Rect;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Rect;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.Rect;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Rect;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Rect;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Rect;
        round(radiusAll: string | number): anychart.graphics.vector.Rect;
        round(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        roundInner(radiusAll: string | number): anychart.graphics.vector.Rect;
        roundInner(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Rect;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Rect;
        setBounds(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.Rect;
        setHeight(value: number): anychart.graphics.vector.Rect;
        setPosition(x: number, y: number): anychart.graphics.vector.Rect;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Rect;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Rect;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Rect;
        setWidth(width: number): anychart.graphics.vector.Rect;
        setX(x: number): anychart.graphics.vector.Rect;
        setY(y: number): anychart.graphics.vector.Rect;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.graphics.vector.Rect;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Rect;
        strokeThickness(): number;
        strokeThickness(thickness?: number): anychart.graphics.vector.Rect;
        title(): string;
        title(value?: string): anychart.graphics.vector.Rect;
        translate(tx: number, ty: number): anychart.graphics.vector.Rect;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Rect;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Rect;
        unlistenByKey(key: Object): boolean;
    }
    interface Layer extends anychart.graphics.vector.Element {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Layer;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Layer;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Layer;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Layer;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Layer;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Layer;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Layer;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Layer;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void)): anychart.graphics.vector.Layer;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Layer;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(id?: string): anychart.graphics.vector.Layer;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Layer;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Layer;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        removeChildAt(index: number): anychart.graphics.vector.Layer;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Layer;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Layer;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Layer;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Layer;
        setPosition(x: number, y: number): anychart.graphics.vector.Layer;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Layer;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Layer;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Layer;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Layer;
        translate(tx: number, ty: number): anychart.graphics.vector.Layer;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Layer;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Layer;
        unlistenByKey(key: Object): boolean;
    }
    interface Path extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Path;
        arcTo(rx: number, ry: number, fromAngle: number, extent: number): anychart.graphics.vector.Path;
        arcToAsCurves(rx: number, ry: number, fromAngle: number, extent: number): anychart.graphics.vector.Path;
        arcToByEndPoint(x: number, y: number, rx: number, ry: number, largeArc: boolean, clockwiseArc: boolean): anychart.graphics.vector.Path;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Path;
        circularArc(cx: number, cy: number, rx: number, ry: number, fromAngle: number, sweep: number, lineTo?: boolean): anychart.graphics.vector.Path;
        clear(): anychart.graphics.vector.Path;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Path;
        close(): anychart.graphics.vector.Path;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Path;
        curveTo(control1X: number, control1Y: number, control2X: number, control2Y: number, endX: number, endY: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Path;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Path;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Path;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Path;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.graphics.vector.Path;
        fill(color: string, opacity?: number): anychart.graphics.vector.Path;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Path;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Path;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getCurrentPoint(): anychart.graphics.math.Coordinate;
        getHeight(): number;
        getLength(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.Path;
        lineTo(x: number, y: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        moveTo(x: number, y: number): anychart.graphics.vector.Path;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Path;
        quadraticCurveTo(controlX: number, controlY: number, endX: number, endY: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        remove(): anychart.graphics.vector.Path;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Path;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Path;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Path;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Path;
        setPosition(x: number, y: number): anychart.graphics.vector.Path;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Path;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Path;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Path;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.graphics.vector.Path;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Path;
        strokeThickness(): number;
        strokeThickness(thickness?: number): anychart.graphics.vector.Path;
        title(): string;
        title(value?: string): anychart.graphics.vector.Path;
        translate(tx: number, ty: number): anychart.graphics.vector.Path;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Path;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Path;
        unlistenByKey(key: Object): boolean;
    }
    interface Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Image extends anychart.graphics.vector.Element {
        align(): anychart.graphics.vector.Image.Align;
        align(align?: anychart.graphics.vector.Image.Align): anychart.graphics.vector.Image;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Image;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Image;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Image;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Image;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Image;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Image;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Image;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Image;
        fittingMode(): anychart.graphics.vector.Image.Fitting;
        fittingMode(mode?: anychart.graphics.vector.Image.Fitting | string): anychart.graphics.vector.Image;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        height(): number;
        height(height?: number): anychart.graphics.vector.Image;
        id(): string;
        id(id?: string): anychart.graphics.vector.Image;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Image;
        remove(): anychart.graphics.vector.Image;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Image;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Image;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Image;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Image;
        setPosition(x: number, y: number): anychart.graphics.vector.Image;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Image;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Image;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Image;
        src(): string;
        src(url?: string): anychart.graphics.vector.Image;
        title(): string;
        title(value?: string): anychart.graphics.vector.Image;
        translate(tx: number, ty: number): anychart.graphics.vector.Image;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Image;
        width(): number;
        width(width?: number): anychart.graphics.vector.Image;
        x(): number;
        x(xCoord?: number): anychart.graphics.vector.Image;
        y(): number;
        y(yCoord?: number): anychart.graphics.vector.Image;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Image;
        unlistenByKey(key: Object): boolean;
    }
    namespace Image {
    enum Fitting {
        MEET,
        SLICE
    }
    enum Align {
        NONE,
        X_MAX_Y_MAX,
        X_MAX_Y_MID,
        X_MAX_Y_MIN,
        X_MID_Y_MAX,
        X_MID_Y_MID,
        X_MID_Y_MIN,
        X_MIN_Y_MAX,
        X_MIN_Y_MID,
        X_MIN_Y_MIN
    }
    }
    interface HatchFill extends anychart.graphics.vector.PatternFill {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.HatchFill;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.HatchFill;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.HatchFill;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.HatchFill;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.HatchFill;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.HatchFill;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.HatchFill;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.HatchFill;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.HatchFill;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.HatchFill;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void)): anychart.graphics.vector.HatchFill;
        forEachChild(callback: ((element:anychart.graphics.vector.Element)=>void), obj?: Object): anychart.graphics.vector.HatchFill;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.HatchFill;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(id?: string): anychart.graphics.vector.HatchFill;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.HatchFill;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.HatchFill | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.HatchFill;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.HatchFill;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.HatchFill;
        removeChildAt(index: number): anychart.graphics.vector.HatchFill;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.HatchFill;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.HatchFill;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.HatchFill;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.HatchFill;
        setPosition(x: number, y: number): anychart.graphics.vector.HatchFill;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.HatchFill;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.HatchFill;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.HatchFill;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.HatchFill;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.HatchFill;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.HatchFill;
        translate(tx: number, ty: number): anychart.graphics.vector.HatchFill;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.HatchFill;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.HatchFill;
        unlistenByKey(key: Object): boolean;
    }
    namespace HatchFill {
    enum HatchFillType {
        BACKWARD_DIAGONAL,
        CHECKER_BOARD,
        CONFETTI,
        DASHED_BACKWARD_DIAGONAL,
        DASHED_FORWARD_DIAGONAL,
        DASHED_HORIZONTAL,
        DASHED_VERTICAL,
        DIAGONAL_BRICK,
        DIAGONAL_CROSS,
        DIVOT,
        FORWARD_DIAGONAL,
        GRID,
        HORIZONTAL,
        HORIZONTAL_BRICK,
        PERCENT_05,
        PERCENT_10,
        PERCENT_20,
        PERCENT_25,
        PERCENT_30,
        PERCENT_40,
        PERCENT_50,
        PERCENT_60,
        PERCENT_70,
        PERCENT_75,
        PERCENT_80,
        PERCENT_90,
        PLAID,
        SOLID_DIAMOND,
        VERTICAL,
        VERTICAL_BRICK,
        WEAVE,
        ZIG_ZAG
    }
    }
    interface Text extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Text;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Text;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Text;
        color(): string;
        color(color?: string): anychart.graphics.vector.Text;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Text;
        decoration(): string;
        decoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.graphics.vector.Text;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Text;
        direction(): string;
        direction(direction?: anychart.graphics.vector.Text.Direction | string): anychart.graphics.vector.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Text;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Text;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Text;
        fontFamily(): string;
        fontFamily(family?: string): anychart.graphics.vector.Text;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.graphics.vector.Text;
        fontStyle(): string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.graphics.vector.Text;
        fontVariant(): string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.graphics.vector.Text;
        fontWeight(): string;
        fontWeight(weight?: string | number): anychart.graphics.vector.Text;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTextHeight(): number;
        getTextWidth(): number;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hAlign(): string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.graphics.vector.Text;
        hasParent(): boolean;
        height(): number | string;
        height(height?: number | string): anychart.graphics.vector.Text;
        htmlText(): string;
        htmlText(value?: string): anychart.graphics.vector.Text;
        id(): string;
        id(id?: string): anychart.graphics.vector.Text;
        letterSpacing(): string;
        letterSpacing(spacing?: string | number): anychart.graphics.vector.Text;
        lineHeight(): string;
        lineHeight(height?: string | number): anychart.graphics.vector.Text;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        opacity(): number;
        opacity(opacity?: number): anychart.graphics.vector.Text;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Text;
        path(): anychart.graphics.vector.Path;
        path(path?: anychart.graphics.vector.Path): anychart.graphics.vector.Text;
        remove(): anychart.graphics.vector.Text;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Text;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Text;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Text;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Text;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.graphics.vector.Text;
        setPosition(x: number, y: number): anychart.graphics.vector.Text;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Text;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Text;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Text;
        style(): anychart.graphics.vector.TextStyle;
        style(style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        text(): string;
        text(text?: string): anychart.graphics.vector.Text;
        textIndent(): number;
        textIndent(indent?: number): anychart.graphics.vector.Text;
        textOverflow(): string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Text;
        translate(tx: number, ty: number): anychart.graphics.vector.Text;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        vAlign(): string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.graphics.vector.Text;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Text;
        width(): number | string;
        width(width?: number | string): anychart.graphics.vector.Text;
        wordBreak(): string | anychart.graphics.vector.Text.WordBreak;
        wordBreak(value?: string | anychart.graphics.vector.Text.WordBreak): anychart.graphics.vector.Text;
        wordWrap(): string | anychart.graphics.vector.Text.WordWrap;
        wordWrap(value?: string | anychart.graphics.vector.Text.WordWrap): string | anychart.graphics.vector.Text;
        x(): number;
        x(xCoord?: number): anychart.graphics.vector.Text;
        y(): number;
        y(yCoord?: number): anychart.graphics.vector.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Text;
        unlistenByKey(key: Object): boolean;
    }
    namespace Text {
    enum WordBreak {
        BREAK_ALL,
        KEEP_ALL,
        NORMAL
    }
    enum WordWrap {
        BREAK_WORD,
        NORMAL
    }
    enum TextOverflow {
        CLIP,
        ELLIPSIS
    }
    enum HAlign {
        CENTER,
        END,
        LEFT,
        RIGHT,
        START
    }
    enum VAlign {
        BOTTOM,
        MIDDLE,
        TOP
    }
    enum Decoration {
        BLINK,
        LINE_THROUGH,
        NONE,
        OVERLINE,
        UNDERLINE
    }
    enum FontVariant {
        NORMAL,
        SMALL_CAP
    }
    enum FontStyle {
        ITALIC,
        NORMAL,
        OBLIQUE
    }
    enum Direction {
        LTR,
        RTL
    }
    }
    interface Ellipse extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Ellipse;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Ellipse;
        center(): anychart.graphics.math.Coordinate;
        center(center?: anychart.graphics.math.Coordinate): anychart.graphics.vector.Ellipse;
        centerX(): number;
        centerX(centerX?: number): anychart.graphics.vector.Ellipse;
        centerY(): number;
        centerY(centerY?: number): anychart.graphics.vector.Ellipse;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Ellipse;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Ellipse;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Ellipse;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Ellipse;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.Ellipse;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Ellipse;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill): anychart.graphics.vector.Ellipse;
        fill(color: string, opacity?: number): anychart.graphics.vector.Ellipse;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Ellipse;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Ellipse;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(id?: string): anychart.graphics.vector.Ellipse;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Ellipse;
        radiusX(): number;
        radiusX(radiusX?: number): anychart.graphics.vector.Ellipse;
        radiusY(): number;
        radiusY(value?: number): anychart.graphics.vector.Ellipse;
        remove(): anychart.graphics.vector.Ellipse;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Ellipse;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Ellipse;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Ellipse;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Ellipse;
        setPosition(x: number, y: number): anychart.graphics.vector.Ellipse;
        setRadius(rx: number, ry: number): anychart.graphics.vector.Ellipse;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Ellipse;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Ellipse;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Ellipse;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(settings: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.graphics.vector.Ellipse;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Ellipse;
        strokeThickness(): number;
        strokeThickness(thickness?: number): anychart.graphics.vector.Ellipse;
        title(): string;
        title(value?: string): anychart.graphics.vector.Ellipse;
        translate(tx: number, ty: number): anychart.graphics.vector.Ellipse;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Ellipse;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Ellipse;
        unlistenByKey(key: Object): boolean;
    }
    interface Clip {
        dispose(): void;
        shape(): anychart.graphics.vector.Shape;
        shape(shape?: Array<number> | anychart.graphics.vector.Shape | anychart.graphics.math.Rect | Object): anychart.graphics.vector.Clip;
        shape(left?: number, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
    }
}

declare namespace anychart.graphics.vector.primitives {
    function cross(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function diagonalCross(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function diamond(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function donut(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, cx: number, cy: number, outerR: number, innerR: number, start: number, sweep: number): anychart.graphics.vector.Path;
    function hLine(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function pie(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, cx: number, cy: number, r: number, start: number, sweep: number): anychart.graphics.vector.Path;
    function roundedInnerRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function roundedRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function star(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number, innerRadius: number, numberOfSpikes: number, startDegrees?: number, curvature?: number): anychart.graphics.vector.Path;
    function star10(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star4(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star5(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star6(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star7(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleDown(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleLeft(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleRight(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleUp(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function truncatedRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function vLine(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
}

declare namespace anychart.graphics.vector.vml {
    interface Text extends anychart.graphics.vector.Text {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.vml.Text;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.vml.Text;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.vml.Text;
        color(): string;
        color(color?: string): anychart.graphics.vector.vml.Text;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.vml.Text;
        decoration(): string;
        decoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.graphics.vector.vml.Text;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.vml.Text;
        direction(): string;
        direction(direction?: anychart.graphics.vector.Text.Direction | string): anychart.graphics.vector.vml.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.vml.Text;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(enabled?: boolean): anychart.graphics.vector.vml.Text;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.vml.Text;
        fontFamily(): string;
        fontFamily(family?: string): anychart.graphics.vector.vml.Text;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.graphics.vector.vml.Text;
        fontStyle(): string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.graphics.vector.vml.Text;
        fontVariant(): string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.graphics.vector.vml.Text;
        fontWeight(): string;
        fontWeight(weight?: string | number): anychart.graphics.vector.vml.Text;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTextHeight(): number;
        getTextWidth(): number;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hAlign(): string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.graphics.vector.vml.Text;
        hasParent(): boolean;
        height(): number | string;
        height(height?: number | string): anychart.graphics.vector.vml.Text;
        htmlText(): string;
        htmlText(value?: string): anychart.graphics.vector.vml.Text;
        id(): string;
        id(id?: string): anychart.graphics.vector.vml.Text;
        letterSpacing(): string;
        letterSpacing(spacing?: string | number): anychart.graphics.vector.vml.Text;
        lineHeight(): string;
        lineHeight(height?: string | number): anychart.graphics.vector.vml.Text;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        opacity(): number;
        opacity(opacity?: number): anychart.graphics.vector.vml.Text;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(parent?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.vml.Text;
        remove(): anychart.graphics.vector.vml.Text;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.vml.Text;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.vml.Text;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.vml.Text;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.vml.Text;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.graphics.vector.vml.Text;
        setPosition(x: number, y: number): anychart.graphics.vector.vml.Text;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.vml.Text;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.vml.Text;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.vml.Text;
        style(): anychart.graphics.vector.TextStyle;
        style(style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.vml.Text;
        text(): string;
        text(text?: string): anychart.graphics.vector.vml.Text;
        textIndent(): number;
        textIndent(indent?: number): anychart.graphics.vector.vml.Text;
        textOverflow(): string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.graphics.vector.vml.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.vml.Text;
        translate(tx: number, ty: number): anychart.graphics.vector.vml.Text;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        vAlign(): string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.graphics.vector.vml.Text;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.vml.Text;
        width(): number | string;
        width(width?: number | string): anychart.graphics.vector.vml.Text;
        wordBreak(): string | anychart.graphics.vector.Text.WordBreak;
        wordBreak(value?: string | anychart.graphics.vector.Text.WordBreak): anychart.graphics.vector.vml.Text;
        wordWrap(): string | anychart.graphics.vector.Text.WordWrap;
        wordWrap(value?: string | anychart.graphics.vector.Text.WordWrap): string | anychart.graphics.vector.vml.Text;
        x(): number;
        x(xCoord?: number): anychart.graphics.vector.vml.Text;
        y(): number;
        y(yCoord?: number): anychart.graphics.vector.vml.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.vml.Text;
        path(): anychart.graphics.vector.Path;
        path(path?: anychart.graphics.vector.Path): anychart.graphics.vector.vml.Text;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.math {
    function cycledQueue(lengthLimit?: number): anychart.math.CycledQueue;
    function rect(x: number, y: number, w: number, h: number): anychart.math.Rect;
    type CoordinateObject = {
        x: string | number;
        y: string | number;
    }
    interface CycledQueue {
        clear(newLengthLimit?: number): void;
        dequeue(): any;
        enqueue(item: any): any;
        get(index: number): any;
        getLength(): number;
    }
    interface Rect {
        getBottom(): number;
        getHeight(): number;
        getLeft(): number;
        getRight(): number;
        getTop(): number;
        getWidth(): number;
    }
}

declare namespace anychart.math.adl {
    function calculate(context: anychart.math.adl.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.adl.Context): void;
    function createComputer(mapping: anychart.data.TableMapping): anychart.data.TableComputer;
    function initContext(): anychart.math.adl.Context;
    function startFunction(context: anychart.math.adl.Context): void;
    type Context = {
        closeQueue: anychart.math.CycledQueue;
        dispose: number;
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        period: number;
        prevResult: number;
        volumeQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.ama {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.ama.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, fastPeriod?: number, slowPeriod?: number): anychart.data.TableComputer;
    function initContext(period?: number, fastPeriod?: number, slowPeriod?: number): anychart.math.ama.Context;
    function startFunction(context: anychart.math.ama.Context): void;
    type Context = {
        dispose: (() => void);
        fastPeriod: number;
        period: number;
        prevNoise: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
        slowPeriod: number;
    }
}

declare namespace anychart.math.ao {
    function calculate(context: anychart.math.ao.Context, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.ao.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string): anychart.data.TableComputer;
    function initContext(fastPeriod?: number, slowPeriod?: number, maType?: string): anychart.math.ao.Context;
    function startFunction(context: anychart.math.ao.Context): void;
    type Context = {
        dispose: (() => void);
        fastMAContext: anychart.math.sma.Context | anychart.math.ema.Context;
        maCalculate: (() => void);
        maType: string;
        slowMAContext: anychart.math.sma.Context | anychart.math.ema.Context;
    }
}

declare namespace anychart.math.aroon {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.aroon.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.aroon.Context;
    function startFunction(context: anychart.math.aroon.Context): void;
    type Context = {
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        period: number;
    }
}

declare namespace anychart.math.atr {
    function calculate(context: anychart.math.atr.Context, close: number, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.atr.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.atr.Context;
    function startFunction(context: anychart.math.atr.Context): void;
    type Context = {
        dequeuedValue: number;
        dispose: (() => void);
        period: number;
        prevClose: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.bbands {
    function calculate(context: anychart.math.bbands.Context, value: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.bbands.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, deviation?: number): anychart.data.TableComputer;
    function initContext(period?: number, deviation?: number): anychart.math.bbands.Context;
    function startFunction(context: anychart.math.bbands.Context): void;
    type Context = {
        dequeuedValue: number;
        deviation: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        period: number;
        prevDeviation: number;
        prevResult: number;
    }
}

declare namespace anychart.math.bbandsB {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.bbandsB.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, deviation?: number): anychart.data.TableComputer;
    function initContext(period?: number, deviation?: number): anychart.math.bbandsB.Context;
    function startFunction(context: anychart.math.bbandsB.Context): void;
    type Context = {
        deviation: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        period: number;
        prevDeviation: number;
        prevResult: number;
    }
}

declare namespace anychart.math.bbandsWidth {
    function calculate(context: anychart.math.bbandsWidth.Context, value: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.bbandsWidth.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, deviation?: number): anychart.data.TableComputer;
    function initContext(period?: number, deviation?: number): anychart.math.bbandsWidth.Context;
    function startFunction(context: anychart.math.bbandsWidth.Context): void;
    type Context = {
        dequeuedValue: number;
        deviation: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        period: number;
        prevDeviation: number;
        prevResult: number;
    }
}

declare namespace anychart.math.cci {
    function calculate(context: anychart.math.cci.Context, close: number, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.cci.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.cci.Context;
    function startFunction(context: anychart.math.cci.Context): void;
    type Context = {
        dequeuedValue: number;
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.cho {
    function calculate(context: anychart.math.cho.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.cho.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, maType?: string): anychart.data.TableComputer;
    function initContext(fastPeriod?: number, slowPeriod?: number, maType?: string): anychart.math.cho.Context;
    function startFunction(context: anychart.math.cho.Context): void;
    type Context = {
        adlContext: anychart.math.adl.Context;
        dispose: (() => void);
        fastMAContext: anychart.math.ema.Context | anychart.math.sma.Context;
        maCalculate: (() => void);
        maType: string;
        slowMAContext: anychart.math.ema.Context | anychart.math.sma.Context;
    }
}

declare namespace anychart.math.cmf {
    function calculate(context: anychart.math.cmf.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.cmf.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.cmf.Context;
    function startFunction(context: anychart.math.cmf.Context): void;
    type Context = {
        dispose: (() => void);
        mfvQueue: anychart.math.CycledQueue;
        period: number;
        prevMFVSum: number;
        prevVolumeSum: number;
        volumeQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.dmi {
    function calculate(context: anychart.math.dmi.Context, close: number, high: number, low: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.dmi.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, adxPeriod?: number, useWildersSmoothing?: boolean): anychart.data.TableComputer;
    function initContext(period?: number, adxPeriod?: number, useWildersSmoothing?: boolean): anychart.math.dmi.Context;
    function startFunction(context: anychart.math.dmi.Context): void;
    type Context = {
        adxAlpha: number;
        adxPeriod: number;
        adxQueue: anychart.math.CycledQueue;
        adxValue: number;
        alpha: number;
        closeQueue: anychart.math.CycledQueue;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        ndiSumValue: number;
        ndiValue: number;
        pdiSumValue: number;
        pdiValue: number;
        period: number;
        trSumValue: number;
        useWildersSmoothing: boolean;
    }
}

declare namespace anychart.math.ema {
    function calculate(context: anychart.math.ema.Context, value: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.ema.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.ema.Context;
    function startFunction(context: anychart.math.ema.Context): void;
    type Context = {
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.ha {
    function calculate(context: anychart.math.ha.Context, open: number, high: number, low: number, close: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.ha.Context): void;
    function createComputer(mapping: anychart.data.TableMapping): anychart.data.TableComputer;
    function initContext(): anychart.math.ha.Context;
    function startFunction(context: anychart.math.ha.Context): void;
    type Context = {
        closeQueue: anychart.math.CycledQueue;
        dispose: (() => void);
        openQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.kdj {
    function calculate(context: anychart.math.kdj.Context, close: number, high: number, low: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.kdj.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string, kMultiplier?: number, dMultiplier?: number): anychart.data.TableComputer;
    function initContext(kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string, kMultiplier?: number, dMultiplier?: number): anychart.math.kdj.Context;
    function startFunction(context: anychart.math.kdj.Context): void;
    type Context = {
        dMACalculate: (() => void);
        dMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        dMAType: string;
        dMultiplier: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        kMACalculate: (() => void);
        kMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        kMAType: string;
        kMultiplier: number;
        kPeriod: number;
        lowQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.keltnerChannels {
    function calculate(context: anychart.math.keltnerChannels.Context, close: number, high: number, low: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.keltnerChannels.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, maPeriod?: number, atrPeriod?: number, maType?: string, multiplier?: number): anychart.data.TableMapping;
    function initContext(maPeriod?: number, atrPeriod?: number, maType?: string, multiplier?: number): anychart.math.keltnerChannels.Context;
    function startFunction(context: anychart.math.keltnerChannels.Context): void;
    type Context = {
        atrContext: anychart.math.atr.Context;
        atrPeriod: number;
        dispose: (() => void);
        maCalculate: (() => void);
        maContext: anychart.math.ema.Context | anychart.math.sma.Context;
        maPeriod: number;
        maType: string;
        multiplier: number;
    }
}

declare namespace anychart.math.macd {
    function calculate(context: anychart.math.macd.Context, value: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.macd.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number): anychart.data.TableComputer;
    function initContext(fastPeriod?: number, slowPeriod?: number, signalPeriod?: number): anychart.math.macd.Context;
    function startFunction(context: anychart.math.macd.Context): void;
    type Context = {
        dispose: (() => void);
        fastPeriod: number;
        fastQueue: anychart.math.CycledQueue;
        fastResult: number;
        signalPeriod: number;
        signalQueue: anychart.math.CycledQueue;
        signalResult: number;
        slowPeriod: number;
        slowQueue: anychart.math.CycledQueue;
        slowResult: number;
    }
}

declare namespace anychart.math.mfi {
    function calculate(context: anychart.math.mfi.Context, close: number, high: number, low: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.mfi.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.mfi.Context;
    function startFunction(context: anychart.math.mfi.Context): void;
    type Context = {
        dispose: (() => void);
        lastValueSign: number;
        negativeFlow: number;
        period: number;
        positiveFlow: number;
        prevResult: number;
        priceQueue: anychart.math.CycledQueue;
        volumeQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.mma {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.mma.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.mma.Context;
    function startFunction(context: anychart.math.mma.Context): void;
    type Context = {
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.momentum {
    function calculate(context: anychart.math.momentum.Context, close: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.momentum.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.momentum.Context;
    function startFunction(context: anychart.math.momentum.Context): void;
    type Context = {
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.obv {
    function calculate(context: anychart.math.obv.Context, close: number, volume: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.obv.Context): void;
    function createComputer(mapping: anychart.data.TableMapping): anychart.data.TableComputer;
    function initContext(): anychart.math.obv.Context;
    function startFunction(context: anychart.math.obv.Context): void;
    type Context = {
        dispose: (() => void);
        prevCloseValue: number;
        prevObvValue: number;
    }
}

declare namespace anychart.math.priceChannels {
    function calculate(context: anychart.math.priceChannels.Context, high: number, low: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.priceChannels.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.priceChannels.Context;
    function startFunction(context: anychart.math.priceChannels.Context): void;
    type Context = {
        dispose: (() => void);
        highQueue: Array<number>;
        lowQueue: Array<number>;
        period: number;
    }
}

declare namespace anychart.math.psar {
    function calculate(context: anychart.math.psar.Context, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.psar.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, accelerationFactorStart?: number, accelerationFactorIncrement?: number, accelerationFactorMaximum?: number): anychart.data.TableComputer;
    function initContext(accelerationFactorStart?: number, accelerationFactorIncrement?: number, accelerationFactorMaximum?: number): anychart.math.psar.Context;
    function startFunction(context: anychart.math.psar.Context): void;
    type Context = {
        alpha: number;
        alphaIncrement: number;
        alphaMax: number;
        alphaStart: number;
        currentDownTrendEP: number;
        currentUpTrendEP: number;
        dequeuedHigh: number;
        dequeuedLow: number;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        isUptrend: boolean;
        lowQueue: anychart.math.CycledQueue;
        prevResult: number;
    }
}

declare namespace anychart.math.roc {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.roc.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.roc.Context;
    function startFunction(context: anychart.math.roc.Context): void;
    type Context = {
        dispose: (() => void);
        period: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.rsi {
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.rsi.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.rsi.Context;
    function startFunction(context: anychart.math.rsi.Context): void;
    type Context = {
        dispose: (() => void);
        downwardChange: number;
        period: number;
        queue: anychart.math.CycledQueue;
        upwardChange: number;
    }
}

declare namespace anychart.math.sma {
    function calculate(context: anychart.math.sma.Context, value: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.sma.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.sma.Context;
    function startFunction(context: anychart.math.sma.Context): void;
    type Context = {
        dequeuedValue: number;
        dispose: (() => void);
        period: number;
        prevResult: number;
        queue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.stochastic {
    function calculate(context: Object, closeValue: number, highValue: number, lowValue: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.stochastic.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string): anychart.data.TableComputer;
    function initContext(kPeriod?: number, kMAPeriod?: number, dPeriod?: number, kMAType?: string, dMAType?: string): anychart.math.stochastic.Context;
    function startFunction(context: anychart.math.stochastic.Context): void;
    type Context = {
        dMACalculate: (() => void);
        dMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        dMAType: string;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        kMACalculate: (() => void);
        kMAContext: anychart.math.sma.Context | anychart.math.ema.Context | Object;
        kMAType: string;
        kPeriod: number;
        lowQueue: anychart.math.CycledQueue;
    }
}

declare namespace anychart.math.trix {
    function calculate(context: anychart.math.trix.Context, value: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.trix.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number, signalPeriod?: number, maType?: string, signalMaType?: string): anychart.data.TableComputer;
    function initContext(period?: number, signalPeriod?: number, maType?: string, signalMaType?: string): anychart.math.trix.Context;
    function startFunction(context: anychart.math.trix.Context): void;
    type Context = {
        dispose: (() => void);
        firstMaContext: anychart.math.ema.Context | anychart.math.sma.Context;
        maCalculate: (() => void);
        maSignalCalculate: (() => void);
        maType: string;
        period: number;
        prevResult: number;
        secondMaContext: anychart.math.ema.Context | anychart.math.sma.Context;
        signalMaContext: anychart.math.ema.Context | anychart.math.sma.Context;
        signalMaType: string;
        signalPeriod: number;
        thirdMaContext: anychart.math.ema.Context | anychart.math.sma.Context;
    }
}

declare namespace anychart.math.volumeMA {
    function calculate(context: anychart.math.volumeMA.Context, volume: number): Array<number>;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.volumeMA.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, maPeriod?: number, maType?: string): anychart.data.TableComputer;
    function initContext(maPeriod?: number, maType?: string): anychart.math.volumeMA.Context;
    function startFunction(context: anychart.math.volumeMA.Context): void;
    type Context = {
        dispose: (() => void);
        maCalculate: (() => void);
        maContext: anychart.math.sma.Context | anychart.math.ema.Context;
        maPeriod: number;
        maType: string;
    }
}

declare namespace anychart.math.williamsR {
    function calculate(context: anychart.math.williamsR.Context, close: number, high: number, low: number): number;
    function calculationFunction(row: anychart.data.TableComputer.RowProxy, context: anychart.math.williamsR.Context): void;
    function createComputer(mapping: anychart.data.TableMapping, period?: number): anychart.data.TableComputer;
    function initContext(period?: number): anychart.math.williamsR.Context;
    function startFunction(context: anychart.math.williamsR.Context): void;
    type Context = {
        closeQueue: anychart.math.CycledQueue;
        dispose: (() => void);
        highQueue: anychart.math.CycledQueue;
        lowQueue: anychart.math.CycledQueue;
        period: number;
        prevResult: number;
    }
}

declare namespace anychart.palettes {
    const blue: Array<string>;
    const coffee: Array<string>;
    const defaultPalette: Array<string>;
    const earth: Array<string>;
    const glamour: Array<string>;
    const monochrome: Array<string>;
    const morning: Array<string>;
    const pastel: Array<string>;
    const provence: Array<string>;
    const sea: Array<string>;
    const turquoise: Array<string>;
    const v6: Array<string>;
    const wines: Array<string>;
    function distinctColors(): anychart.palettes.DistinctColors;
    function hatchFills(): anychart.palettes.HatchFills;
    function markers(): anychart.palettes.Markers;
    function rangeColors(): anychart.palettes.RangeColors;
    interface Markers extends anychart.core.Base {
        itemAt(index: number): string;
        itemAt(index: number, type?: string): anychart.palettes.Markers;
        items(): Array<string> | string;
        items(type?: Array<string> | string, ...var_args: (string)[]): anychart.palettes.Markers;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColors extends anychart.core.Base {
        count(): number;
        count(count?: number): anychart.palettes.RangeColors;
        itemAt(index: number): anychart.graphics.vector.SolidFill;
        itemAt(index: number, color?: anychart.graphics.vector.SolidFill): anychart.palettes.RangeColors;
        items(): Array<anychart.graphics.vector.SolidFill>;
        items(color?: Array<anychart.graphics.vector.SolidFill|Object> | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<anychart.graphics.vector.GradientKey> | Array<string> | anychart.graphics.vector.SolidFill | string, ...var_args: (anychart.graphics.vector.SolidFill | string)[]): anychart.palettes.RangeColors;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DistinctColors extends anychart.core.Base {
        itemAt(index: number): anychart.graphics.vector.Fill;
        itemAt(index: number, color?: anychart.graphics.vector.Fill): anychart.palettes.DistinctColors;
        items(): Array<anychart.graphics.vector.Fill>;
        items(color?: Array<anychart.graphics.vector.Fill> | anychart.graphics.vector.Fill, ...var_args: (anychart.graphics.vector.Fill)[]): anychart.palettes.DistinctColors;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface HatchFills extends anychart.core.Base {
        itemAt(index: number): anychart.graphics.vector.HatchFill | anychart.graphics.vector.PatternFill;
        itemAt(index: number, type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.palettes.HatchFills;
        itemAt(index: number, patternFill?: anychart.graphics.vector.PatternFill): anychart.palettes.HatchFills;
        itemAt(index: number, instance?: anychart.graphics.vector.HatchFill): anychart.palettes.HatchFills;
        itemAt(index: number, state?: boolean): anychart.palettes.HatchFills;
        items(): Array<anychart.graphics.vector.HatchFill|anychart.graphics.vector.HatchFill.HatchFillType|anychart.graphics.vector.PatternFill>;
        items(hatchFill?: Array<anychart.graphics.vector.HatchFill|anychart.graphics.vector.HatchFill.HatchFillType|anychart.graphics.vector.PatternFill>, ...var_args: (anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | anychart.graphics.vector.PatternFill)[]): anychart.palettes.HatchFills;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.scales {
    function calendar(parentCalendar?: anychart.scales.Calendar): anychart.scales.Calendar;
    function dateTime(): anychart.scales.DateTime;
    function linear(): anychart.scales.Linear;
    function linearColor(...var_args: (string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<string|anychart.graphics.vector.SolidFill|anychart.graphics.vector.LinearGradientFill|anychart.graphics.vector.RadialGradientFill>)[]): anychart.scales.LinearColor;
    function log(): anychart.scales.Logarithmic;
    function ordinal(): anychart.scales.Ordinal;
    function ordinalColor(colors?: Array<Object>): anychart.scales.OrdinalColor;
    interface DateTimeTicks extends anychart.core.Base {
        count(): number;
        count(count?: number): anychart.scales.DateTimeTicks;
        get(): Array<any>;
        getIntervalUnit(): string;
        getIntervalUnitCount(): number;
        interval(): string;
        interval(isoDate?: string): anychart.scales.DateTimeTicks;
        interval(unit?: string, count?: number): anychart.scales.DateTimeTicks;
        interval(years?: number, months?: number, days?: number, hours?: number, minutes?: number, seconds?: number): anychart.scales.DateTimeTicks;
        set(ticks: Array<any>): anychart.scales.DateTimeTicks;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Calendar extends anychart.core.Base {
        availabilities(): Array<anychart.scales.Calendar.Availability>;
        availabilities(availabilities?: Array<anychart.scales.Calendar.Availability>): anychart.scales.Calendar;
        getWorkingSchedule(startDate: number, endDate: number, unit?: string, count?: number): Array<anychart.scales.Calendar.ScheduleItem>;
        timezoneOffset(): Array<number>;
        timezoneOffset(var_offset: number): anychart.scales.Calendar;
        weekendRange(): Array<number>;
        weekendRange(var_range: Array<number>): anychart.scales.Calendar;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Calendar {
    type Availability = {
        each?: string;
        ends?: Date | number | string;
        from?: Date | number | string;
        isWorking?: boolean;
        on?: Date | number | string;
        starts?: Date | number | string;
        to?: Date | number | string;
    }
    type ScheduleItem = {
        end: number;
        start: number;
        workingTime: Array<Array<number>>;
    }
    }
    interface Linear extends anychart.scales.ScatterBase {
        alignMaximum(): boolean;
        alignMaximum(enabled?: boolean): anychart.scales.Linear;
        alignMinimum(): boolean;
        alignMinimum(enabled?: boolean): anychart.scales.Linear;
        compareWith(): string | number;
        compareWith(mode?: string | number | Date): anychart.scales.Linear;
        comparisonMode(): string;
        comparisonMode(mode?: string): anychart.scales.Linear;
        extendDataRange(...var_args: (any)[]): anychart.scales.Linear;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.Linear;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.Linear;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.Linear;
        maximumGap(): number;
        maximumGap(gap?: number): anychart.scales.Linear;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.Linear;
        minimumGap(): number;
        minimumGap(gap?: number): anychart.scales.Linear;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(settings?: Object | Array<any>): anychart.scales.Linear;
        softMaximum(): number;
        softMaximum(maximum?: number): anychart.scales.Linear;
        softMinimum(): number;
        softMinimum(minimum?: number): anychart.scales.Linear;
        stackDirection(): string;
        stackDirection(direction?: string): anychart.scales.Linear;
        stackMode(): string;
        stackMode(value?: string): anychart.scales.Linear;
        startAutoCalc(): anychart.scales.Linear;
        stickToZero(): boolean;
        stickToZero(enabled?: boolean): anychart.scales.Linear;
        ticks(): anychart.scales.ScatterTicks;
        ticks(settings?: Object | Array<any>): anychart.scales.Linear;
        transform(value: any): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Geo extends anychart.core.Base {
        extendDataRange(x: number, y: number, ...var_args: (any)[]): anychart.scales.Geo;
        gap(): number;
        gap(gap?: number): anychart.scales.Geo;
        getType(): string;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.Geo;
        maximumX(): number;
        maximumX(maximumX?: number): anychart.scales.Geo;
        maximumY(): number;
        maximumY(maximumY?: number): anychart.scales.Geo;
        minimumX(): number;
        minimumX(minimumX?: number): anychart.scales.Geo;
        minimumY(): number;
        minimumY(minimumY?: number): anychart.scales.Geo;
        precision(): Array<number>;
        precision(precision?: Array<number>): anychart.scales.Geo;
        precision(xPrecision?: number, yPrecision?: number): anychart.scales.Geo;
        xMinorTicks(): anychart.scales.GeoTicks;
        xMinorTicks(settings?: Object | Array<any>): anychart.scales.Geo;
        xTicks(): anychart.scales.GeoTicks;
        xTicks(settings?: Object | Array<any>): anychart.scales.Geo;
        yMinorTicks(): anychart.scales.GeoTicks;
        yMinorTicks(settings?: Object | Array<any>): anychart.scales.Geo;
        yTicks(): anychart.scales.GeoTicks;
        yTicks(settings?: Object | Array<any>): anychart.scales.Geo;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ScatterTicks extends anychart.core.Base {
        allowFractional(): boolean;
        allowFractional(enabled?: boolean): anychart.scales.ScatterTicks;
        base(): number;
        base(baseValue?: number): anychart.scales.ScatterTicks;
        count(): number;
        count(count?: number): anychart.scales.ScatterTicks;
        count(minimumCount?: number, maximumCount?: number): anychart.scales.ScatterTicks;
        get(): Array<any>;
        interval(): number;
        interval(value?: number): anychart.scales.ScatterTicks;
        mode(): string;
        mode(mode?: string): anychart.scales.ScatterTicks;
        set(ticks: Array<any>): anychart.scales.ScatterTicks;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.Base {
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.Base;
        startAutoCalc(): anychart.scales.Base;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Ordinal extends anychart.scales.Base {
        extendDataRange(...var_args: (any)[]): anychart.scales.Ordinal;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.Ordinal;
        mode(): string;
        mode(mode?: string): anychart.scales.Ordinal;
        names(): Array<any>;
        names(names?: Array<any> | string): anychart.scales.Ordinal;
        startAutoCalc(): anychart.scales.Ordinal;
        ticks(): anychart.scales.OrdinalTicks;
        ticks(ticks?: Object | Array<any>): anychart.scales.Ordinal;
        transform(value: any, subRangeRatio?: number): number;
        values(): Array<number|string>;
        values(values?: Array<any> | any, ...var_args: (any)[]): anychart.scales.Ordinal;
        weights(): Array<number>;
        weights(weights?: Array<number>): anychart.scales.Ordinal;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OrdinalColor extends anychart.scales.Base {
        colorToValue(color: string): number;
        colors(): Array<string>;
        colors(colors?: Array<string>): anychart.scales.OrdinalColor;
        finishAutoCalc(silently?: boolean): boolean;
        getIndexByValue(value: number): number;
        getProcessedRanges(): Array<Object>;
        getRangeByValue(value: number): Object;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.OrdinalColor;
        names(): Array<any>;
        names(names?: Array<any> | string): anychart.scales.OrdinalColor;
        ranges(): Array<Object>;
        ranges(ranges?: Array<Object>): anychart.scales.OrdinalColor;
        startAutoCalc(): anychart.scales.OrdinalColor;
        ticks(): anychart.scales.OrdinalTicks;
        ticks(ticks?: Object | Array<any>): anychart.scales.OrdinalColor;
        transform(value: any, subRangeRatio?: number): number;
        valueToColor(value: number): string;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StockScatterDateTime extends anychart.core.Base {
        getFullMaximum(): number;
        getFullMinimum(): number;
        getGroupingUnit(): string;
        getGroupingUnitCount(): number;
        getMaximum(): number;
        getMinimum(): number;
        inverseTransform(ratio: number): number;
        maximumGap(): anychart.scales.StockScatterDateTime.GapConfig;
        maximumGap(maxGap?: anychart.scales.StockScatterDateTime.GapConfig): anychart.scales.StockScatterDateTime;
        minimumGap(): anychart.scales.StockScatterDateTime.GapConfig;
        minimumGap(minGap?: anychart.scales.StockScatterDateTime.GapConfig): anychart.scales.StockScatterDateTime;
        ticks(): anychart.scales.StockScatterDateTime.TicksSettings;
        ticks(ticks?: anychart.scales.StockScatterDateTime.TicksSettings): anychart.scales.StockScatterDateTime;
        ticksCount(): number;
        ticksCount(count?: number): anychart.scales.StockScatterDateTime;
        transform(value: number | string | Date): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace StockScatterDateTime {
    type TicksSettings = {
        ticks: Array<{minor:string|{unit:string,count:number},major:string|{unit:string,count:number}}>;
    }
    type GapConfig = {
        intervalsCount: number;
        unitCount: number;
        unitType: string;
    }
    }
    interface DateTime extends anychart.scales.ScatterBase {
        alignMaximum(): boolean;
        alignMaximum(enabled?: boolean): anychart.scales.DateTime;
        alignMinimum(): boolean;
        alignMinimum(enabled?: boolean): anychart.scales.DateTime;
        extendDataRange(...var_args: (any)[]): anychart.scales.DateTime;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.DateTime;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.DateTime;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.DateTime;
        maximumGap(): number;
        maximumGap(gap?: number): anychart.scales.DateTime;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.DateTime;
        minimumGap(): number;
        minimumGap(gap?: number): anychart.scales.DateTime;
        minorTicks(): anychart.scales.DateTimeTicks;
        minorTicks(settings?: Object | Array<any>): anychart.scales.DateTime;
        softMaximum(): number;
        softMaximum(maximum?: number): anychart.scales.DateTime;
        softMinimum(): number;
        softMinimum(minimum?: number): anychart.scales.DateTime;
        startAutoCalc(): anychart.scales.DateTime;
        ticks(): anychart.scales.DateTimeTicks;
        ticks(settings?: Object | Array<any>): anychart.scales.DateTime;
        transform(value: any): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ScatterBase extends anychart.scales.Base {
        alignMaximum(): boolean;
        alignMaximum(enabled?: boolean): anychart.scales.ScatterBase;
        alignMinimum(): boolean;
        alignMinimum(enabled?: boolean): anychart.scales.ScatterBase;
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.ScatterBase;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.ScatterBase;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.ScatterBase;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.ScatterBase;
        startAutoCalc(): anychart.scales.ScatterBase;
        transform(value: any): number;
        getType(): string;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OrdinalTicks extends anychart.core.Base {
        get(): Array<any>;
        interval(): number;
        interval(interval?: number): anychart.scales.OrdinalTicks;
        maxCount(): number;
        maxCount(count?: number): anychart.scales.OrdinalTicks;
        names(): Array<any>;
        names(names?: Array<any>): anychart.scales.OrdinalTicks;
        set(ticks: Array<any>): anychart.scales.OrdinalTicks;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StockOrdinalDateTime extends anychart.scales.StockScatterDateTime {
        getFullMaximum(): number;
        getFullMinimum(): number;
        getGroupingUnit(): string;
        getGroupingUnitCount(): number;
        getMaximum(): number;
        getMinimum(): number;
        inverseTransform(ratio: number): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        maximumGap(): anychart.scales.StockScatterDateTime.GapConfig;
        maximumGap(maxGap?: anychart.scales.StockScatterDateTime.GapConfig): anychart.scales.StockOrdinalDateTime;
        minimumGap(): anychart.scales.StockScatterDateTime.GapConfig;
        minimumGap(minGap?: anychart.scales.StockScatterDateTime.GapConfig): anychart.scales.StockOrdinalDateTime;
        removeAllListeners(type?: string): number;
        transform(value: number | string | Date): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        ticks(): anychart.scales.StockScatterDateTime.TicksSettings;
        ticks(ticks?: anychart.scales.StockScatterDateTime.TicksSettings): anychart.scales.StockOrdinalDateTime;
        ticksCount(): number;
        ticksCount(count?: number): anychart.scales.StockOrdinalDateTime;
    }
    interface LinearColor extends anychart.scales.ScatterBase {
        colorToValue(color: string): number;
        colors(): Array<Object>;
        colors(...var_args: (string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<string|anychart.graphics.vector.SolidFill|anychart.graphics.vector.LinearGradientFill|anychart.graphics.vector.RadialGradientFill>)[]): anychart.scales.LinearColor;
        extendDataRange(...var_args: (any)[]): anychart.scales.LinearColor;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.LinearColor;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.LinearColor;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.LinearColor;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.LinearColor;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(ticks?: Object | Array<any>): anychart.scales.LinearColor;
        startAutoCalc(): anychart.scales.LinearColor;
        ticks(): anychart.scales.ScatterTicks;
        ticks(ticks?: Object | Array<any>): anychart.scales.LinearColor;
        valueToColor(value: number): string;
        alignMaximum(): boolean;
        alignMaximum(enabled?: boolean): anychart.scales.LinearColor;
        alignMinimum(): boolean;
        alignMinimum(enabled?: boolean): anychart.scales.LinearColor;
        inverseTransform(ratio: number): any;
        transform(value: any): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Logarithmic extends anychart.scales.Linear {
        alignMaximum(): boolean;
        alignMaximum(enabled?: boolean): anychart.scales.Logarithmic;
        alignMinimum(): boolean;
        alignMinimum(enabled?: boolean): anychart.scales.Logarithmic;
        compareWith(): string | number;
        compareWith(mode?: string | number | Date): anychart.scales.Logarithmic;
        comparisonMode(): string;
        comparisonMode(mode?: string): anychart.scales.Logarithmic;
        extendDataRange(...var_args: (any)[]): anychart.scales.Logarithmic;
        finishAutoCalc(silently?: boolean): boolean;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.Logarithmic;
        logBase(): number;
        logBase(baseValue?: number): anychart.scales.Logarithmic;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.Logarithmic;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.Logarithmic;
        maximumGap(): number;
        maximumGap(gap?: number): anychart.scales.Logarithmic;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.Logarithmic;
        minimumGap(): number;
        minimumGap(gap?: number): anychart.scales.Logarithmic;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(settings?: Object | Array<any>): anychart.scales.Logarithmic;
        softMaximum(): number;
        softMaximum(maximum?: number): anychart.scales.Logarithmic;
        softMinimum(): number;
        softMinimum(minimum?: number): anychart.scales.Logarithmic;
        stackDirection(): string;
        stackDirection(direction?: string): anychart.scales.Logarithmic;
        stackMode(): string;
        stackMode(value?: string): anychart.scales.Logarithmic;
        startAutoCalc(): anychart.scales.Logarithmic;
        stickToZero(): boolean;
        stickToZero(enabled?: boolean): anychart.scales.Logarithmic;
        ticks(): anychart.scales.ScatterTicks;
        ticks(settings?: Object | Array<any>): anychart.scales.Logarithmic;
        transform(value: any): number;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface GanttDateTime extends anychart.core.Base {
        fiscalYearOffset(): number;
        fiscalYearOffset(value?: number): anychart.scales.GanttDateTime;
        fiscalYearStartMonth(): number;
        fiscalYearStartMonth(value?: number): anychart.scales.GanttDateTime;
        getRange(): {[prop:string]:number};
        getTotalRange(): {[prop:string]:number};
        inverseTransform(ratio: number): number;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.GanttDateTime;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.GanttDateTime;
        maximumGap(): number | anychart.scales.GanttDateTime.Gap;
        maximumGap(gap?: number | anychart.scales.GanttDateTime.Gap, treatAsPixels?: boolean): anychart.scales.GanttDateTime;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.GanttDateTime;
        minimumGap(): number | anychart.scales.GanttDateTime.Gap;
        minimumGap(gap?: number | anychart.scales.GanttDateTime.Gap, treatAsPixels?: boolean): anychart.scales.GanttDateTime;
        softMaximum(): number;
        softMaximum(maximum?: number): anychart.scales.GanttDateTime;
        softMinimum(): number;
        softMinimum(minimum?: number): anychart.scales.GanttDateTime;
        transform(value: any): number;
        zoomLevels(): anychart.scales.GanttDateTime.ZoomLevelsSettings;
        zoomLevels(settings?: anychart.scales.GanttDateTime.ZoomLevelsSettings): anychart.scales.GanttDateTime;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace GanttDateTime {
    type Gap = {
        isPixels: boolean;
        value: number;
    }
    type ZoomLevelsSettings = Array<Array<string|string|{unit:string,count:number}>>;
    }
    interface DateTimeWithCalendar extends anychart.scales.ScatterBase {
        calendar(): anychart.scales.Calendar;
        calendar(calendar?: anychart.scales.Calendar): anychart.scales.DateTimeWithCalendar;
        count(): number;
        count(count?: number): anychart.scales.DateTimeWithCalendar;
        dateToPix(date: number | Date): number;
        extendDataRange(...var_args: (any)[]): anychart.scales.DateTimeWithCalendar;
        finishAutoCalc(silently?: boolean): boolean;
        getTicks(fromPix: number, toPix: number, unit?: string, count?: number): Array<anychart.scales.DateTimeWithCalendar.Tick>;
        getType(): string;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.scales.DateTimeWithCalendar;
        maxTicksCount(): number;
        maxTicksCount(count?: number): anychart.scales.DateTimeWithCalendar;
        maximum(): number;
        maximum(maximum?: number): anychart.scales.DateTimeWithCalendar;
        maximumGap(): number;
        maximumGap(gap?: number): anychart.scales.DateTime;
        minimum(): number;
        minimum(minimum?: number): anychart.scales.DateTimeWithCalendar;
        minimumGap(): number;
        minimumGap(gap?: number): anychart.scales.DateTime;
        pixToDate(pix: number): number;
        skipHolidays(): boolean;
        skipHolidays(enabled?: boolean): anychart.scales.DateTimeWithCalendar;
        softMaximum(): number;
        softMaximum(maximum?: number): anychart.scales.DateTime;
        softMinimum(): number;
        softMinimum(minimum?: number): anychart.scales.DateTime;
        startAutoCalc(): anychart.scales.DateTimeWithCalendar;
        startDate(): number;
        startDate(date?: number | Date): anychart.scales.DateTimeWithCalendar;
        transform(value: any): number;
        unit(): string;
        unit(interval?: string): anychart.scales.DateTimeWithCalendar;
        unitPixSize(): number | string;
        unitPixSize(size?: number | string): anychart.scales.DateTimeWithCalendar;
        alignMaximum(): boolean;
        alignMaximum(enabled?: boolean): anychart.scales.DateTimeWithCalendar;
        alignMinimum(): boolean;
        alignMinimum(enabled?: boolean): anychart.scales.DateTimeWithCalendar;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace DateTimeWithCalendar {
    type Tick = {
        end: number;
        holiday: boolean;
        start: number;
    }
    }
    interface GeoTicks extends anychart.core.Base {
        count(): number;
        count(count?: number): anychart.scales.GeoTicks;
        count(minimumCount?: number, maximumCount?: number): anychart.scales.GeoTicks;
        get(): Array<any>;
        interval(): number;
        interval(interval?: number): anychart.scales.GeoTicks;
        set(ticks: Array<any>): anychart.scales.GeoTicks;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.standalones {
    function background(): anychart.standalones.Background;
    function colorRange(): anychart.standalones.ColorRange;
    function dataGrid(): anychart.standalones.DataGrid;
    function label(): anychart.standalones.Label;
    function labelsFactory(): anychart.standalones.LabelsFactory;
    function legend(): anychart.standalones.Legend;
    function markersFactory(): anychart.standalones.MarkersFactory;
    function projectTimeline(): anychart.standalones.ProjectTimeline;
    function resourceList(data?: Array<Object>): anychart.standalones.ResourceList;
    function resourceTimeline(): anychart.standalones.ResourceTimeline;
    function scroller(): anychart.standalones.Scroller;
    function table(rowsCount?: number, colsCount?: number): anychart.standalones.Table;
    function title(): anychart.standalones.Title;
    interface ProjectTimeline extends anychart.core.ui.Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        backgroundFill(color: string, opacity?: number): anychart.standalones.ProjectTimeline;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ProjectTimeline;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ProjectTimeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        baselines(): anychart.core.gantt.elements.BaselinesElement;
        baselines(settings?: Object): anychart.standalones.ProjectTimeline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.standalones.ProjectTimeline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.standalones.ProjectTimeline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.standalones.ProjectTimeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.standalones.ProjectTimeline;
        columnStroke(settings?: Object): anychart.standalones.ProjectTimeline;
        connectors(): anychart.core.gantt.elements.ConnectorElement;
        connectors(settings?: Object): anychart.standalones.ProjectTimeline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.ProjectTimeline;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView, fillMethod?: string): anychart.standalones.ProjectTimeline;
        defaultRowHeight(): number;
        defaultRowHeight(height?: number): anychart.standalones.ProjectTimeline;
        draw(): anychart.standalones.ProjectTimeline;
        edit(): anychart.core.gantt.edit.StructureEdit;
        edit(settings?: Object | boolean): anychart.standalones.ProjectTimeline;
        elements(): anychart.core.gantt.elements.TimelineElement;
        elements(settings?: Object): anychart.standalones.ProjectTimeline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.ProjectTimeline;
        getPixelBounds(): anychart.math.Rect;
        groupingTasks(): anychart.core.gantt.elements.GroupingTasksElement;
        groupingTasks(settings?: Object): anychart.standalones.ProjectTimeline;
        header(): anychart.core.gantt.TimeLineHeader;
        header(value?: Object): anychart.standalones.ProjectTimeline;
        headerHeight(): number;
        headerHeight(height?: number): anychart.standalones.ProjectTimeline;
        height(): number | string;
        height(height?: number | string): anychart.standalones.ProjectTimeline;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(value?: Object): anychart.standalones.ProjectTimeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.standalones.ProjectTimeline;
        left(): number | string;
        left(left?: number | string): anychart.standalones.ProjectTimeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.standalones.ProjectTimeline;
        lineMarker(index?: number, value?: Object | boolean | string): anychart.standalones.ProjectTimeline;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.standalones.ProjectTimeline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.ProjectTimeline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.ProjectTimeline;
        milestones(): anychart.core.gantt.elements.MilestonesElement;
        milestones(settings?: Object): anychart.standalones.ProjectTimeline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.ProjectTimeline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.standalones.ProjectTimeline;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(paletteSettings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.standalones.ProjectTimeline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.ProjectTimeline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.ProjectTimeline;
        periods(): anychart.core.gantt.elements.PeriodsElement;
        periods(settings?: Object): anychart.standalones.ProjectTimeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.standalones.ProjectTimeline;
        rangeMarker(index?: number, value?: Object | boolean | string): anychart.standalones.ProjectTimeline;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.standalones.ProjectTimeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        rowEvenFill(color: string, opacity?: number): anychart.standalones.ProjectTimeline;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ProjectTimeline;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ProjectTimeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        rowFill(color: string, opacity?: number): anychart.standalones.ProjectTimeline;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ProjectTimeline;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ProjectTimeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        rowHoverFill(color: string, opacity?: number): anychart.standalones.ProjectTimeline;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ProjectTimeline;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ProjectTimeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        rowOddFill(color: string, opacity?: number): anychart.standalones.ProjectTimeline;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ProjectTimeline;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ProjectTimeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ProjectTimeline;
        rowSelectedFill(color: string, opacity?: number): anychart.standalones.ProjectTimeline;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.standalones.ProjectTimeline;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ProjectTimeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.ProjectTimeline;
        rowStroke(settings?: Object): anychart.standalones.ProjectTimeline;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: Object): anychart.standalones.ProjectTimeline;
        tasks(): anychart.core.gantt.elements.TasksElement;
        tasks(settings?: Object): anychart.standalones.ProjectTimeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.standalones.ProjectTimeline;
        textMarker(index?: number, value?: Object | boolean | string): anychart.standalones.ProjectTimeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.standalones.ProjectTimeline;
        top(): number | string;
        top(top?: number | string): anychart.standalones.ProjectTimeline;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalScrollBar(): anychart.core.ui.ScrollBar;
        verticalScrollBar(value?: Object): anychart.standalones.ProjectTimeline;
        width(): number | string;
        width(width?: number | string): anychart.standalones.ProjectTimeline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.ProjectTimeline;
        baselineMilestones(): anychart.core.gantt.elements.BaselineMilestonesElement;
        baselineMilestones(settings?: Object): anychart.standalones.ProjectTimeline;
        cropLabels(): boolean;
        cropLabels(value?: boolean): anychart.standalones.ProjectTimeline;
        holidaysFill(): anychart.graphics.vector.Fill;
        holidaysFill(value: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        notWorkingFill(): anychart.graphics.vector.Fill;
        notWorkingFill(value: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        weekendsFill(): anychart.graphics.vector.Fill;
        weekendsFill(value: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        workingFill(): anychart.graphics.vector.Fill;
        workingFill(value: anychart.graphics.vector.Fill): anychart.standalones.ProjectTimeline;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(isEnabled?: boolean): anychart.standalones.ProjectTimeline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
    }
    interface ResourceTimeline extends anychart.core.ui.Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        backgroundFill(color: string, opacity?: number): anychart.standalones.ResourceTimeline;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceTimeline;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceTimeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.standalones.ResourceTimeline;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.standalones.ResourceTimeline;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.standalones.ResourceTimeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.standalones.ResourceTimeline;
        columnStroke(settings?: Object): anychart.standalones.ResourceTimeline;
        connectors(): anychart.core.gantt.elements.ConnectorElement;
        connectors(settings?: Object): anychart.standalones.ResourceTimeline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.ResourceTimeline;
        data(): anychart.data.Tree | anychart.data.TreeView;
        data(data?: anychart.data.Tree | anychart.data.TreeView, fillMethod?: string): anychart.standalones.ResourceTimeline;
        defaultRowHeight(): number;
        defaultRowHeight(height?: number): anychart.standalones.ResourceTimeline;
        draw(): anychart.standalones.ResourceTimeline;
        edit(): anychart.core.gantt.edit.StructureEdit;
        edit(settings?: Object | boolean): anychart.standalones.ResourceTimeline;
        elements(): anychart.core.gantt.elements.TimelineElement;
        elements(settings?: Object): anychart.standalones.ResourceTimeline;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.ResourceTimeline;
        getPixelBounds(): anychart.math.Rect;
        header(): anychart.core.gantt.TimeLineHeader;
        header(value?: Object): anychart.standalones.ResourceTimeline;
        headerHeight(): number;
        headerHeight(height?: number): anychart.standalones.ResourceTimeline;
        height(): number | string;
        height(height?: number | string): anychart.standalones.ResourceTimeline;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(value?: Object): anychart.standalones.ResourceTimeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.standalones.ResourceTimeline;
        left(): number | string;
        left(left?: number | string): anychart.standalones.ResourceTimeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.standalones.ResourceTimeline;
        lineMarker(index?: number, value?: Object | boolean | string): anychart.standalones.ResourceTimeline;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.standalones.ResourceTimeline;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.ResourceTimeline;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.ResourceTimeline;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.ResourceTimeline;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.standalones.ResourceTimeline;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(paletteSettings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.standalones.ResourceTimeline;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.ResourceTimeline;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.ResourceTimeline;
        periods(): anychart.core.gantt.elements.PeriodsElement;
        periods(settings?: Object): anychart.standalones.ResourceTimeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.standalones.ResourceTimeline;
        rangeMarker(index?: number, value?: Object | boolean | string): anychart.standalones.ResourceTimeline;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(right?: number | string): anychart.standalones.ResourceTimeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        rowEvenFill(color: string, opacity?: number): anychart.standalones.ResourceTimeline;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceTimeline;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceTimeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        rowFill(color: string, opacity?: number): anychart.standalones.ResourceTimeline;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceTimeline;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceTimeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        rowHoverFill(color: string, opacity?: number): anychart.standalones.ResourceTimeline;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceTimeline;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceTimeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        rowOddFill(color: string, opacity?: number): anychart.standalones.ResourceTimeline;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceTimeline;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceTimeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceTimeline;
        rowSelectedFill(color: string, opacity?: number): anychart.standalones.ResourceTimeline;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.standalones.ResourceTimeline;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceTimeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.ResourceTimeline;
        rowStroke(settings?: Object): anychart.standalones.ResourceTimeline;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: Object): anychart.standalones.ResourceTimeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.standalones.ResourceTimeline;
        textMarker(index?: number, value?: Object | boolean | string): anychart.standalones.ResourceTimeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.standalones.ResourceTimeline;
        top(): number | string;
        top(top?: number | string): anychart.standalones.ResourceTimeline;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalScrollBar(): anychart.core.ui.ScrollBar;
        verticalScrollBar(value?: Object): anychart.standalones.ResourceTimeline;
        width(): number | string;
        width(width?: number | string): anychart.standalones.ResourceTimeline;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.ResourceTimeline;
        baselineMilestones(): anychart.core.gantt.elements.BaselineMilestonesElement;
        baselineMilestones(settings?: Object): anychart.standalones.ResourceTimeline;
        baselines(): anychart.core.gantt.elements.BaselinesElement;
        baselines(settings?: Object): anychart.standalones.ResourceTimeline;
        cropLabels(): boolean;
        cropLabels(value?: boolean): anychart.standalones.ResourceTimeline;
        groupingTasks(): anychart.core.gantt.elements.GroupingTasksElement;
        groupingTasks(settings?: Object): anychart.standalones.ResourceTimeline;
        holidaysFill(): anychart.graphics.vector.Fill;
        holidaysFill(value: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        milestones(): anychart.core.gantt.elements.MilestonesElement;
        milestones(settings?: Object): anychart.standalones.ResourceTimeline;
        notWorkingFill(): anychart.graphics.vector.Fill;
        notWorkingFill(value: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        tasks(): anychart.core.gantt.elements.TasksElement;
        tasks(settings?: Object): anychart.standalones.ResourceTimeline;
        weekendsFill(): anychart.graphics.vector.Fill;
        weekendsFill(value: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        workingFill(): anychart.graphics.vector.Fill;
        workingFill(value: anychart.graphics.vector.Fill): anychart.standalones.ResourceTimeline;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(isEnabled?: boolean): anychart.standalones.ResourceTimeline;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
    }
    interface DataGrid extends anychart.core.ui.DataGrid {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        backgroundFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        backgroundFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.standalones.DataGrid;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.standalones.DataGrid;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.standalones.DataGrid;
        buttons(): anychart.core.gantt.DataGridButton;
        buttons(settings?: Object): anychart.standalones.DataGrid;
        column(index?: number): anychart.core.ui.DataGrid.Column;
        column(settings?: anychart.core.ui.DataGrid.Column | Object): anychart.standalones.DataGrid;
        column(index?: number, settings?: anychart.core.ui.DataGrid.Column | Object): anychart.standalones.DataGrid;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(color?: anychart.graphics.vector.Stroke | string): anychart.standalones.DataGrid;
        columnStroke(settings?: Object): anychart.standalones.DataGrid;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: string | anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.DataGrid;
        data(): anychart.data.Tree;
        data(data?: anychart.data.Tree): anychart.standalones.DataGrid;
        defaultRowHeight(): number;
        defaultRowHeight(height?: number): anychart.standalones.DataGrid;
        draw(): anychart.standalones.DataGrid;
        edit(): anychart.core.gantt.edit.StructureEdit;
        edit(settings?: Object | boolean): anychart.standalones.DataGrid;
        editing(): boolean;
        editing(mode?: boolean): anychart.standalones.DataGrid;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.DataGrid;
        endIndex(): number;
        endIndex(index?: number): anychart.standalones.DataGrid;
        getPixelBounds(): anychart.math.Rect;
        getVisibleItems(): Array<anychart.data.Tree.DataItem>;
        headerFill(): anychart.graphics.vector.Fill | string;
        headerFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        headerFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        headerFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        headerFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        headerFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        headerHeight(): number;
        headerHeight(height?: number): anychart.standalones.DataGrid;
        height(): number | string;
        height(height?: number | string): anychart.standalones.DataGrid;
        horizontalOffset(): number;
        horizontalOffset(offset?: number): anychart.standalones.DataGrid;
        horizontalScrollBar(): anychart.core.ui.ScrollBar;
        horizontalScrollBar(settings?: Object): anychart.standalones.DataGrid;
        left(): number | string;
        left(left?: number | string): anychart.standalones.DataGrid;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.DataGrid;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.DataGrid;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.DataGrid;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.standalones.DataGrid;
        onEditEnd(): (()=>Object);
        onEditEnd(onEditEndFunction?: (()=>Object)): anychart.standalones.DataGrid;
        onEditStart(): (()=>Object);
        onEditStart(onEditStartFunction?: (()=>Object)): anychart.standalones.DataGrid;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.DataGrid;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.DataGrid;
        right(): number | string;
        right(right?: number | string): anychart.standalones.DataGrid;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        rowEvenFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        rowFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        rowFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        rowHoverFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        rowHoverFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        rowHoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        rowOddFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.DataGrid;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.DataGrid;
        rowSelectedFill(color: string, opacity?: number): anychart.standalones.DataGrid;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.standalones.DataGrid;
        rowSelectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.DataGrid;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.DataGrid;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.standalones.DataGrid;
        rowStroke(settings?: Object): anychart.standalones.DataGrid;
        startIndex(): number;
        startIndex(index?: number): anychart.standalones.DataGrid;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.standalones.DataGrid;
        top(): number | string;
        top(top?: number | string): anychart.standalones.DataGrid;
        verticalOffset(): number;
        verticalOffset(offset?: number): anychart.standalones.DataGrid;
        verticalScrollBar(): anychart.core.ui.ScrollBar;
        verticalScrollBar(settings?: Object): anychart.standalones.DataGrid;
        width(): number | string;
        width(width?: number | string): anychart.standalones.DataGrid;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.DataGrid;
        fixedColumns(): boolean;
        fixedColumns(value?: boolean): anychart.standalones.DataGrid;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MarkersFactory extends anychart.core.ui.MarkersFactory {
        add(positionProvider: any, index?: number): anychart.standalones.MarkersFactory;
        anchor(): string;
        anchor(anchor?: string): anychart.standalones.MarkersFactory;
        clear(index?: number): anychart.standalones.MarkersFactory;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.MarkersFactory;
        disablePointerEvents(value?: boolean): anychart.standalones.MarkersFactory | boolean;
        draw(): anychart.standalones.MarkersFactory;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.MarkersFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.MarkersFactory;
        fill(color: string, opacity?: number): anychart.standalones.MarkersFactory;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.MarkersFactory;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.MarkersFactory;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.MarkersFactory;
        measure(positionProvider: any): anychart.math.Rect;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.standalones.MarkersFactory;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.standalones.MarkersFactory;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.MarkersFactory;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.MarkersFactory;
        position(): string;
        position(position?: string): anychart.standalones.MarkersFactory;
        positionFormatter(): (() => void);
        positionFormatter(formatter?: ((positionProvider:any,index:number)=>anychart.math.CoordinateObject)): anychart.standalones.MarkersFactory;
        rotation(): number;
        rotation(rotation?: number): anychart.standalones.MarkersFactory;
        size(): number;
        size(size?: number): anychart.standalones.MarkersFactory;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.standalones.MarkersFactory;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.MarkersFactory;
        stroke(settings?: Object): anychart.standalones.MarkersFactory;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.standalones.MarkersFactory;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.MarkersFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    module MarkersFactory {
    interface Marker extends anychart.core.ui.MarkersFactory.Marker {
        anchor(): string;
        anchor(anchor?: string): anychart.standalones.MarkersFactory.Marker;
        clear(): void;
        draw(): anychart.standalones.MarkersFactory.Marker;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.MarkersFactory.Marker;
        fill(): anychart.graphics.vector.Fill | string;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.MarkersFactory.Marker;
        fill(color: string, opacity?: number): anychart.standalones.MarkersFactory.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.MarkersFactory.Marker;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.MarkersFactory.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.MarkersFactory.Marker;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.standalones.MarkersFactory.Marker;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.standalones.MarkersFactory.Marker;
        position(): string;
        position(position?: string): anychart.standalones.MarkersFactory.Marker;
        positionFormatter(): any;
        positionFormatter(formatter?: any): any;
        rotation(): number;
        rotation(angle?: number): anychart.standalones.MarkersFactory.Marker;
        size(): number;
        size(size?: number): anychart.standalones.MarkersFactory.Marker;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.standalones.MarkersFactory.Marker;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.MarkersFactory.Marker;
        stroke(settings?: Object): anychart.standalones.MarkersFactory.Marker;
        type(): string | (() => void);
        type(type?: string | (() => void)): anychart.standalones.MarkersFactory.Marker;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.MarkersFactory.Marker;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.MarkersFactory.Marker;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.MarkersFactory.Marker;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.MarkersFactory.Marker;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    }
    interface Scroller extends anychart.core.ui.Scroller {
        allowRangeChange(): boolean;
        allowRangeChange(enabled?: boolean): anychart.standalones.Scroller;
        autoHide(): boolean;
        autoHide(enabled?: boolean): anychart.standalones.Scroller;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.Scroller;
        draw(): anychart.standalones.Scroller;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.Scroller;
        endRatio(): number;
        endRatio(ratio?: number): anychart.standalones.Scroller;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.Scroller;
        fill(color: string, opacity?: number): anychart.standalones.Scroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.Scroller;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.Scroller;
        getRemainingBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.standalones.Scroller;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.standalones.Scroller;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.Scroller;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.Scroller;
        orientation(): string;
        orientation(orientation?: string): anychart.standalones.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Scroller;
        outlineStroke(settings?: Object): anychart.standalones.Scroller;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.standalones.Scroller;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Scroller;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.Scroller;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Scroller;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.Scroller;
        selectedFill(color: string, opacity?: number): anychart.standalones.Scroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.Scroller;
        selectedFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.Scroller;
        setRange(startRatio: number, endRatio: number): anychart.standalones.Scroller;
        startRatio(): number;
        startRatio(value?: number): anychart.standalones.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(settings?: boolean | Object): anychart.standalones.Scroller;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.Scroller;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ColorRange extends anychart.core.ui.ColorRange {
        align(): string;
        align(align?: string): anychart.standalones.ColorRange;
        colorLineSize(): number;
        colorLineSize(size?: number): anychart.standalones.ColorRange;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.ColorRange;
        draw(): anychart.standalones.ColorRange;
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.standalones.ColorRange;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.standalones.ColorRange;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.ColorRange;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.standalones.ColorRange;
        length(): number | string;
        length(length?: string | number): anychart.standalones.ColorRange;
        marker(): anychart.core.ui.MarkersFactory.Marker;
        marker(settings?: anychart.core.ui.MarkersFactory.Marker | Object): anychart.standalones.ColorRange;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.standalones.ColorRange;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.standalones.ColorRange;
        orientation(): string;
        orientation(orientation?: string): anychart.standalones.ColorRange;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.standalones.ColorRange;
        padding(): anychart.core.ui.table.Padding;
        padding(padding?: Array<number|string> | Object): anychart.standalones.ColorRange;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.ColorRange;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.ColorRange;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.ColorRange;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.standalones.ColorRange;
        staggerLines(): number;
        staggerLines(count?: number): anychart.standalones.ColorRange;
        staggerMaxLines(): number;
        staggerMaxLines(count?: number): anychart.standalones.ColorRange;
        staggerMode(): boolean;
        staggerMode(enabled?: boolean): anychart.standalones.ColorRange;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.ColorRange;
        stroke(settings?: Object): anychart.standalones.ColorRange;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.standalones.ColorRange;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.standalones.ColorRange;
        width(): number | string;
        width(width?: number | string): anychart.standalones.ColorRange;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.ColorRange;
        value(): number;
        value(value?: number): anychart.standalones.ColorRange;
        valueTarget(): anychart.standalones.ColorRange;
        valueTarget(target?: anychart.core.axes.Linear): anychart.standalones.ColorRange;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Label extends anychart.core.ui.Label {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.standalones.Label;
        anchor(): string;
        anchor(anchor?: string): anychart.standalones.Label;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.standalones.Label;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.Label;
        draw(): anychart.standalones.Label;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.Label;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.Label;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.standalones.Label;
        fontFamily(): string;
        fontFamily(family?: string): anychart.standalones.Label;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.standalones.Label;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.standalones.Label;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.standalones.Label;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.standalones.Label;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.standalones.Label;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.standalones.Label;
        height(): number | string;
        height(height?: number | string): anychart.standalones.Label;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.standalones.Label;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.standalones.Label;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.standalones.Label;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.standalones.Label;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.standalones.Label;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.standalones.Label;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.standalones.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Label;
        position(): string;
        position(position?: string): anychart.standalones.Label;
        rotation(): number;
        rotation(rotation?: number): anychart.standalones.Label;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.standalones.Label;
        text(): string;
        text(text?: string): anychart.standalones.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.standalones.Label;
        textIndent(): number;
        textIndent(indent?: number): anychart.standalones.Label;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.standalones.Label;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.standalones.Label;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.standalones.Label;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.Label;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.standalones.Label;
        width(): number | string;
        width(width?: number | string): anychart.standalones.Label;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.standalones.Label;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.standalones.Label;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.Label;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.standalones.Label;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Background extends anychart.core.ui.Background {
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.standalones.Background;
        bottomStroke(): anychart.graphics.vector.Stroke;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.standalones.Background;
        bottomStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Background;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.standalones.Background;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.standalones.Background;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.Background;
        cornerType(): string;
        cornerType(type?: string): anychart.standalones.Background;
        corners(): Array<number>;
        corners(corners?: number | string | Array<number>): anychart.standalones.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.standalones.Background;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.Background;
        draw(): anychart.standalones.Background;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.Background;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.Background;
        fill(color: string, opacity?: number): anychart.standalones.Background;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.Background;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.standalones.Background;
        left(): number | string;
        left(left?: number | string): anychart.standalones.Background;
        leftStroke(): anychart.graphics.vector.Stroke;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.standalones.Background;
        leftStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Background;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.Background;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.Background;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.Background;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.standalones.Background;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.Background;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Background;
        right(): number | string;
        right(right?: number | string): anychart.standalones.Background;
        rightStroke(): anychart.graphics.vector.Stroke;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.standalones.Background;
        rightStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Background;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.standalones.Background;
        stroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Background;
        top(): number | string;
        top(top?: number | string): anychart.standalones.Background;
        topStroke(): anychart.graphics.vector.Stroke;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | Object): anychart.standalones.Background;
        topStroke(color: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Background;
        width(): number | string;
        width(width?: number | string): anychart.standalones.Background;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.Background;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Legend extends anychart.core.ui.Legend {
        align(): string;
        align(align?: string): anychart.standalones.Legend;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.standalones.Legend;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.Legend;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.Legend;
        drag(): boolean;
        drag(enabled?: boolean): anychart.standalones.Legend;
        draw(): anychart.standalones.Legend;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.Legend;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.Legend;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.standalones.Legend;
        fontFamily(): string;
        fontFamily(family?: string): anychart.standalones.Legend;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.standalones.Legend;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.standalones.Legend;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.standalones.Legend;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.standalones.Legend;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.standalones.Legend;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.standalones.Legend;
        height(): number | string;
        height(height?: number | string): anychart.standalones.Legend;
        hoverCursor(): string;
        hoverCursor(cursorTypr?: string): anychart.standalones.Legend;
        iconSize(): number;
        iconSize(size?: number | string): anychart.standalones.Legend;
        iconTextSpacing(): number;
        iconTextSpacing(spacing?: string | number): anychart.standalones.Legend;
        inverted(): boolean;
        inverted(enabled?: boolean): anychart.standalones.Legend;
        items(): Array<anychart.core.ui.Legend.LegendItemProvider>;
        items(itemsList?: Array<anychart.core.ui.Legend.LegendItemProvider>): anychart.standalones.Legend;
        itemsFormat(): (() => void);
        itemsFormat(format?: ((value:Object)=>string) | string): anychart.standalones.Legend;
        itemsFormatter(): ((items:Array<anychart.core.ui.Legend.LegendItemProvider>)=>Array<anychart.core.ui.Legend.LegendItemProvider>);
        itemsFormatter(formatterFunction?: ((items:Array<anychart.core.ui.Legend.LegendItemProvider>)=>Array<anychart.core.ui.Legend.LegendItemProvider>)): anychart.standalones.Legend;
        itemsLayout(): string;
        itemsLayout(layout?: string): anychart.standalones.Legend;
        itemsSource(): anychart.core.SeparateChart | Array<anychart.core.SeparateChart>;
        itemsSource(source?: anychart.core.SeparateChart | Array<anychart.core.SeparateChart>): anychart.standalones.Legend;
        itemsSourceMode(): string;
        itemsSourceMode(mode?: string): anychart.standalones.Legend;
        itemsSpacing(): string | number;
        itemsSpacing(spacing?: string | number): anychart.standalones.Legend;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.standalones.Legend;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.standalones.Legend;
        margin(): anychart.core.utils.Margin;
        margin(margin?: Array<number|string> | Object | number | string): anychart.standalones.Legend;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Legend;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.Legend;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.Legend;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.standalones.Legend;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Legend;
        paginator(): anychart.core.ui.Paginator;
        paginator(settings?: Object | boolean): anychart.standalones.Legend;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.Legend;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Legend;
        position(): string;
        position(position?: string): anychart.standalones.Legend;
        positionMode(): string;
        positionMode(mode?: string): anychart.standalones.Legend;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.standalones.Legend;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.standalones.Legend;
        textIndent(): number;
        textIndent(indent?: number): anychart.standalones.Legend;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.standalones.Legend;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.standalones.Legend;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.standalones.Legend;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.standalones.Legend;
        titleFormat(): string | (() => void);
        titleFormat(format?: string | (() => void)): anychart.standalones.Legend;
        titleSeparator(): anychart.core.ui.Separator;
        titleSeparator(settings?: Object | boolean): anychart.standalones.Legend;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(settings?: Object | boolean): anychart.standalones.Legend;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.Legend;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.standalones.Legend;
        width(): number | string;
        width(width?: number | string): anychart.standalones.Legend;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.standalones.Legend;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.standalones.Legend;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.Legend;
        itemsHAlign(): string;
        itemsHAlign(hAlign?: string): anychart.standalones.Legend;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.standalones.Legend;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Title extends anychart.core.ui.Title {
        adjustFontSize(): number;
        adjustFontSize(adjustOrAdjustByWidth?: boolean | Array<boolean> | Object, adjustByHeight?: boolean): anychart.standalones.Title;
        align(): string;
        align(align?: string): anychart.standalones.Title;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.standalones.Title;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.standalones.Title;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.Title;
        draw(): anychart.standalones.Title;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.Title;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.Title;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.standalones.Title;
        fontFamily(): string;
        fontFamily(family?: string): anychart.standalones.Title;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.standalones.Title;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.standalones.Title;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.standalones.Title;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.standalones.Title;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.standalones.Title;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.standalones.Title;
        height(): number | string;
        height(height?: number | string): anychart.standalones.Title;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.standalones.Title;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.standalones.Title;
        margin(): anychart.core.utils.Margin;
        margin(allValues?: string | number | Array<number|string> | Object): anychart.standalones.Title;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Title;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.standalones.Title;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.standalones.Title;
        orientation(): string;
        orientation(orientation?: string): anychart.standalones.Title;
        padding(): anychart.core.utils.Padding;
        padding(paddinge?: string | number | Array<number|string> | Object): anychart.standalones.Title;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Title;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.Title;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Title;
        rotation(): number;
        rotation(rotation?: number): anychart.standalones.Title;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.standalones.Title;
        text(): string;
        text(text?: string): anychart.standalones.Title;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.standalones.Title;
        textIndent(): number;
        textIndent(indent?: number): anychart.standalones.Title;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.standalones.Title;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.standalones.Title;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.standalones.Title;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.Title;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.standalones.Title;
        width(): number | string;
        width(width?: number | string): anychart.standalones.Title;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.standalones.Title;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.standalones.Title;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.Title;
        maxLength(): number;
        maxLength(maxLength?: number): anychart.standalones.Title;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.standalones.Title;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Table extends anychart.core.ui.Table {
        border(): anychart.core.ui.table.Border;
        border(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Table;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.standalones.Table;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.standalones.Table;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.standalones.Table;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(colorSettings?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.Table;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.Table;
        cellFill(color: string, opacity?: number): anychart.standalones.Table;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.Table;
        cellFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.Table;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.Table;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(padding?: Array<number|string> | Object): anychart.standalones.Table;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.Table;
        colsCount(): number;
        colsCount(count?: number): anychart.standalones.Table;
        colsMaxWidth(): string | number;
        colsMaxWidth(width?: string | number): anychart.standalones.Table;
        colsMinWidth(): string | number;
        colsMinWidth(width?: string | number): anychart.standalones.Table;
        colsWidth(): string | number;
        colsWidth(width?: string | number): anychart.standalones.Table;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.Table;
        contents(): Array<Array<anychart.core.VisualBase>>;
        contents(tableValues?: Array<Array<anychart.core.VisualBase|string|number>>, demergeCells?: boolean): anychart.standalones.Table;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.Table;
        draw(): anychart.standalones.Table;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.Table;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.Table;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.standalones.Table;
        fontFamily(): string;
        fontFamily(family?: string): anychart.standalones.Table;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.standalones.Table;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.standalones.Table;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.standalones.Table;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.standalones.Table;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.standalones.Table;
        getCell(row: number, col: number): anychart.core.ui.table.Cell;
        getCol(col: number): anychart.core.ui.table.Column;
        getPixelBounds(): anychart.math.Rect;
        getRow(row: number): anychart.core.ui.table.Row;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.standalones.Table;
        height(): number | string;
        height(height?: number | string): anychart.standalones.Table;
        left(): number | string;
        left(left?: number | string): anychart.standalones.Table;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.standalones.Table;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.standalones.Table;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.Table;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.Table;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.Table;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.standalones.Table;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.Table;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.Table;
        right(): number | string;
        right(right?: number | string): anychart.standalones.Table;
        rowEvenFill(): anychart.graphics.vector.Fill;
        rowEvenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.Table;
        rowEvenFill(color: string, opacity?: number): anychart.standalones.Table;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.Table;
        rowEvenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.Table;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.Table;
        rowOddFill(): anychart.graphics.vector.Fill;
        rowOddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.Table;
        rowOddFill(color: string, opacity?: number): anychart.standalones.Table;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.Table;
        rowOddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.Table;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.Table;
        rowsCount(): number;
        rowsCount(count?: number): anychart.standalones.Table;
        rowsHeight(): string | number;
        rowsHeight(height?: string | number): anychart.standalones.Table;
        rowsMaxHeight(): string | number;
        rowsMaxHeight(height?: string | number): anychart.standalones.Table;
        rowsMinHeight(): string | number;
        rowsMinHeight(height?: string | number): anychart.standalones.Table;
        saveAsCsv(chartDataExportMode?: string, csvSettings?: {[prop:string]:string|boolean|((name:any,value:any)=>void)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(filename?: string): void;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.standalones.Table;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.standalones.Table;
        textIndent(): number;
        textIndent(indent?: number): anychart.standalones.Table;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.standalones.Table;
        toCsv(csvSettings?: {[prop:string]:string|boolean}): string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        top(): number | string;
        top(top?: number | string): anychart.standalones.Table;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.Table;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.standalones.Table;
        width(): number | string;
        width(width?: number | string): anychart.standalones.Table;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.standalones.Table;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.standalones.Table;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.Table;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(settings?: Object | boolean): anychart.standalones.Table;
        dispose(): void;
        exports(): anychart.core.utils.Exports;
        exports(settings?: Object): anychart.standalones.Table;
        fullScreen(): boolean;
        fullScreen(enabled?: boolean): anychart.standalones.Table;
        getJpgBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPngBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), width?: number, height?: number, quality?: number): void;
        getSvgBase64String(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        isFullScreenAvailable(): boolean;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        shareAsJpg(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: ((response:string)=>void), onError?: ((response:string)=>void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        shareWithFacebook(captionOrOptions?: string | Object, link?: string, name?: string, description?: string): void;
        shareWithLinkedIn(captionOrOptions?: string | Object, description?: string): void;
        shareWithPinterest(linkOrOptions?: string | Object, description?: string): void;
        shareWithTwitter(): void;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.standalones.Table;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface LabelsFactory extends anychart.core.ui.LabelsFactory {
        add(formatProvider: any, positionProvider: any, index?: number): anychart.core.ui.LabelsFactory.Label;
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.standalones.LabelsFactory;
        adjustFontSize(settings?: Object | Array<boolean> | boolean): anychart.standalones.LabelsFactory;
        anchor(): string;
        anchor(anchor?: string): anychart.standalones.LabelsFactory;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.standalones.LabelsFactory;
        clear(index?: number): anychart.standalones.LabelsFactory;
        clip(): anychart.graphics.vector.Shape | string | anychart.graphics.vector.Clip | anychart.math.Rect;
        clip(clipSettings?: anychart.graphics.vector.Shape | string | anychart.graphics.vector.Clip | anychart.math.Rect): anychart.standalones.LabelsFactory;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.LabelsFactory;
        draw(): anychart.standalones.LabelsFactory;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.LabelsFactory;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.LabelsFactory;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.standalones.LabelsFactory;
        fontFamily(): string;
        fontFamily(family?: string): anychart.standalones.LabelsFactory;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.standalones.LabelsFactory;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.standalones.LabelsFactory;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.standalones.LabelsFactory;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.standalones.LabelsFactory;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.standalones.LabelsFactory;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.standalones.LabelsFactory;
        height(): number | string;
        height(height?: number | string): anychart.standalones.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.standalones.LabelsFactory;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.standalones.LabelsFactory;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.standalones.LabelsFactory;
        measure(formatProviderOrLabel: any | anychart.core.ui.LabelsFactory.Label, positionProvider?: any, settings?: Object, cacheIndex?: number): anychart.math.Rect;
        measureWithTransform(formatProviderOrLabel: any | anychart.core.ui.LabelsFactory.Label, positionProvider?: any, settings?: Object, cacheIndexIndex?: number): Array<number>;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.standalones.LabelsFactory;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.standalones.LabelsFactory;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.standalones.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object | number | string): anychart.standalones.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.LabelsFactory;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.LabelsFactory;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.LabelsFactory;
        position(): string;
        position(position?: string): anychart.standalones.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(formatter?: (() => void)): anychart.standalones.LabelsFactory;
        rotation(): number;
        rotation(angle?: number): anychart.standalones.LabelsFactory;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.standalones.LabelsFactory;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.standalones.LabelsFactory;
        textIndent(): number;
        textIndent(indent?: number): anychart.standalones.LabelsFactory;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.standalones.LabelsFactory;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.LabelsFactory;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.standalones.LabelsFactory;
        width(): number | string;
        width(width?: number | string): anychart.standalones.LabelsFactory;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.standalones.LabelsFactory;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.standalones.LabelsFactory;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.LabelsFactory;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(color?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.standalones.LabelsFactory;
        connectorStroke(settings?: Object): anychart.standalones.LabelsFactory;
        format(): (() => void) | string;
        format(token?: string): anychart.standalones.LabelsFactory;
        format(func?: (() => void)): anychart.standalones.LabelsFactory;
        getLabel(index: number): anychart.core.ui.LabelsFactory.Label;
        getLabelsCount(): number;
        maxLength(): number;
        maxLength(maxLength?: number): anychart.standalones.LabelsFactory;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.standalones.LabelsFactory;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.standalones.LabelsFactory;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.standalones.LabelsFactory;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ResourceList extends anychart.core.resource.ResourceList {
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.standalones.ResourceList;
        bottom(): number | string;
        bottom(bottom?: number | string): anychart.standalones.ResourceList;
        bounds(): anychart.core.utils.Bounds;
        bounds(bounds?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.standalones.ResourceList;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.standalones.ResourceList;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.ResourceList;
        data(): anychart.data.View;
        data(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: string | anychart.data.TextParsingSettings): anychart.standalones.ResourceList;
        descriptions(): anychart.core.resource.resourceList.TextSettings;
        descriptions(settings?: Object): anychart.standalones.ResourceList;
        draw(): anychart.standalones.ResourceList;
        drawBottomLine(): boolean;
        drawBottomLine(enabled?: boolean): anychart.standalones.ResourceList;
        drawLeftLine(): boolean;
        drawLeftLine(enabled?: boolean): anychart.standalones.ResourceList;
        drawRightLine(): boolean;
        drawRightLine(enabled?: boolean): anychart.standalones.ResourceList;
        drawTopLine(): boolean;
        drawTopLine(enabled?: boolean): anychart.standalones.ResourceList;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.ResourceList;
        evenFill(): anychart.graphics.vector.Fill;
        evenFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceList;
        evenFill(color: string, opacity?: number): anychart.standalones.ResourceList;
        evenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceList;
        evenFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceList;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceList;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(height?: number | string): anychart.standalones.ResourceList;
        images(): anychart.core.resource.resourceList.ImageSettings;
        images(settings?: Object): anychart.standalones.ResourceList;
        left(): number | string;
        left(left?: number | string): anychart.standalones.ResourceList;
        maxHeight(): number | string;
        maxHeight(height?: number | string): anychart.standalones.ResourceList;
        maxRowHeight(): number;
        maxRowHeight(height?: number): anychart.standalones.ResourceList;
        maxWidth(): number | string;
        maxWidth(width?: number | string): anychart.standalones.ResourceList;
        minHeight(): number | string;
        minHeight(height?: number | string): anychart.standalones.ResourceList;
        minRowHeight(): number;
        minRowHeight(height?: number): anychart.standalones.ResourceList;
        minWidth(): number | string;
        minWidth(width?: number | string): anychart.standalones.ResourceList;
        names(): anychart.core.resource.resourceList.TextSettings;
        names(settings?: Object): anychart.standalones.ResourceList;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.ResourceList;
        oddFill(color: string, opacity?: number): anychart.standalones.ResourceList;
        oddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.ResourceList;
        oddFill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.ResourceList;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.ResourceList;
        overlay(): anychart.core.gantt.Overlay;
        overlay(settings?: string | Object | boolean): anychart.standalones.ResourceList;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.ResourceList;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.ResourceList;
        right(): number | string;
        right(right?: number | string): anychart.standalones.ResourceList;
        rowHeight(): number;
        rowHeight(height?: number): anychart.standalones.ResourceList;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.ResourceList;
        stroke(settings?: Object): anychart.standalones.ResourceList;
        tags(): anychart.core.resource.resourceList.TagsSettings;
        tags(settings?: Object): anychart.standalones.ResourceList;
        target(): anychart.charts.Resource;
        target(target?: anychart.charts.Resource): anychart.standalones.ResourceList;
        top(): number | string;
        top(top?: number | string): anychart.standalones.ResourceList;
        types(): anychart.core.resource.resourceList.TextSettings;
        types(settings?: Object): anychart.standalones.ResourceList;
        verticalScrollBarPosition(): number;
        verticalScrollBarPosition(position?: number): anychart.standalones.ResourceList;
        width(): number | string;
        width(width?: number | string): anychart.standalones.ResourceList;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.ResourceList;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.standalones.axes {
    function linear(): anychart.standalones.axes.Linear;
    function polar(): anychart.standalones.axes.Polar;
    function radar(): anychart.standalones.axes.Radar;
    function radial(): anychart.standalones.axes.Radial;
    interface Polar extends anychart.core.axes.Polar {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Polar;
        draw(): anychart.standalones.axes.Polar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axes.Polar;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.axes.Polar;
        fill(color: string, opacity?: number): anychart.standalones.axes.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.axes.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.axes.Polar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.axes.Polar;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.standalones.axes.Polar;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.standalones.axes.Polar;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.standalones.axes.Polar;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.standalones.axes.Polar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.axes.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Polar;
        scale(): anychart.scales.ScatterBase;
        scale(settings?: anychart.scales.ScatterBase | string | Object): anychart.standalones.axes.Polar;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.standalones.axes.Polar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.axes.Polar;
        stroke(settings?: Object): anychart.standalones.axes.Polar;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.standalones.axes.Polar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axes.Polar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Linear extends anychart.core.axes.Linear {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Linear;
        draw(): anychart.standalones.axes.Linear;
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.standalones.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.standalones.axes.Linear;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axes.Linear;
        getPixelBounds(): anychart.math.Rect;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.standalones.axes.Linear;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.standalones.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.standalones.axes.Linear;
        orientation(): string;
        orientation(orientation?: string): anychart.standalones.axes.Linear;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.standalones.axes.Linear;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.standalones.axes.Linear;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.axes.Linear;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.axes.Linear;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Linear;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.standalones.axes.Linear;
        staggerLines(): number;
        staggerLines(count?: number): anychart.standalones.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(count?: number): anychart.standalones.axes.Linear;
        staggerMode(): boolean;
        staggerMode(enabled?: boolean): anychart.standalones.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.axes.Linear;
        stroke(settings?: Object): anychart.standalones.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.standalones.axes.Linear;
        title(): anychart.core.ui.Title;
        title(settings?: boolean | Object | string): anychart.standalones.axes.Linear;
        width(): number | string;
        width(width?: number | string): anychart.standalones.axes.Linear;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axes.Linear;
        value(): number;
        value(value?: number): anychart.standalones.axes.Linear;
        valueTarget(): anychart.standalones.axes.Linear;
        valueTarget(target?: anychart.core.axes.Linear): anychart.standalones.axes.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Radial extends anychart.core.axes.Radial {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Radial;
        draw(): anychart.standalones.axes.Radial;
        drawFirstLabel(): boolean;
        drawFirstLabel(enabled?: boolean): anychart.standalones.axes.Radial;
        drawLastLabel(): boolean;
        drawLastLabel(enabled?: boolean): anychart.standalones.axes.Radial;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axes.Radial;
        innerRadius(): string | number;
        innerRadius(value?: string | number): anychart.standalones.axes.Radial;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.standalones.axes.Radial;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(settings?: Object | boolean): anychart.standalones.axes.Radial;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(settings?: Object | boolean): anychart.standalones.axes.Radial;
        overlapMode(): string;
        overlapMode(mode?: string): anychart.standalones.axes.Radial;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.standalones.axes.Radial;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Radial;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.standalones.axes.Radial;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.standalones.axes.Radial;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.axes.Radial;
        stroke(settings?: Object): anychart.standalones.axes.Radial;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.standalones.axes.Radial;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axes.Radial;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Radar extends anychart.core.axes.Radar {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axes.Radar;
        draw(): anychart.standalones.axes.Radar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axes.Radar;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(settings?: Object | boolean): anychart.standalones.axes.Radar;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.axes.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axes.Radar;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | string | Object): anychart.standalones.axes.Radar;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.standalones.axes.Radar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.axes.Radar;
        stroke(settings?: Object): anychart.standalones.axes.Radar;
        ticks(): anychart.core.axes.Ticks;
        ticks(settings?: Object | boolean): anychart.standalones.axes.Radar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axes.Radar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.standalones.axisMarkers {
    function line(): anychart.standalones.axisMarkers.Line;
    function range(): anychart.standalones.axisMarkers.Range;
    function text(): anychart.standalones.axisMarkers.Text;
    interface Text extends anychart.core.axisMarkers.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.annotations.Label;
        align(): string;
        align(align?: string): anychart.standalones.axisMarkers.Text;
        anchor(): string;
        anchor(anchor?: string): anychart.standalones.axisMarkers.Text;
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        background(): anychart.core.ui.Background;
        background(settings?: string | Object | boolean): anychart.standalones.axisMarkers.Text;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axisMarkers.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(enabled?: boolean): anychart.standalones.axisMarkers.Text;
        draw(): anychart.standalones.axisMarkers.Text;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axisMarkers.Text;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.axisMarkers.Text;
        fontColor(): string;
        fontColor(color?: string): anychart.standalones.axisMarkers.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.standalones.axisMarkers.Text;
        fontFamily(): string;
        fontFamily(family?: string): anychart.standalones.axisMarkers.Text;
        fontOpacity(): number;
        fontOpacity(opacity?: number): anychart.standalones.axisMarkers.Text;
        fontSize(): string | number;
        fontSize(size?: string | number): anychart.standalones.axisMarkers.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(style?: anychart.graphics.vector.Text.FontStyle | string): anychart.standalones.axisMarkers.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.standalones.axisMarkers.Text;
        fontWeight(): string | number;
        fontWeight(weight?: string | number): anychart.standalones.axisMarkers.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(align?: anychart.graphics.vector.Text.HAlign | string): anychart.standalones.axisMarkers.Text;
        height(): number | string;
        height(height?: number | string): anychart.standalones.axisMarkers.Text;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.standalones.axisMarkers.Text;
        letterSpacing(): string | number;
        letterSpacing(spacing?: string | number): anychart.standalones.axisMarkers.Text;
        lineHeight(): string | number;
        lineHeight(height?: string | number): anychart.standalones.axisMarkers.Text;
        maxFontSize(): number;
        maxFontSize(size?: number | string): anychart.standalones.axisMarkers.Text;
        minFontSize(): number;
        minFontSize(size?: number | string): anychart.standalones.axisMarkers.Text;
        offsetX(): number | string;
        offsetX(offset?: number | string): anychart.standalones.axisMarkers.Text;
        offsetY(): number | string;
        offsetY(offset?: number | string): anychart.standalones.axisMarkers.Text;
        padding(): anychart.core.utils.Padding;
        padding(padding?: Array<number|string> | Object): anychart.standalones.axisMarkers.Text;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.standalones.axisMarkers.Text;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.axisMarkers.Text;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axisMarkers.Text;
        position(): string;
        position(position?: string): anychart.standalones.axisMarkers.Text;
        rotation(): number;
        rotation(rotation?: number): anychart.standalones.axisMarkers.Text;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.standalones.axisMarkers.Text;
        scaleRangeMode(): string;
        scaleRangeMode(mode?: string): anychart.standalones.axisMarkers.Text;
        selectable(): boolean;
        selectable(enabled?: boolean): anychart.standalones.axisMarkers.Text;
        text(): string;
        text(text?: string): anychart.standalones.axisMarkers.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(direction?: anychart.graphics.vector.Text.Direction | string): anychart.standalones.axisMarkers.Text;
        textIndent(): number;
        textIndent(indent?: number): anychart.standalones.axisMarkers.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.standalones.axisMarkers.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.standalones.axisMarkers.Text;
        textSettings(name?: string, settings?: string | number | boolean | (() => void)): anychart.standalones.axisMarkers.Text;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.axisMarkers.Text;
        useHtml(): boolean;
        useHtml(enabled?: boolean): anychart.standalones.axisMarkers.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(align?: anychart.graphics.vector.Text.VAlign | string): anychart.standalones.axisMarkers.Text;
        value(): number;
        value(value?: number): anychart.standalones.axisMarkers.Text;
        width(): number | string;
        width(width?: number | string): anychart.standalones.axisMarkers.Text;
        wordBreak(): string;
        wordBreak(mode?: string): anychart.standalones.axisMarkers.Text;
        wordWrap(): string;
        wordWrap(mode?: string): anychart.standalones.axisMarkers.Text;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axisMarkers.Text;
        textShadow(): string;
        textShadow(textShadow?: anychart.graphics.vector.TextShadow | string): anychart.standalones.axisMarkers.Text;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Line extends anychart.core.axisMarkers.Line {
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.standalones.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axisMarkers.Line;
        draw(): anychart.standalones.axisMarkers.Line;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axisMarkers.Line;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.standalones.axisMarkers.Line;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.axisMarkers.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axisMarkers.Line;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.standalones.axisMarkers.Line;
        scaleRangeMode(): string;
        scaleRangeMode(mode?: string): anychart.standalones.axisMarkers.Line;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.axisMarkers.Line;
        stroke(settings?: Object): anychart.standalones.axisMarkers.Line;
        value(): number;
        value(newValue?: number): anychart.standalones.axisMarkers.Line;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axisMarkers.Line;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Range extends anychart.core.axisMarkers.Range {
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.axisMarkers.Range;
        draw(): anychart.standalones.axisMarkers.Range;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.axisMarkers.Range;
        fill(): anychart.graphics.vector.Fill;
        fill(color: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.axisMarkers.Range;
        fill(color: string, opacity?: number): anychart.standalones.axisMarkers.Range;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.axisMarkers.Range;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.axisMarkers.Range;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.axisMarkers.Range;
        from(): number;
        from(fromValue?: number): anychart.standalones.axisMarkers.Range;
        isHorizontal(): boolean;
        layout(): string;
        layout(layout?: string): anychart.standalones.axisMarkers.Range;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object): anychart.standalones.axisMarkers.Range;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.axisMarkers.Range;
        scale(): anychart.scales.Base;
        scale(settings?: anychart.scales.Base | Object | string): anychart.standalones.axisMarkers.Range;
        scaleRangeMode(): string;
        scaleRangeMode(mode?: string): anychart.standalones.axisMarkers.Range;
        to(): number;
        to(toValue?: number): anychart.standalones.axisMarkers.Range;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.axisMarkers.Range;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.standalones.grids {
    function linear(): anychart.core.grids.Linear;
    function polar(): anychart.standalones.grids.Polar;
    function radar(): anychart.standalones.grids.Radar;
    interface Polar extends anychart.core.grids.Polar {
        axis(): anychart.core.axes.Polar | anychart.core.axes.Radial;
        axis(axis?: anychart.core.axes.Polar | anychart.core.axes.Radial): anychart.standalones.grids.Polar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.grids.Polar;
        draw(): anychart.standalones.grids.Polar;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.standalones.grids.Polar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.grids.Polar;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.grids.Polar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.standalones.grids.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.grids.Polar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.grids.Polar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.grids.Polar;
        innerRadius(): string | number;
        innerRadius(radius?: string | number): anychart.standalones.grids.Polar;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.standalones.grids.Polar;
        isRadial(): boolean;
        layout(): string;
        layout(value?: string): anychart.standalones.grids.Polar;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.grids.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.grids.Polar;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.standalones.grids.Polar;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.standalones.grids.Polar;
        stroke(settings?: Object): anychart.standalones.grids.Polar;
        xScale(): anychart.scales.Linear;
        xScale(settings?: anychart.scales.Base | string | Object): anychart.standalones.grids.Polar;
        yScale(): anychart.scales.Base;
        yScale(settings?: anychart.scales.Base | string | Object): anychart.standalones.grids.Polar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.grids.Polar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Linear extends anychart.core.grids.Linear {
        axis(): anychart.core.axes.Linear;
        axis(axis?: anychart.core.axes.Linear): anychart.standalones.grids.Linear;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.grids.Linear;
        draw(): anychart.standalones.grids.Linear;
        drawFirstLine(): boolean;
        drawFirstLine(enabled?: boolean): anychart.standalones.grids.Linear;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.standalones.grids.Linear;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.grids.Linear;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.grids.Linear;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.standalones.grids.Linear;
        fill(color: string, opacity?: number): anychart.standalones.grids.Linear;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.grids.Linear;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.grids.Linear;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.grids.Linear;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.standalones.grids.Linear;
        layout(): string;
        layout(layout?: string): anychart.standalones.grids.Linear;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.standalones.grids.Linear;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.grids.Linear;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.grids.Linear;
        scale(): anychart.scales.Base;
        scale(settings?: Object | string | anychart.scales.Base): anychart.standalones.grids.Linear;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.standalones.grids.Linear;
        stroke(settings?: Object): anychart.standalones.grids.Linear;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.grids.Linear;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Radar extends anychart.core.grids.Radar {
        axis(): anychart.core.axes.Radar | anychart.core.axes.Radial;
        axis(axis?: anychart.core.axes.Radar | anychart.core.axes.Radial): anychart.standalones.grids.Radar;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(element?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.standalones.grids.Radar;
        draw(): anychart.standalones.grids.Radar;
        drawLastLine(): boolean;
        drawLastLine(enabled?: boolean): anychart.standalones.grids.Radar;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.standalones.grids.Radar;
        fill(): string | anychart.graphics.vector.Fill;
        fill(color?: anychart.graphics.vector.Fill | Array<anychart.graphics.vector.GradientKey|string>): anychart.standalones.grids.Radar;
        fill(fillFunction?: (()=>anychart.graphics.vector.Fill)): anychart.core.grids.Map;
        fill(color: string, opacity?: number): anychart.standalones.grids.Radar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.standalones.grids.Radar;
        fill(keys: Array<anychart.graphics.vector.GradientKey|string>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.standalones.grids.Radar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.standalones.grids.Radar;
        innerRadius(): string | number;
        innerRadius(radius?: string | number): anychart.standalones.grids.Radar;
        isMinor(): boolean;
        isMinor(enabled?: boolean): anychart.standalones.grids.Radar;
        isRadial(): boolean;
        layout(): string;
        layout(layout?: string): anychart.standalones.grids.Radar;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(settings?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.grids.Map;
        parentBounds(): anychart.math.Rect;
        parentBounds(bounds?: anychart.math.Rect | Object | number): anychart.standalones.grids.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.standalones.grids.Radar;
        startAngle(): string | number;
        startAngle(angle?: string | number): anychart.standalones.grids.Radar;
        stroke(settings?: Object): anychart.standalones.grids.Radar;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(color?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: string | anychart.graphics.vector.StrokeLineJoin, lineCap?: string | anychart.graphics.vector.StrokeLineCap): anychart.standalones.grids.Radar;
        stroke(settings?: Object): anychart.standalones.grids.Radar;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: anychart.scales.Ordinal | string | Object): anychart.standalones.grids.Radar;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | string | Object): anychart.standalones.grids.Radar;
        zIndex(): number;
        zIndex(zIndex?: number): anychart.standalones.grids.Radar;
        print(paperSizeOrOptions?: anychart.graphics.vector.PaperSize | Object, landscape?: boolean): void;
        listen(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: ((e:Object)=>void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.ui {
    function contextMenu(): anychart.ui.ContextMenu;
    function ganttToolbar(): anychart.ui.GanttToolbar;
    function preloader(): anychart.ui.Preloader;
    function rangePicker(): anychart.ui.RangePicker;
    function rangeSelector(): anychart.ui.RangeSelector;
    function zoom(): anychart.ui.Zoom;
    interface RangePicker {
        decorate(value: Element): void;
        dispose(): void;
        format(): string;
        format(format?: string): string;
        fromLabelText(): string;
        fromLabelText(text?: string): anychart.ui.RangePicker;
        getElement(): Element;
        render(parentElement?: anychart.charts.Stock | Element): void;
        target(chart: anychart.charts.Stock): void;
        toLabelText(): string;
        toLabelText(text?: string): anychart.ui.RangePicker;
    }
    interface Zoom {
        decorate(element: Element): void;
        dispose(): void;
        render(parentElement?: anychart.charts.Map | anychart.charts.Graph | anychart.charts.Timeline | Element): void;
        target(chart: anychart.charts.Map | anychart.charts.Graph | anychart.charts.Timeline): void;
    }
    interface RangeSelector {
        decorate(value: Element): void;
        dispose(): void;
        getElement(): Element;
        ranges(): Array<anychart.ui.RangeSelector.Range>;
        ranges(ranges?: Array<anychart.ui.RangeSelector.Range>): Array<anychart.ui.RangeSelector.Range>;
        render(parentElement?: anychart.charts.Stock | Element): void;
        target(chart: anychart.charts.Stock): void;
        zoomLabelText(): string;
        zoomLabelText(text?: string): anychart.ui.RangeSelector;
    }
    namespace RangeSelector {
    type Range = {
        anchor: string;
        count: number;
        endDate: string;
        startDate: string;
        text: string;
        type: string;
        unit: string;
    }
    }
    interface GanttToolbar {
        buttonsMode(): string;
        buttonsMode(mode: string): anychart.ui.GanttToolbar;
        container(): Element;
        container(element?: string | Element): anychart.ui.GanttToolbar;
        draw(): anychart.ui.GanttToolbar;
        printPaperSizes(): Array<anychart.graphics.vector.PaperSize>;
        printPaperSizes(paperSizeList?: Array<anychart.graphics.vector.PaperSize>): anychart.ui.GanttToolbar;
        target(): anychart.core.Chart;
        target(target?: anychart.core.Chart): anychart.ui.GanttToolbar;
        updateLocalizedCaptions(): anychart.ui.GanttToolbar;
    }
    interface Preloader {
        decorate(element: Element): void;
        render(parentElement?: Element): void;
        visible(): boolean;
        visible(enabled?: boolean): anychart.ui.Preloader;
    }
    interface ContextMenu {
        addClassName(className: string): void;
        attach(target: Element | anychart.core.Chart, capture?: boolean): anychart.ui.ContextMenu;
        detach(target?: Element, capture?: boolean): anychart.ui.ContextMenu;
        enabled(): boolean;
        enabled(enabled?: boolean): anychart.ui.ContextMenu;
        hide(): void;
        items(): Array<anychart.ui.ContextMenu.Item>;
        items(itemsList?: Array<anychart.ui.ContextMenu.Item>): anychart.ui.ContextMenu;
        itemsFormatter(): (() => void);
        itemsFormatter(formatter?: ((item1:Object,item2:Object,context:anychart.ui.ContextMenu.PrepareItemsContext)=>Object)): anychart.ui.ContextMenu;
        itemsProvider(): (() => void);
        itemsProvider(func?: ((itemsContext1:anychart.ui.ContextMenu.PrepareItemsContext,itemsContext2:anychart.ui.ContextMenu.PrepareItemsContext)=>Object)): anychart.ui.ContextMenu;
        listen(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): Object;
        removeClassName(className: string): void;
        serialize(): Object;
        setup(...var_args: (Object | Array<any> | number | string | boolean)[]): anychart.ui.ContextMenu;
        show(x: number, y: number): void;
        unlisten(type: string, listener: ((e:Object)=>boolean), useCapture?: boolean, listenerScope?: Object): boolean;
    }
    namespace ContextMenu {
    type Item = {
        action: (() => void);
        classNames: string | Array<string>;
        enabled: boolean;
        eventType: string;
        href: string;
        iconClass: string;
        index: number;
        meta: any;
        scrollable: boolean;
        subMenu: Array<anychart.ui.ContextMenu.Item>;
        target: string;
        text: string;
    }
    type ActionContext = {
        chart: anychart.core.Chart;
        event: Object;
        item: anychart.ui.ContextMenu.Item;
        selectedPoints: Array<anychart.core.Point>;
        target: Element | anychart.core.VisualBase;
        type: string;
    }
    type PrepareItemsContext = {
        chart: anychart.core.Chart;
        event: anychart.core.MouseEvent;
        menu: anychart.ui.ContextMenu;
        selectedPoints: Array<anychart.core.Point>;
        target: Element | anychart.core.VisualBase;
    }
    }
}

declare namespace anychart.ui.toolbar {
    interface Toolbar {
        container(element?: string | Element): anychart.ui.toolbar.Toolbar | Element;
        draw(): anychart.ui.toolbar.Toolbar;
        target(value?: anychart.core.Chart): anychart.ui.toolbar.Toolbar | anychart.core.Chart;
    }
}

declare namespace anychart.utils {
    function hideTooltips(force?: boolean): void;
    function htmlTableFromCsv(csv: string, title?: string, asString?: boolean, csvSettings?: Object): Element;
    function json2xml(json: Object | string, rootNodeName?: string, returnAsXmlNode?: boolean): string | Node;
    function xml2json(xml: string | Node): Object | string;
    type RectObj = {
        bottom: number | string;
        height: number | string;
        left: number | string;
        right: number | string;
        top: number | string;
        width: number | string;
    }
}